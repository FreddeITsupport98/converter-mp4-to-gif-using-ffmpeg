#!/bin/bash

# ============================================================================
# ðŸ”’ BASH SHELL ENFORCEMENT - This script REQUIRES bash
# ============================================================================
# This check runs immediately (even before any sourcing or subshells)
if [ -z "$BASH_VERSION" ]; then
    # Not running in bash - show helpful error and exit
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    âš ï¸  SHELL COMPATIBILITY ERROR                    â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "ðŸš« This script REQUIRES GNU Bash and cannot run in $(basename $SHELL)."
    echo ""
    echo "ðŸ“ Why? The script uses advanced bash features like:"
    echo "   â€¢ Associative arrays"
    echo "   â€¢ Parameter expansion (\${var//pattern/replace})"
    echo "   â€¢ Process substitution"
    echo "   â€¢ [[  ]] test syntax"
    echo "   â€¢ \${...} advanced substitution"
    echo ""
    echo "ðŸ’¡ How to fix this:"
    echo "   1. Run with bash explicitly:"
    echo "      bash $0"
    echo ""
    echo "   2. Or set bash as your default shell:"
    echo "      chsh -s /bin/bash"
    echo ""
    echo "   3. Then run the script normally:"
    echo "      ./$(basename $0)"
    echo ""
    echo "ðŸ“‹ Current shell:"
    echo "   SHELL variable: $SHELL"
    echo "   Running as: $(basename $0)"
    echo ""
    exit 1
fi

# ============================================================================
# ðŸ”” TERMINAL MONITOR - Detects when terminal closes and sends notifications
# ============================================================================
# This function runs in the background and monitors the parent terminal process
# When it detects the terminal has closed, it sends notifications about the tmux session

start_terminal_monitor() {
    local session_name="$1"
    local monitor_log="$HOME/.smart-gif-converter/terminal_monitor.log"
    
    # Verify notify-send is available
    if ! command -v notify-send >/dev/null 2>&1; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARNING: notify-send not found, notifications disabled" >> "$monitor_log" 2>/dev/null
        return 1
    fi
    
    # Create monitor script that will run independently
    local monitor_script="/tmp/gif_terminal_monitor_$$.sh"
    
    cat > "$monitor_script" << 'MONITOR_EOF'
#!/bin/bash
SESSION_NAME="__SESSION_NAME__"
MONITOR_LOG="__MONITOR_LOG__"
DBUS_SESSION="__DBUS_SESSION__"
DISPLAY_VAR="__DISPLAY_VAR__"

# Export DBUS and DISPLAY for notify-send to work from background
export DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION"
export DISPLAY="$DISPLAY_VAR"

# Create log directory
mkdir -p "$(dirname "$MONITOR_LOG")" 2>/dev/null

# Log start with environment info
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor started for session: $SESSION_NAME" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] DISPLAY: $DISPLAY_VAR" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] DBUS: ${DBUS_SESSION:0:50}..." >> "$MONITOR_LOG"

# Find the terminal process - improved detection including fish shell
find_terminal_pid() {
    local current_pid=$$
    local max_depth=30  # Increased depth for fish shell
    local depth=0
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting terminal PID search from PID: $current_pid" >> "$MONITOR_LOG"
    
    while [[ $depth -lt $max_depth ]]; do
        # Get parent PID
        local parent_pid=$(ps -o ppid= -p $current_pid 2>/dev/null | tr -d ' ')
        [[ -z "$parent_pid" || "$parent_pid" == "1" || "$parent_pid" == "0" ]] && break
        
        # Get process name and command line
        local proc_name=$(ps -o comm= -p $parent_pid 2>/dev/null | tr -d ' ')
        local proc_cmd=$(ps -o args= -p $parent_pid 2>/dev/null)
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [Depth $depth] PID $parent_pid: $proc_name ($proc_cmd)" >> "$MONITOR_LOG"
        
        # Check if this is a terminal emulator (expanded list including warp-terminal)
        if [[ "$proc_name" =~ ^(konsole|gnome-terminal|xterm|alacritty|kitty|wezterm|warp|warp-terminal|tilix|terminator|st|urxvt|rxvt|foot|contour)$ ]] || \
           [[ "$proc_cmd" =~ (konsole|gnome-terminal|xterm|alacritty|kitty|wezterm|warp|warp-terminal|tilix|terminator) ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Found terminal: $proc_name (PID: $parent_pid)" >> "$MONITOR_LOG"
            echo "$parent_pid"
            return 0
        fi
        
        current_pid=$parent_pid
        ((depth++))
    done
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ— No terminal found in process tree after $depth iterations" >> "$MONITOR_LOG"
    
    # Fallback: try to find terminal by session leader
    local session_leader=$(ps -o sid= -p $$ 2>/dev/null | tr -d ' ')
    if [[ -n "$session_leader" ]]; then
        local leader_name=$(ps -o comm= -p $session_leader 2>/dev/null)
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session leader: PID $session_leader ($leader_name)" >> "$MONITOR_LOG"
        if [[ "$leader_name" =~ (konsole|gnome-terminal|xterm|alacritty|kitty|wezterm|warp|warp-terminal|tilix|terminator) ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Using session leader as terminal PID" >> "$MONITOR_LOG"
            echo "$session_leader"
            return 0
        fi
    fi
    
    return 1
}

# Get terminal PID
TERMINAL_PID=$(find_terminal_pid)

if [[ -z "$TERMINAL_PID" ]]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: Could not find terminal PID - notifications will not work" >> "$MONITOR_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Process tree:" >> "$MONITOR_LOG"
    ps -ef --forest 2>/dev/null | grep -A 10 -B 5 "$$" >> "$MONITOR_LOG" 2>&1
    exit 1
fi

echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Monitoring terminal PID: $TERMINAL_PID" >> "$MONITOR_LOG"

NOTIFICATION_SENT=false

# Test notification immediately to ensure notify-send works
if command -v notify-send >/dev/null 2>&1; then
    notify-send -u low -t 3000 -i info \
        "ðŸ”” Terminal Monitor Active" \
        "Monitoring session: $SESSION_NAME\nWill notify INSTANTLY if terminal closes." \
        2>>"$MONITOR_LOG" &
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Test notification sent" >> "$MONITOR_LOG"
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: notify-send not available" >> "$MONITOR_LOG"
    exit 1
fi

# INSTANT monitoring: wait for terminal process to exit (no polling delay!)
# Background loop that checks tmux session periodically
(
    while tmux has-session -t "$SESSION_NAME" 2>/dev/null; do
        sleep 60  # Check tmux session every minute
    done
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Tmux session ended naturally" >> "$MONITOR_LOG"
) &
TMUX_MONITOR_PID=$!

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting INSTANT terminal exit monitoring..." >> "$MONITOR_LOG"

# Main monitoring: Use tail --pid to wait for terminal process exit
# This returns INSTANTLY when the terminal closes (no polling delay)
if command -v tail >/dev/null 2>&1; then
    # tail --pid waits until the process exits, then returns immediately
    tail --pid="$TERMINAL_PID" -f /dev/null 2>/dev/null
    TERMINAL_EXIT_CODE=$?
else
    # Fallback: poll with kill -0 (very fast polling)
    while kill -0 "$TERMINAL_PID" 2>/dev/null; do
        sleep 0.1  # Poll every 100ms for near-instant detection
    done
    TERMINAL_EXIT_CODE=0
fi

echo "[$(date '+%Y-%m-%d %H:%M:%S')] âš ï¸  Terminal closed INSTANTLY! Checking tmux session..." >> "$MONITOR_LOG"

# Terminal closed - check if tmux session still exists
if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Session still active, sending INSTANT notification" >> "$MONITOR_LOG"
    
    # Send persistent notification with urgency
    if notify-send -u critical -t 0 -i video-x-generic \
        "ðŸ’» Terminal Closed - Conversion Still Running!" \
        "Your GIF conversion is still active in tmux!\n\nðŸ“ Session: $SESSION_NAME\n\nðŸ”— To reconnect:\nâ€¢ Open terminal and run: ./convert.sh\nâ€¢ Or use: tmux attach -t $SESSION_NAME\n\nâœ… Your work is safe!" \
        2>>"$MONITOR_LOG"; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Initial notification sent successfully" >> "$MONITOR_LOG"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ— Failed to send notification (exit code: $?)" >> "$MONITOR_LOG"
    fi
    
    NOTIFICATION_SENT=true
    
    # Send periodic reminders
    while tmux has-session -t "$SESSION_NAME" 2>/dev/null; do
        sleep 600  # 10 minutes
        
        if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
            if notify-send -u normal -t 0 -i video-x-generic \
                "â° Reminder: Conversion Still Running" \
                "Session: $SESSION_NAME is still active.\n\nReconnect with: tmux attach -t $SESSION_NAME" \
                2>>"$MONITOR_LOG"; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Reminder notification sent" >> "$MONITOR_LOG"
            else
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ— Failed to send reminder" >> "$MONITOR_LOG"
            fi
        fi
    done
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session has ended (normal completion)" >> "$MONITOR_LOG"
fi

# Clean up background tmux monitor
kill $TMUX_MONITOR_PID 2>/dev/null

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor exiting" >> "$MONITOR_LOG"
exit 0
MONITOR_EOF

    # Substitute variables including DBUS session for notifications
    # Try multiple methods to detect DBUS session (works across all major desktop environments)
    local dbus_session="$DBUS_SESSION_BUS_ADDRESS"
    
    if [[ -z "$dbus_session" ]]; then
        # Method 1: Standard user bus (works on most modern systems)
        if [[ -S "/run/user/$(id -u)/bus" ]]; then
            dbus_session="unix:path=/run/user/$(id -u)/bus"
        # Method 2: Extract from desktop environment session processes
        # Ordered by popularity/likelihood
        elif [[ -n "$(pgrep -u $(id -u) 'plasmashell|kded5|kded6')" ]]; then
            # KDE Plasma
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) plasmashell | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) gnome-session)" ]]; then
            # GNOME
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) gnome-session | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) cinnamon-session)" ]]; then
            # Cinnamon (Linux Mint)
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) cinnamon-session | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) xfce4-session)" ]]; then
            # XFCE
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) xfce4-session | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) mate-session)" ]]; then
            # MATE
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) mate-session | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) budgie-panel)" ]]; then
            # Budgie
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) budgie-panel | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) lxqt-session)" ]]; then
            # LXQt
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) lxqt-session | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) lxsession)" ]]; then
            # LXDE
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) lxsession | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) gala)" ]]; then
            # Pantheon (elementary OS)
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) gala | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        elif [[ -n "$(pgrep -u $(id -u) deepin-wm)" ]]; then
            # Deepin
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) deepin-wm | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        # Method 3: Try dbus-daemon directly
        elif [[ -n "$(pgrep -u $(id -u) dbus-daemon)" ]]; then
            dbus_session=$(grep -z '^DBUS_SESSION_BUS_ADDRESS=' /proc/$(pgrep -u $(id -u) dbus-daemon | head -1)/environ 2>/dev/null | tr -d '\0' | cut -d'=' -f2-)
        # Method 4: Default fallback
        else
            dbus_session="unix:path=/run/user/$(id -u)/bus"
        fi
    fi
    
    local display_var="${DISPLAY:-:0}"
    
    sed -i "s|__SESSION_NAME__|$session_name|g" "$monitor_script"
    sed -i "s|__MONITOR_LOG__|$monitor_log|g" "$monitor_script"
    sed -i "s|__DBUS_SESSION__|$dbus_session|g" "$monitor_script"
    sed -i "s|__DISPLAY_VAR__|$display_var|g" "$monitor_script"
    
    chmod +x "$monitor_script"
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting terminal monitor for session: $session_name" >> "$monitor_log" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor script: $monitor_script" >> "$monitor_log" 2>/dev/null
    
    # Launch monitor in background WITHOUT setsid to preserve session context
    # This allows notifications to work by keeping DBUS and DISPLAY access
    # Just background it and disown to prevent it from being killed with the parent
    "$monitor_script" </dev/null &>/dev/null &
    local monitor_pid=$!
    disown 2>/dev/null || true
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor launched with PID: $monitor_pid" >> "$monitor_log" 2>/dev/null
    
    # Don't clean up the script immediately - let it run
    # Clean up old monitor scripts only
    (sleep 5; find /tmp -name "gif_terminal_monitor_*.sh" -mmin +60 -delete 2>/dev/null) &
}

# ============================================================================
# ðŸ›¡ï¸  TMUX PROTECTION - Auto-launch in tmux to prevent terminal crashes
# ============================================================================
# This prevents Konsole and other terminals from crashing due to large output
# Automatically launches in tmux with comprehensive error handling

# Configuration
TMUX_PROTECTION_ENABLED=true  # Set to false to disable auto-tmux
TMUX_MIN_VERSION="1.8"        # Minimum tmux version required

# ðŸ”” Notification Configuration (needed by tmux wrapper)
NOTIFY_ENABLED=true
NOTIFY_SESSION_START=true
NOTIFY_SESSION_FOUND=true
NOTIFY_TERMINAL_CLOSED=true

# ðŸš¨ Log directory (needed by terminal detection)
LOG_DIR="$HOME/.smart-gif-converter"
GIF_CONVERTER_DIR="$HOME/.smart-gif-converter"  # Main settings directory

# Check if tmux protection should run
if [[ "$TMUX_PROTECTION_ENABLED" == "true" ]] && [[ -z "$TMUX" ]] && [[ "$*" != *"--no-tmux"* ]]; then
    
    # Verify tmux is available
    if ! command -v tmux >/dev/null 2>&1; then
        # tmux not installed - offer to install like other dependencies
        echo -e "\033[1;33mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m" >&2
        echo -e "\033[1;33mâš ï¸  TERMINAL CRASH PROTECTION UNAVAILABLE\033[0m" >&2
        echo -e "\033[1;33mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m" >&2
        echo -e "\033[0;33m\nThis script produces large output that may crash some terminals (like Konsole).\033[0m" >&2
        echo -e "\033[0;36m\nðŸ’¡ tmux provides automatic crash protection and session persistence.\033[0m" >&2
        echo -e "\033[0;36m   Your conversions will survive terminal crashes and disconnects!\033[0m" >&2
        
        # Detect package manager and show appropriate install command
        pkg_mgr="unknown"
        install_cmd=""
        if command -v apt >/dev/null 2>&1; then
            pkg_mgr="apt"
            install_cmd="sudo apt update && sudo apt install -y tmux"
        elif command -v dnf >/dev/null 2>&1; then
            pkg_mgr="dnf"
            install_cmd="sudo dnf install -y tmux"
        elif command -v pacman >/dev/null 2>&1; then
            pkg_mgr="pacman"
            install_cmd="sudo pacman -S --needed tmux"
        elif command -v zypper >/dev/null 2>&1; then
            pkg_mgr="zypper"
            install_cmd="sudo zypper install -y tmux"
        elif command -v yum >/dev/null 2>&1; then
            pkg_mgr="yum"
            install_cmd="sudo yum install -y tmux"
        elif command -v apk >/dev/null 2>&1; then
            pkg_mgr="apk"
            install_cmd="sudo apk add tmux"
        else
            install_cmd="sudo <package-manager> install tmux"
        fi
        
        echo -e "\033[0;32m\nðŸ“¦ Install command: $install_cmd\033[0m" >&2
        echo -e "\033[0;36m\nAlternatively, use a more stable terminal (xterm, warp, alacritty)\033[0m" >&2
        echo -ne "\n\033[0;33mWould you like to install tmux now? [Y/n]: \033[0m" >&2
        read -r tmux_install_choice
        
        if [[ ! "$tmux_install_choice" =~ ^[Nn]$ ]]; then
            # User wants to install (default is Yes)
            echo -e "\n\033[0;36mðŸš€ Installing tmux...\033[0m" >&2
            if [[ "$pkg_mgr" == "unknown" ]]; then
                echo -e "\n\033[1;31mâŒ Cannot detect package manager!\033[0m" >&2
                echo -e "\033[0;33mðŸ“ Please install tmux manually\033[0m" >&2
            elif eval "$install_cmd"; then
                echo -e "\n\033[0;32mâœ… tmux installed successfully!\033[0m" >&2
                echo -e "\033[0;36mðŸ”„ Restarting script with tmux protection...\033[0m" >&2
                sleep 2
                # Re-exec script to apply tmux protection
                exec bash "$0" "$@"
            else
                echo -e "\n\033[1;31mâŒ Installation failed!\033[0m" >&2
                echo -ne "\n\033[0;33mContinue without crash protection? [y/N]: \033[0m" >&2
                read -r continue_anyway
                if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
                    echo -e "\033[0;36m\nðŸ’¡ Install tmux manually and run the script again.\033[0m" >&2
                    exit 1
                fi
            fi
        fi
        
        echo -e "\033[1;33mâš ï¸  Continuing without crash protection...\033[0m" >&2
        sleep 2
    else
        # tmux is available - validate and launch
        
        # Check tmux version
        TMUX_VERSION=$(tmux -V 2>/dev/null | grep -oE '[0-9]+\.[0-9]+' | head -1)
        if [[ -z "$TMUX_VERSION" ]]; then
            echo -e "\033[1;33mâš ï¸  Warning: Could not detect tmux version. Proceeding anyway...\033[0m" >&2
            sleep 1
        fi
        
        # Create unique session name with sanitization
        CURRENT_DIR="$(basename "$PWD" 2>/dev/null || echo 'unknown')"
        # Sanitize: remove special chars, limit length, add timestamp for uniqueness
        SANITIZED_DIR=$(echo "$CURRENT_DIR" | tr -cd '[:alnum:]-' | cut -c1-30)
        SESSION_NAME="gif-converter-${SANITIZED_DIR}"
        
        # Handle existing session
        if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
            # Session exists - ask user what to do
            echo -e "\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m"
            echo -e "\033[1;36mðŸ”„ Existing conversion session found!\033[0m"
            echo -e "\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m"
            echo -e "\n\033[0;33mSession name: \033[1m$SESSION_NAME\033[0m"
            echo -e "\n\033[0;36mYour options:\033[0m"
            echo -e "  \033[1;32m[1]\033[0m Attach to existing session (resume conversion)"
            echo -e "  \033[1;33m[2]\033[0m Create new session (start fresh conversion)"
            echo -e "  \033[1;31m[3]\033[0m Run without tmux (not recommended)"
            
            # Send persistent desktop notification
            if [[ "$NOTIFY_ENABLED" == "true" && "$NOTIFY_SESSION_FOUND" == "true" ]] && command -v notify-send >/dev/null 2>&1; then
                # Use -t 0 for persistent notification (stays until clicked)
                notify-send -u critical -t 0 -i video-x-generic \
                    "ðŸŽ¬ GIF Converter Still Running" \
                    "Your conversion session is active!\n\nSession: $SESSION_NAME\n\nClick here or run the script again to reconnect." \
                    2>/dev/null
                sleep 0.5
            fi
            
            echo -ne "\n\033[0;36mChoice [1/2/3, default=1]: \033[0m"
            read -r choice || choice="1"
            
            case "$choice" in
                2)
                    # Kill old session and create new one
                    echo -e "\033[0;33mðŸ—‘ï¸  Terminating old session...\033[0m"
                    tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
                    sleep 1
                    ;;
                3)
                    # User wants to run without tmux
                    echo -e "\033[1;33mâš ï¸  Running without crash protection...\033[0m"
                    exec bash "$0" "$@" --no-tmux
                    ;;
                *)
                    # Attach to existing session (default)
                    echo -e "\033[0;36mðŸ”— Attaching to existing session: $SESSION_NAME\033[0m"
                    sleep 1
                    exec tmux attach-session -t "$SESSION_NAME"
                    ;;
            esac
        fi
        
        # Create new tmux session
        echo -e "\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m"
        echo -e "\033[1;36mðŸ›¡ï¸  LAUNCHING TERMINAL CRASH PROTECTION\033[0m"
        echo -e "\033[0;36mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m"
        echo -e "\n\033[0;32mâœ“ tmux detected and available\033[0m"
        echo -e "\033[0;32mâœ“ Session name: \033[1m$SESSION_NAME\033[0m"
        echo -e "\n\033[0;36mðŸ“ Useful commands:\033[0m"
        echo -e "  \033[1;33mDetach:\033[0m     Ctrl+b then d (keeps conversion running)"
        echo -e "  \033[1;33mReattach:\033[0m   tmux attach -t $SESSION_NAME"
        echo -e "  \033[1;33mList:\033[0m       tmux ls"
        echo -e "  \033[1;33mTerminate:\033[0m  tmux kill-session -t $SESSION_NAME"
        echo -e "\n\033[0;33mðŸ’¡ Your conversion will survive terminal crashes and disconnects!\033[0m"
        echo ""
        
        # Animated countdown from 3 to 0
        for i in 3 2 1; do
            echo -ne "\r\033[0;36mLaunching in ${i} second$([ $i -ne 1 ] && echo 's' || echo '')...\033[0m"
            sleep 1
        done
        echo -ne "\r\033[0;32mâœ“ Starting tmux session now!          \033[0m\n\n"
        
        # Send desktop notification about tmux session starting
        echo -e "\033[0;33mDEBUG: NOTIFY_ENABLED=$NOTIFY_ENABLED, NOTIFY_SESSION_START=$NOTIFY_SESSION_START\033[0m" >&2
        if [[ "$NOTIFY_ENABLED" == "true" && "$NOTIFY_SESSION_START" == "true" ]] && command -v notify-send >/dev/null 2>&1; then
            echo -e "\033[0;32mDEBUG: Sending notification now...\033[0m" >&2
            notify-send -u normal -t 8000 -i video-x-generic \
                "ðŸ›¡ï¸ GIF Converter Running in tmux" \
                "Session: $SESSION_NAME\n\nYour conversion is protected from crashes!\n\nTo reconnect if disconnected:\nâ€¢ Run ./convert.sh again, or\nâ€¢ Use: tmux attach -t $SESSION_NAME" \
                2>/dev/null
            sleep 0.5
        fi
        
        # Detect terminal PID NOW (before entering tmux where we can't see it)
        MONITOR_DEBUG_LOG="$LOG_DIR/terminal-detect-debug.log"
        mkdir -p "$LOG_DIR" 2>/dev/null || true
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] === Terminal Detection (BEFORE tmux) ===" > "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Current PID: $$" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] NOTIFY_ENABLED: $NOTIFY_ENABLED" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] NOTIFY_TERMINAL_CLOSED: $NOTIFY_TERMINAL_CLOSED" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        
        TERMINAL_PID=""
        current_pid=$$
        depth=0
        while [[ $depth -lt 30 ]]; do
            parent_pid=$(ps -o ppid= -p $current_pid 2>/dev/null | tr -d ' ')
            [[ -z "$parent_pid" || "$parent_pid" == "1" || "$parent_pid" == "0" ]] && break
            
            # Check the PARENT process (moving up the tree)
            proc_name=$(ps -o comm= -p $parent_pid 2>/dev/null | tr -d ' ')
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Depth $depth: PID $parent_pid = $proc_name" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
            
            if [[ "$proc_name" =~ ^(konsole|gnome-terminal|xterm|alacritty|kitty|wezterm|warp|warp-terminal|tilix|terminator|st|urxvt|rxvt|foot|contour)$ ]]; then
                TERMINAL_PID=$parent_pid
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Found terminal: $proc_name (PID: $TERMINAL_PID)" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
                break
            fi
            
            current_pid=$parent_pid
            ((depth++))
        done
        
        if [[ -z "$TERMINAL_PID" ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ— No terminal found" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        fi
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] DISPLAY: ${DISPLAY:-NOT SET}" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] DBUS: ${DBUS_SESSION_BUS_ADDRESS:-NOT SET}" >> "$MONITOR_DEBUG_LOG" 2>/dev/null || true
        
        # Prepare script path and arguments
        SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || echo "$0")"
        SCRIPT_ARGS="$*"
        
        # Export notification settings and terminal PID for tmux wrapper to use
        export NOTIFY_ENABLED
        export NOTIFY_TERMINAL_CLOSED
        export SESSION_NAME
        export TERMINAL_PID
        export DISPLAY
        export DBUS_SESSION_BUS_ADDRESS
        
        # Create robust tmux wrapper script to avoid quoting issues and keep session open
        TMUX_WRAPPER="$(mktemp -t smart_gif_tmux_XXXXXX.sh)"
        cat > "$TMUX_WRAPPER" <<'TMUX_EOF'
#!/usr/bin/env bash
# Wrapper runs inside tmux. Keep pane alive and behave interactively after conversion.
# Make the current pane remain on exit as a safety net (won't hurt if unsupported)
if [ -n "$TMUX_PANE" ]; then
  tmux set-option -pt "$TMUX_PANE" remain-on-exit on >/dev/null 2>&1 || true
fi

# Start terminal monitor NOW (inside tmux session)
# TERMINAL_PID was detected BEFORE entering tmux and passed via environment
MONITOR_LOG="$HOME/.smart-gif-converter/monitor-inside-tmux.log"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] === Monitor Start (INSIDE tmux) ===" > "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] NOTIFY_ENABLED: $NOTIFY_ENABLED" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] NOTIFY_TERMINAL_CLOSED: $NOTIFY_TERMINAL_CLOSED" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] TERMINAL_PID: ${TERMINAL_PID:-NOT SET}" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] SESSION_NAME: $SESSION_NAME" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] DISPLAY: ${DISPLAY:-NOT SET}" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] DBUS: ${DBUS_SESSION_BUS_ADDRESS:-NOT SET}" >> "$MONITOR_LOG"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] notify-send available: $(command -v notify-send || echo 'NO')" >> "$MONITOR_LOG"

if [[ "$NOTIFY_ENABLED" == "true" && "$NOTIFY_TERMINAL_CLOSED" == "true" ]] && \
   [[ -n "$TERMINAL_PID" ]] && command -v notify-send >/dev/null 2>&1; then
    
    # Kill any existing monitor for this session using PID file
    MONITOR_PID_FILE="$HOME/.smart-gif-converter/monitor-${SESSION_NAME}.pid"
    if [[ -f "$MONITOR_PID_FILE" ]]; then
        OLD_MONITOR_PID=$(cat "$MONITOR_PID_FILE" 2>/dev/null)
        if [[ -n "$OLD_MONITOR_PID" ]] && kill -0 "$OLD_MONITOR_PID" 2>/dev/null; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Found old monitor PID: $OLD_MONITOR_PID, killing it" >> "$MONITOR_LOG"
            kill -9 "$OLD_MONITOR_PID" 2>/dev/null || true
            # Also kill any child processes
            pkill -P "$OLD_MONITOR_PID" 2>/dev/null || true
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Old monitor killed" >> "$MONITOR_LOG"
        else
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Old monitor PID file exists but process not running" >> "$MONITOR_LOG"
        fi
        rm -f "$MONITOR_PID_FILE" 2>/dev/null || true
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] No old monitor PID file found (first run or clean exit)" >> "$MONITOR_LOG"
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ All checks passed, starting monitor" >> "$MONITOR_LOG"
    
    # Start monitor in background
    (
        # Save monitor PID to file immediately
        echo $$ > "$MONITOR_PID_FILE"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor subprocess PID $$ started, waiting for PID $TERMINAL_PID to exit" >> "$MONITOR_LOG"
        
        # Wait for terminal to close
        tail --pid="$TERMINAL_PID" -f /dev/null 2>/dev/null || while kill -0 "$TERMINAL_PID" 2>/dev/null; do sleep 0.5; done
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Terminal $TERMINAL_PID has exited!" >> "$MONITOR_LOG"
        
        # Clean up our PID file since we're the active monitor that detected terminal exit
        rm -f "$MONITOR_PID_FILE" 2>/dev/null || true
        
        # Terminal closed - send notification if tmux session still exists
        if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Tmux session still active, starting reminder loop" >> "$MONITOR_LOG"
            
            # Create helper script for reconnecting
            RECONNECT_SCRIPT="$HOME/.smart-gif-converter/reconnect-tmux.sh"
            cat > "$RECONNECT_SCRIPT" << 'RECONNECT_EOF'
#!/bin/bash
# Ensure DISPLAY is set for GUI applications
export DISPLAY="__DISPLAY__"
export DBUS_SESSION_BUS_ADDRESS="__DBUS__"

SESSION="__SESSION_NAME__"

# Log the attempt
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Reconnect script called for session: $SESSION" >> "$HOME/.smart-gif-converter/reconnect.log"

if tmux has-session -t "$SESSION" 2>/dev/null; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session exists, launching terminal" >> "$HOME/.smart-gif-converter/reconnect.log"
    
    # Create restart-monitor script that will run inside tmux after reconnecting
    RESTART_MONITOR="$HOME/.smart-gif-converter/restart-monitor-$$\.sh"
    cat > "$RESTART_MONITOR" << 'RESTART_EOF'
#!/bin/bash
# Restart terminal monitor with NEW terminal PID
MONITOR_LOG="$HOME/.smart-gif-converter/monitor-inside-tmux.log"
SESSION="__SESSION__"

# Preserve display and dbus for notifications
export DISPLAY="__DISPLAY__"
export DBUS_SESSION_BUS_ADDRESS="__DBUS__"

# Find the NEW terminal PID (the one we just opened)
TERMINAL_PID=""
current_pid=$$
depth=0
while [[ $depth -lt 30 ]]; do
    parent_pid=$(ps -o ppid= -p $current_pid 2>/dev/null | tr -d ' ')
    [[ -z "$parent_pid" || "$parent_pid" == "1" || "$parent_pid" == "0" ]] && break
    
    proc_name=$(ps -o comm= -p $current_pid 2>/dev/null | tr -d ' ')
    
    if [[ "$proc_name" =~ ^(konsole|gnome-terminal|xterm|alacritty|kitty|wezterm|warp|warp-terminal|tilix|terminator|st|urxvt|rxvt|foot|contour)$ ]]; then
        TERMINAL_PID=$current_pid
        break
    fi
    
    current_pid=$parent_pid
    ((depth++))
done

if [[ -n "$TERMINAL_PID" ]]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Restarting monitor for new terminal PID: $TERMINAL_PID" >> "$MONITOR_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DISPLAY: ${DISPLAY:-NOT SET}" >> "$MONITOR_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DBUS: ${DBUS_SESSION_BUS_ADDRESS:-NOT SET}" >> "$MONITOR_LOG"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] notify-send: $(command -v notify-send || echo 'NOT FOUND')" >> "$MONITOR_LOG"
    
    # Kill any existing monitor using PID file
    MONITOR_PID_FILE="$HOME/.smart-gif-converter/monitor-$SESSION.pid"
    if [[ -f "$MONITOR_PID_FILE" ]]; then
        OLD_MONITOR_PID=$(cat "$MONITOR_PID_FILE" 2>/dev/null)
        if [[ -n "$OLD_MONITOR_PID" ]] && kill -0 "$OLD_MONITOR_PID" 2>/dev/null; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Found old monitor PID: $OLD_MONITOR_PID, killing it" >> "$MONITOR_LOG"
            kill -9 "$OLD_MONITOR_PID" 2>/dev/null || true
            pkill -P "$OLD_MONITOR_PID" 2>/dev/null || true
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Old monitor killed" >> "$MONITOR_LOG"
        else
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Old monitor PID file exists but process not running" >> "$MONITOR_LOG"
        fi
        rm -f "$MONITOR_PID_FILE" 2>/dev/null || true
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] No old monitor PID file found (first run or clean exit)" >> "$MONITOR_LOG"
    fi
    
    # Start new monitor with double-fork to survive parent exit
    # Use nohup to ensure it persists even if parent shell exits
    (
        # Double fork and disown to detach completely
        nohup bash -c '
            MONITOR_LOG="'"$MONITOR_LOG"'"
            MONITOR_PID_FILE="'"$MONITOR_PID_FILE"'"
            TERMINAL_PID="'"$TERMINAL_PID"'"
            SESSION="'"$SESSION"'"
            export DISPLAY="'"$DISPLAY"'"
            export DBUS_SESSION_BUS_ADDRESS="'"$DBUS_SESSION_BUS_ADDRESS"'"
            
            # Save monitor PID to file immediately
            echo $$ > "$MONITOR_PID_FILE"
            echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Monitor subprocess PID: $$ starting to watch terminal $TERMINAL_PID" >> "$MONITOR_LOG"
            
            tail --pid="$TERMINAL_PID" -f /dev/null 2>/dev/null || while kill -0 "$TERMINAL_PID" 2>/dev/null; do sleep 0.5; done
            
            echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] New terminal $TERMINAL_PID has exited!" >> "$MONITOR_LOG"
            
            # Clean up our PID file since we detected terminal exit
            rm -f "$MONITOR_PID_FILE" 2>/dev/null || true
            
            if tmux has-session -t "$SESSION" 2>/dev/null; then
                echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Tmux session still exists, starting reminder loop" >> "$MONITOR_LOG"
                
                # Start reminder loop with fixed notification ID to replace instead of stacking
                # Use session name hash as unique notification ID
                NOTIF_ID=$(echo "$SESSION" | md5sum | cut -d' ' -f1 | tr -d '[:alpha:]' | cut -c1-8)
                REMINDER_COUNT=0
                while tmux has-session -t "$SESSION" 2>/dev/null; do
                    REMINDER_COUNT=$((REMINDER_COUNT + 1))
                    
                    if [ $REMINDER_COUNT -eq 1 ]; then
                        REMINDER_MSG="Your GIF conversion is still active in tmux!"
                        TITLE="ðŸ’» Terminal Closed - Conversion Still Running!"
                    else
                        REMINDER_MSG="Reminder #$REMINDER_COUNT: Your GIF conversion is still active in tmux!"
                        TITLE="ðŸ’» Terminal Closed - Conversion Still Running!"
                    fi
                    
                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Sending/updating notification #$REMINDER_COUNT (ID: $NOTIF_ID)" >> "$MONITOR_LOG"
                    
                    notify-send -u critical -t 0 -i video-x-generic \
                        -r "$NOTIF_ID" \
                        -a "GIF Converter" \
                        --action="reconnect=Reconnect Now" \
                        --action="kill=Kill Session" \
                        "$TITLE" \
                        "$REMINDER_MSG\n\nðŸ“ Session: $SESSION\n\nClick '"'Reconnect Now'"' to open a new terminal or '"'Kill Session'"' to stop." \
                        2>>"$MONITOR_LOG" | \
                        while read action; do
                            echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Action received: $action" >> "$MONITOR_LOG"
                            if [ "$action" = "reconnect" ]; then
                                echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] User clicked reconnect again" >> "$MONITOR_LOG"
                                "$HOME/.smart-gif-converter/reconnect-tmux.sh" 2>>"$MONITOR_LOG" &
                                exit 0  # Exit loop when user reconnects
                            elif [ "$action" = "kill" ]; then
                                echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] User clicked kill session" >> "$MONITOR_LOG"
                                
                                # Run kill action in background to avoid blocking
                                (
                                    # Get tmux server PID before killing
                                    TMUX_PID=$(tmux list-sessions -F '"'#{session_name} #{pane_pid}'"' 2>/dev/null | grep "^$SESSION " | awk '"'{print $2}'"')
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Tmux PID: $TMUX_PID" >> "$MONITOR_LOG"
                                    
                                    tmux kill-session -t "$SESSION" 2>>"$MONITOR_LOG"
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Tmux session killed" >> "$MONITOR_LOG"
                                    
                                    # Send confirmation notification
                                    if [ -n "$TMUX_PID" ]; then
                                        echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Sending kill confirmation with PID" >> "$MONITOR_LOG"
                                        DISPLAY="${DISPLAY}" DBUS_SESSION_BUS_ADDRESS="${DBUS_SESSION_BUS_ADDRESS}" \
                                        notify-send -u normal -t 8000 -i dialog-information \
                                            "âœ“ GIF Converter Session Terminated" \
                                            "Session: $SESSION\nTmux Process PID: $TMUX_PID\n\nThe session and all its processes have been killed." \
                                            2>>"$MONITOR_LOG"
                                    else
                                        echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Sending kill confirmation without PID" >> "$MONITOR_LOG"
                                        DISPLAY="${DISPLAY}" DBUS_SESSION_BUS_ADDRESS="${DBUS_SESSION_BUS_ADDRESS}" \
                                        notify-send -u normal -t 5000 -i dialog-information \
                                            "âœ“ GIF Converter Session Terminated" \
                                            "Session '"'$SESSION'"' has been terminated." \
                                            2>>"$MONITOR_LOG"
                                    fi
                                    
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill notification sent" >> "$MONITOR_LOG"
                                ) &
                                
                                exit 0  # Exit loop when session killed
                            fi
                        done
                    
                    # If notification was dismissed or ignored, wait 1 minute before next reminder
                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Waiting 60 seconds for next reminder" >> "$MONITOR_LOG"
                    sleep 60
                done
                
                echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Reminder loop ended - tmux session no longer exists" >> "$MONITOR_LOG"
            else
                echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Tmux session ended, no notification needed" >> "$MONITOR_LOG"
            fi
        ' >>"$MONITOR_LOG" 2>&1 &
    ) &
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor restarted successfully" >> "$MONITOR_LOG"
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Failed to find new terminal PID" >> "$MONITOR_LOG"
fi

# Clean up this script
rm -f "$0"
RESTART_EOF
    sed -i "s|__SESSION__|$SESSION|g" "$RESTART_MONITOR"
    sed -i "s|__DISPLAY__|${DISPLAY:-:0}|g" "$RESTART_MONITOR"
    sed -i "s|__DBUS__|${DBUS_SESSION_BUS_ADDRESS}|g" "$RESTART_MONITOR"
    chmod +x "$RESTART_MONITOR"
    
    # Find available terminal and open it with restart-monitor script sourced BEFORE tmux attach
    # This ensures the monitor restarts in the new terminal's context
    if command -v konsole >/dev/null 2>&1; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Launching konsole" >> "$HOME/.smart-gif-converter/reconnect.log"
        konsole -e bash -c "source '$RESTART_MONITOR'; exec tmux attach-session -t '$SESSION'" >> "$HOME/.smart-gif-converter/reconnect.log" 2>&1 &
    elif command -v gnome-terminal >/dev/null 2>&1; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Launching gnome-terminal" >> "$HOME/.smart-gif-converter/reconnect.log"
        gnome-terminal -- bash -c "source '$RESTART_MONITOR'; exec tmux attach-session -t '$SESSION'" >> "$HOME/.smart-gif-converter/reconnect.log" 2>&1 &
    elif command -v xterm >/dev/null 2>&1; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Launching xterm" >> "$HOME/.smart-gif-converter/reconnect.log"
        xterm -e bash -c "source '$RESTART_MONITOR'; exec tmux attach-session -t '$SESSION'" >> "$HOME/.smart-gif-converter/reconnect.log" 2>&1 &
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] No terminal found" >> "$HOME/.smart-gif-converter/reconnect.log"
        notify-send "Cannot reconnect" "No terminal emulator found. Run: tmux attach -t $SESSION"
    fi
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session does not exist" >> "$HOME/.smart-gif-converter/reconnect.log"
    notify-send "Session ended" "The tmux session has already completed."
fi
RECONNECT_EOF
            sed -i "s|__SESSION_NAME__|$SESSION_NAME|g" "$RECONNECT_SCRIPT"
            sed -i "s|__DISPLAY__|${DISPLAY:-:0}|g" "$RECONNECT_SCRIPT"
            sed -i "s|__DBUS__|${DBUS_SESSION_BUS_ADDRESS}|g" "$RECONNECT_SCRIPT"
            chmod +x "$RECONNECT_SCRIPT"
            
            # Send clickable notification with 1-minute reminder loop
            # Note: Actions work in KDE Plasma, GNOME, etc.
            # Run action handler in background
            # Use fixed notification ID to replace instead of stacking
            (
                # Use session name hash as unique notification ID
                NOTIF_ID=$(echo "$SESSION_NAME" | md5sum | cut -d' ' -f1 | tr -d '[:alpha:]' | cut -c1-8)
                REMINDER_COUNT=0
                while tmux has-session -t "$SESSION_NAME" 2>/dev/null; do
                    REMINDER_COUNT=$((REMINDER_COUNT + 1))
                    
                    if [ $REMINDER_COUNT -eq 1 ]; then
                        REMINDER_MSG="Your GIF conversion is still active in tmux!"
                        TITLE="ðŸ’» Terminal Closed - Conversion Still Running!"
                    else
                        REMINDER_MSG="Reminder #$REMINDER_COUNT: Your GIF conversion is still active in tmux!"
                        TITLE="ðŸ’» Terminal Closed - Conversion Still Running!"
                    fi
                    
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Sending/updating notification #$REMINDER_COUNT (ID: $NOTIF_ID)" >> "$MONITOR_LOG"
                    
                    notify-send -u critical -t 0 -i video-x-generic \
                        -r "$NOTIF_ID" \
                        -a "GIF Converter" \
                        --action="reconnect=Reconnect Now" \
                        --action="kill=Kill Session" \
                        "$TITLE" \
                        "$REMINDER_MSG\n\nðŸ“ Session: $SESSION_NAME\n\nClick 'Reconnect Now' to open a new terminal or 'Kill Session' to stop." \
                        2>>"$MONITOR_LOG" | \
                        while read action; do
                            if [ "$action" = "reconnect" ]; then
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] User clicked reconnect" >> "$MONITOR_LOG"
                                "$RECONNECT_SCRIPT" 2>>"$MONITOR_LOG" &
                                exit 0  # Exit loop when user reconnects
                            elif [ "$action" = "kill" ]; then
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] User clicked kill session" >> "$MONITOR_LOG"
                                
                                # Run kill action with nohup to ensure it completes even after parent exits
                                nohup bash -c '
                                    MONITOR_LOG="'"$MONITOR_LOG"'"
                                    SESSION_NAME="'"$SESSION_NAME"'"
                                    export DISPLAY="'"${DISPLAY}"'"
                                    export DBUS_SESSION_BUS_ADDRESS="'"${DBUS_SESSION_BUS_ADDRESS}"'"
                                    
                                    # Get tmux server PID before killing
                                    TMUX_PID=$(tmux list-sessions -F '"'#{session_name} #{pane_pid}'"' 2>/dev/null | grep "^$SESSION_NAME " | awk '"'{print $2}'"')
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill handler: Tmux PID: $TMUX_PID" >> "$MONITOR_LOG"
                                    
                                    tmux kill-session -t "$SESSION_NAME" 2>>"$MONITOR_LOG"
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill handler: Tmux session killed" >> "$MONITOR_LOG"
                                    
                                    # Send confirmation notification
                                    if [ -n "$TMUX_PID" ]; then
                                        echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill handler: Sending notification with PID" >> "$MONITOR_LOG"
                                        notify-send -u normal -t 8000 -i dialog-information \
                                            "âœ“ GIF Converter Session Terminated" \
                                            "Session: $SESSION_NAME\nTmux Process PID: $TMUX_PID\n\nThe session and all its processes have been killed." \
                                            2>>"$MONITOR_LOG"
                                    else
                                        echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill handler: Sending notification without PID" >> "$MONITOR_LOG"
                                        notify-send -u normal -t 5000 -i dialog-information \
                                            "âœ“ GIF Converter Session Terminated" \
                                            "Session $SESSION_NAME has been terminated." \
                                            2>>"$MONITOR_LOG"
                                    fi
                                    
                                    echo "[$(date '"'+%Y-%m-%d %H:%M:%S'"')] Kill handler: Notification sent successfully" >> "$MONITOR_LOG"
                                ' >>"$MONITOR_LOG" 2>&1 &
                                
                                exit 0  # Exit loop when session killed
                            fi
                        done
                    
                    # If notification was dismissed or ignored, wait 1 minute before next reminder
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Waiting 60 seconds for next reminder" >> "$MONITOR_LOG"
                    sleep 60
                done
                
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] Reminder loop ended - tmux session no longer exists" >> "$MONITOR_LOG"
            ) &
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ“ Reminder loop started" >> "$MONITOR_LOG"
        else
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Tmux session ended, no notification needed" >> "$MONITOR_LOG"
        fi
    ) &
    
    MONITOR_BG_PID=$!
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Monitor background PID: $MONITOR_BG_PID" >> "$MONITOR_LOG"
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] âœ— Monitor NOT started - checks failed" >> "$MONITOR_LOG"
    [[ "$NOTIFY_ENABLED" != "true" ]] && echo "  - NOTIFY_ENABLED is not true" >> "$MONITOR_LOG"
    [[ "$NOTIFY_TERMINAL_CLOSED" != "true" ]] && echo "  - NOTIFY_TERMINAL_CLOSED is not true" >> "$MONITOR_LOG"
    [[ -z "$TERMINAL_PID" ]] && echo "  - TERMINAL_PID is not set" >> "$MONITOR_LOG"
    ! command -v notify-send >/dev/null 2>&1 && echo "  - notify-send not found" >> "$MONITOR_LOG"
fi

cd "$(pwd)" || exit 1
bash "$SCRIPT_PATH" $SCRIPT_ARGS --no-tmux
EXIT_CODE=$?

# Report result
echo
if [ -n "$EXIT_CODE" ] && [ "$EXIT_CODE" -eq 0 ]; then
  echo -e '\033[1;32mâœ“ Conversion completed successfully!\033[0m'
elif [ -n "$EXIT_CODE" ]; then
  echo -e '\033[1;31mâŒ Conversion exited with code: '"$EXIT_CODE"'\033[0m'
else
  echo -e '\033[1;33mâš ï¸ Script execution issue detected\033[0m'
fi

# Wait for user input from the TTY (avoids accidental EOF)
if [ -t 0 ]; then
  echo
  echo -e '\033[0;36mPress Enter to close, or Ctrl+b then d to detach.\033[0m'
  read -r </dev/tty || true
else
  echo
  echo -e '\033[0;36mNo TTY detected; keeping pane open for 2 minutes.\033[0m'
  sleep 120
fi

# Drop into an interactive shell so the pane stays open
SHELL_TO_EXEC="${SHELL:-/bin/bash}"
if command -v "$SHELL_TO_EXEC" >/dev/null 2>&1; then
  if [ "${SHELL_TO_EXEC##*/}" = "bash" ]; then
    exec "$SHELL_TO_EXEC" -l -i
  else
    exec "$SHELL_TO_EXEC" -l
  fi
fi
# Fallback to bash
exec bash -i
TMUX_EOF
        # Substitute variables into the wrapper
        sed -i "s|\$SCRIPT_PATH|$SCRIPT_PATH|g" "$TMUX_WRAPPER"
        sed -i "s|\$SCRIPT_ARGS|$SCRIPT_ARGS|g" "$TMUX_WRAPPER"
        
        # Add environment variable exports at the beginning of the script
        # Insert after the shebang line
        sed -i "2i\\# Environment variables passed from parent\\nexport NOTIFY_ENABLED='$NOTIFY_ENABLED'\\nexport NOTIFY_TERMINAL_CLOSED='$NOTIFY_TERMINAL_CLOSED'\\nexport SESSION_NAME='$SESSION_NAME'\\nexport TERMINAL_PID='$TERMINAL_PID'\\nexport DISPLAY='$DISPLAY'\\nexport DBUS_SESSION_BUS_ADDRESS='$DBUS_SESSION_BUS_ADDRESS'\\n" "$TMUX_WRAPPER"
        
        chmod +x "$TMUX_WRAPPER"
        exec tmux new-session -s "$SESSION_NAME" "$TMUX_WRAPPER"
    fi
fi

# ðŸ”’ Process Group Management - Ensure all processes die with terminal
# This creates a process group so when the script terminates, ALL children die
if [[ $$ == $BASHPID ]] || [[ -z "$BASHPID" ]]; then
    # We're the main process, set up process group management
    set +m 2>/dev/null || true  # Disable job control initially (ignore if not supported)
    # Skip terminal redirection as it can cause hangs in some environments
    # exec 0< /dev/tty 2>/dev/null || true  # This was causing hangs
    set -m 2>/dev/null || true  # Enable job control for proper process group handling
fi

# Set this script as the process group leader
export SCRIPT_PID=$$
export SCRIPT_PGID=$$

# ðŸ“º Terminal binding - ensure processes are tied to terminal session
if [[ -t 0 ]] && [[ -t 1 ]]; then
    # We have a terminal, bind processes to it
    export TERMINAL_BOUND=true
    echo -e "\033[2mðŸ“º Process group $SCRIPT_PGID bound to terminal session\033[0m"
else
    # No terminal detected
    export TERMINAL_BOUND=false
fi

# ðŸŽ¨ Color codes for early use (needed for lock file messages)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ðŸ”’ Single Instance Lock - Prevent multiple concurrent executions
# This ensures only one instance of the script runs at a time
LOCK_FILE="${HOME}/.smart-gif-converter/script.lock"
LOCK_DIR="$(dirname "$LOCK_FILE")"

# Create lock directory if it doesn't exist
mkdir -p "$LOCK_DIR" 2>/dev/null || true

# Try to acquire the lock
if [[ -f "$LOCK_FILE" ]]; then
    # Lock file exists, check if the process is still running
    existing_pid=$(cat "$LOCK_FILE" 2>/dev/null)
    
    # Check if process exists AND is actually running this script
    if [[ -n "$existing_pid" ]] && kill -0 "$existing_pid" 2>/dev/null; then
        # Verify this PID is actually running convert.sh (not just any process)
        process_cmd=$(ps -p "$existing_pid" -o comm= 2>/dev/null || echo "")
        process_args=$(ps -p "$existing_pid" -o args= 2>/dev/null || echo "")
        
        # Check if it's a bash process running this script
        if [[ "$process_cmd" == "bash" || "$process_cmd" == */"bash" ]] && [[ "$process_args" == *"convert.sh"* ]]; then
            # Process is still running THIS script - block this new instance
            echo -e "" >&2
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}" >&2
            echo -e "${RED}${BOLD}â¸ï¸  Script is already running in another terminal${NC}" >&2
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}" >&2
            echo -e "" >&2
            echo -e "${CYAN}Running process ID (PID): ${BOLD}$existing_pid${NC}" >&2
            echo -e "" >&2
            echo -e "${CYAN}Your options:${NC}" >&2
            echo -e "  ${GREEN}1. Wait${NC} - Let the current conversion finish" >&2
            echo -e "  ${GREEN}2. Stop${NC} - Run: ${BOLD}kill $existing_pid${NC}" >&2
            echo -e "" >&2
            exit 1
        else
            # PID exists but is NOT running convert.sh (PID was reused)
            # Clean up stale lock file
            rm -f "$LOCK_FILE" 2>/dev/null || true
        fi
    else
        # Process is not running at all, clean up stale lock
        rm -f "$LOCK_FILE" 2>/dev/null || true
    fi
fi

# Create lock file with current PID
echo "$$" > "$LOCK_FILE" 2>/dev/null || true

# Setup cleanup for lock file on exit
cleanup_lock_file() {
    rm -f "$LOCK_FILE" 2>/dev/null || true
}
trap cleanup_lock_file EXIT

# =============================================================================
# ðŸŽ¬ SMART GIF CONVERTER - Revolutionary Video-to-GIF Conversion Tool
# =============================================================================
# Author: AI Assistant
# Version: 7.1
# Description: Advanced, customizable video-to-GIF converter with intelligent
#              processing, quality optimization, and extensive configuration options.
# =============================================================================

# Note: Color codes already defined above (before lock file check)

# ðŸ“Š Statistics tracking
total_files=0
converted_files=0
skipped_files=0
failed_files=0
corrupt_input_files=0
corrupt_output_files=0
start_time=$(date +%s)

# ðŸ” Validation tracking
VALIDATION_TOTAL_VIDEOS=0
VALIDATION_ALREADY_CONVERTED=0
VALIDATION_NEED_CONVERSION=0
VALIDATION_ORPHANED_COUNT=0

# ðŸš¨ Error handling
LOG_DIR="$HOME/.smart-gif-converter"
ERROR_LOG="$LOG_DIR/errors.log"
CONVERSION_LOG="$LOG_DIR/conversions.log"
PROGRESS_FILE="$LOG_DIR/progress.save"
DEBUG_MODE=false
MAX_RETRIES=2
CLEANUP_ON_EXIT=true
AUTOSAVE_ENABLED=true
CLEANUP_IN_PROGRESS=false

# âš™ï¸ DEFAULT CONFIGURATION (Conservative settings for better GIF sizes)
CONFIG_FILE="gif-converter.conf"
RESOLUTION="1280:720"
FRAMERATE="12"
QUALITY="high"
ASPECT_RATIO="16:9"
SCALING_ALGO="lanczos"
DITHER_MODE="bayer"
MAX_COLORS="128"
PALETTE_MODE="custom"
FORCE_CONVERSION=false
PARALLEL_JOBS="$(nproc 2>/dev/null || echo '4')"
OUTPUT_FORMAT="gif"
COMPRESSION_LEVEL="medium"
AUTO_OPTIMIZE=true
OPTIMIZE_AGGRESSIVE=true
OPTIMIZE_TARGET_RATIO=20
MAX_GIF_SIZE_MB=25
AUTO_REDUCE_QUALITY=true
SMART_SIZE_DOWN=true
GPU_ACCELERATION="auto"
FFMPEG_THREADS="auto"
BACKUP_ORIGINAL=false
LOG_LEVEL="info"
PROGRESS_BAR=true
INTERACTIVE_MODE=true
SKIP_VALIDATION=false
ONLY_FILE=""

# ðŸ“ Output Directory Configuration
OUTPUT_DIRECTORY="./converted_gifs"  # Default: ./converted_gifs subdirectory
OUTPUT_DIR_MODE="default"  # default, current, pictures, custom

# ðŸ¤– Enhanced AI Configuration
AI_ENABLED=false
CROP_FILTER=""
AI_MODE="smart"  # smart, content, motion, quality
AI_CONFIDENCE_THRESHOLD=70
AI_CONTENT_CACHE=""
AI_AUTO_QUALITY=false  # Let AI automatically select quality per video
AI_SCENE_ANALYSIS=true  # Enable advanced scene detection
AI_VISUAL_SIMILARITY=true  # Enable visual similarity in duplicate detection
AI_SMART_CROP=true  # Enable intelligent crop detection
AI_AUTO_OPTIMIZE=true  # Let AI decide optimal Level 6 settings based on collection size & system
AI_FRAME_ANALYSIS=false  # Enable Level 6 frame-by-frame analysis (EXPENSIVE: disabled by default)
AI_LEVEL6_FAST_MODE=true  # Use fast Level 6 analysis (skip color histograms, 2x faster)
AI_DYNAMIC_FRAMERATE=true  # Enable smart frame rate adjustment
AI_QUALITY_SCALING=true  # Enable intelligent quality parameter scaling
AI_CONTENT_FINGERPRINT=true   # Enable content fingerprinting for duplicates
AI_THREADS_OPTIMAL="auto"  # AI-optimized thread count
AI_MEMORY_OPT="auto"        # AI-optimized memory settings
CONTENT_TYPE_PREFERENCE="mixed"  # animation, movie, screencast, mixed (auto-detect)

# ðŸ” AI Video Discovery Preferences
AI_DISCOVERY_ENABLED=true      # Enable AI video discovery when no files found
AI_DISCOVERY_AUTO_SELECT="ask" # Auto selection mode: "ask", "recent", "all", "disabled"
AI_DISCOVERY_REMEMBER_CHOICE=true  # Remember user's selection preference
CPU_BENCHMARK=false

# ðŸš€ Advanced Multi-Threading Configuration
CPU_CORES="$(nproc 2>/dev/null || echo '4')"
CPU_PHYSICAL_CORES="$(lscpu 2>/dev/null | grep '^Core(s) per socket:' | awk '{print $4}' || echo "$CPU_CORES")"
CPU_LOGICAL_CORES="$CPU_CORES"
AI_MAX_PARALLEL_JOBS="$(( CPU_CORES > 8 ? 8 : CPU_CORES ))"  # Cap at 8 for memory efficiency
AI_DUPLICATE_THREADS="$(( CPU_CORES > 4 ? CPU_CORES - 1 : CPU_CORES ))"  # Leave 1 core free on high-core systems
AI_ANALYSIS_BATCH_SIZE="$(( CPU_CORES * 2 ))"  # Process 2x CPU cores worth in each batch

# ðŸ—„ï¸ AI Cache System Configuration
AI_CACHE_DIR="$LOG_DIR/ai_cache"
AI_CACHE_INDEX="$AI_CACHE_DIR/analysis_cache.db"
AI_CACHE_VERSION="2.0"  # Increment to invalidate old cache
AI_CACHE_ENABLED=true
AI_CACHE_MAX_AGE_DAYS=30  # Cache entries older than this are cleaned up

# Ensure AI cache directory exists to avoid "No such file or directory" errors
if [[ "$AI_CACHE_ENABLED" == "true" ]]; then
    mkdir -p "$AI_CACHE_DIR" 2>/dev/null || true
fi

# ðŸ” Checksum Cache System Configuration
CHECKSUM_CACHE_DIR="$LOG_DIR/checksum_cache"
CHECKSUM_CACHE_DB="$CHECKSUM_CACHE_DIR/checksums.db"
CHECKSUM_CACHE_VERSION="1.0"
CHECKSUM_CACHE_ENABLED=true
CHECKSUM_CACHE_MAX_AGE_DAYS=90  # Cache checksums for 90 days

# Ensure checksum cache directory exists as well
if [[ "$CHECKSUM_CACHE_ENABLED" == "true" ]]; then
    mkdir -p "$CHECKSUM_CACHE_DIR" 2>/dev/null || true
fi

# ðŸ“Š Duplicate Detection Statistics
DUPLICATE_STATS_TOTAL_CHECKED=0
DUPLICATE_STATS_EXACT_BINARY=0
DUPLICATE_STATS_VISUAL_IDENTICAL=0
DUPLICATE_STATS_CONTENT_FINGERPRINT=0
DUPLICATE_STATS_NEAR_IDENTICAL=0
DUPLICATE_STATS_DELETED=0
DUPLICATE_STATS_SKIPPED=0
DUPLICATE_STATS_SPACE_SAVED=0
DUPLICATE_STATS_CACHE_HITS=0
DUPLICATE_STATS_CACHE_MISSES=0

# ðŸ§  AI Training & Learning System Configuration
AI_TRAINING_ENABLED=true
AI_TRAINING_DIR="$LOG_DIR/ai_training"
AI_MODEL_FILE="$AI_TRAINING_DIR/smart_model.db"
AI_TRAINING_LOG="$AI_TRAINING_DIR/training_history.log"
AI_MODEL_VERSION="1.0"  # Increment to reset training model
AI_GENERATION=1          # Current AI generation (increments with model rebuilds)
AI_LEARNING_RATE=0.1    # How quickly AI adapts (0.1 = moderate learning)
AI_CONFIDENCE_MIN=0.3    # Minimum confidence threshold for AI decisions
AI_TRAINING_MIN_SAMPLES=5  # Minimum samples before AI makes confident predictions

# ðŸ”„ Auto-Update System Configuration
GITHUB_REPO="FreddeITsupport98/converter-mp4-to-gif-using-ffmpeg"
GITHUB_API_URL="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"
GITHUB_RELEASES_URL="https://github.com/${GITHUB_REPO}/releases"
CURRENT_VERSION="10"  # Script version
UPDATE_CHECK_FILE="$LOG_DIR/.last_update_check"
UPDATE_CHECK_INTERVAL=86400  # Check once per day (in seconds)
AUTO_UPDATE_ENABLED=true  # Enable automatic update checks (user configurable)
UPDATE_FIRST_RUN_PROMPT_DONE=false  # Track if first-run update prompt was shown

# ðŸ› ï¸ Development Mode Configuration (Auto-detected, hidden from settings)
DEV_MODE=false           # Auto-detected: true if running in Git repository
DEV_MODE_DETECTED=false  # Set to true if Git repository detected

# ðŸ” Release Fingerprint System - Track installed version integrity
RELEASE_FINGERPRINT_FILE="$LOG_DIR/.release_fingerprint"
INSTALLED_RELEASE_SHA256=""       # SHA256 of currently installed release
INSTALLED_RELEASE_VERSION=""      # Version of currently installed release
INSTALLED_RELEASE_TAG=""          # Git tag of currently installed release
INSTALLED_RELEASE_TIMESTAMP="0"   # GitHub release timestamp (Unix epoch)

# ðŸ” Security Configuration
GPG_SIGNATURE_REQUIRED=false  # Require GPG signature verification (set true for max security)
GPG_KEY_FINGERPRINT=""  # Your GPG key fingerprint (set this for GPG verification)
TRUSTED_GITHUB_DOMAINS=("raw.githubusercontent.com" "github.com" "api.github.com")
MIN_FILE_SIZE=10000  # Minimum expected file size in bytes (sanity check)

# ðŸ”” Desktop Notification Configuration
NOTIFY_ENABLED=true                    # Master toggle for all notifications
NOTIFY_SESSION_START=true              # Notify when tmux session starts
NOTIFY_SESSION_FOUND=true              # Notify when existing session is found
NOTIFY_CONVERSION_COMPLETE=true        # Notify when conversion completes
NOTIFY_CONVERSION_PROGRESS=true        # Periodic progress notifications during conversion
NOTIFY_PROGRESS_INTERVAL=300           # Progress notification interval in seconds (5 minutes)
NOTIFY_ERROR=true                      # Notify on errors
NOTIFY_REMINDER_ENABLED=true           # Enable periodic "still running" reminders
NOTIFY_REMINDER_INTERVAL=600           # Reminder interval in seconds (10 minutes)
NOTIFY_TERMINAL_CLOSED=true            # Notify when terminal closes with active tmux session

# ðŸš€ Parallel Processing Utility Functions
# =====================================================

# ðŸ§  Optimize thread count based on workload type
get_optimal_threads() {
    local workload_type="${1:-default}"  # io, cpu, mixed, default
    local total_work="${2:-1}"           # Number of items to process
    
    case "$workload_type" in
        "io")  # I/O intensive (file operations, FFprobe)
            # Use more threads for I/O bound tasks
            echo "$(( CPU_CORES * 2 ))"
            ;;
        "cpu") # CPU intensive (FFmpeg encoding, hash calculations)
            # Use physical cores to avoid oversubscription
            echo "$CPU_PHYSICAL_CORES"
            ;;
        "mixed") # Mixed workload
            # Use logical cores but cap at reasonable limit
            echo "$(( CPU_CORES > 12 ? 12 : CPU_CORES ))"
            ;;
        "memory") # Memory intensive operations
            # Conservative threading to avoid memory pressure
            echo "$(( CPU_CORES > 6 ? 6 : CPU_CORES ))"
            ;;
        *) # Default balanced approach
            # Adapt based on total work and available cores
            if [[ $total_work -lt $CPU_CORES ]]; then
                echo "$total_work"  # Don't use more threads than work items
            else
                echo "$CPU_CORES"
            fi
            ;;
    esac
}

# âš¡ Run commands in parallel with controlled concurrency
run_parallel() {
    local max_jobs="$1"      # Maximum concurrent jobs
    local job_function="$2"  # Function to call for each item
    shift 2                  # Remove first two args
    local items=("$@")       # Remaining args are items to process
    
    if [[ $max_jobs -le 1 || ${#items[@]} -eq 0 ]]; then
        # No parallelization needed/possible
        for item in "${items[@]}"; do
            "$job_function" "$item"
        done
        return
    fi
    
    local active_jobs=0
    local job_pids=()
    
    for item in "${items[@]}"; do
        # Wait if we have too many active jobs
        while [[ $active_jobs -ge $max_jobs ]]; do
            # Check for completed jobs
            local new_pids=()
            for pid in "${job_pids[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    new_pids+=("$pid")
                else
                    ((active_jobs--))
                fi
            done
            job_pids=("${new_pids[@]}")
            
            # Short sleep to avoid busy waiting
            [[ $active_jobs -ge $max_jobs ]] && sleep 0.1
        done
        
        # Start new job in background
        "$job_function" "$item" &
        job_pids+=("$!")
        ((active_jobs++))
    done
    
    # Wait for all remaining jobs to complete
    for pid in "${job_pids[@]}"; do
        wait "$pid" 2>/dev/null || true
    done
}

# ðŸ“Š Progress tracker for parallel operations
update_parallel_progress() {
    local current="$1"
    local total="$2"
    local operation="${3:-Processing}"
    local bar_length="${4:-25}"
    
    local progress=$(( current * 100 / total ))
    local filled=$(( progress * bar_length / 100 ))
    local empty=$(( bar_length - filled ))
    
    printf "\r  ${CYAN}%s [${NC}" "$operation"
    for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((i=0; i<empty; i++)); do printf "${GRAY}â–‘${NC}"; done
    printf "${CYAN}] ${BOLD}%3d%%${NC} (${BOLD}%d${NC}/${BOLD}%d${NC})" "$progress" "$current" "$total"
}

# ðŸ“Š Progress tracker with current file display
update_file_progress() {
    local current="$1"
    local total="$2"
    local current_file="${3:-}"
    local operation="${4:-Processing}"
    local bar_length="${5:-25}"
    
    # Ensure current doesn't exceed total to prevent overshooting
    [[ $current -gt $total ]] && current=$total
    
    local progress=$(( current * 100 / total ))
    # Cap progress at 100% to prevent overshooting
    [[ $progress -gt 100 ]] && progress=100
    
    local filled=$(( progress * bar_length / 100 ))
    local empty=$(( bar_length - filled ))
    
    # Show full filename without truncation
    local display_file="$current_file"
    
    # Truncate long filenames to prevent line wrapping
    local max_filename_length=50
    if [[ ${#display_file} -gt $max_filename_length ]]; then
        display_file="${display_file:0:47}..."
    fi
    
    # Clear the entire line first to prevent display corruption
    printf "\r\033[K"  # Clear from cursor to end of line
    printf "  ${CYAN}%s [${NC}" "$operation"
    for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((i=0; i<empty; i++)); do printf "${GRAY}â–‘${NC}"; done
    printf "${CYAN}] ${BOLD}%3d%%${NC} (${BOLD}%d${NC}/${BOLD}%d${NC})" "$progress" "$current" "$total"
    if [[ -n "$current_file" ]]; then
        printf " ${GRAY}%s${NC}" "$display_file"
    fi
}

# ðŸ”„ Auto-Update System (GitHub Releases with SHA256 Verification)
# =================================================================

# ðŸ› ï¸ Detect if script is running in a Git repository (Development Mode)
# FOOLPROOF: Multiple layers of detection to ensure 100% accuracy
detect_dev_mode() {
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local script_file="${BASH_SOURCE[0]}"
    
    # ==================================================================
    # LAYER 1: Check if script is inside a Git repository
    # ==================================================================
    local check_dir="$script_dir"
    local git_root=""
    
    while [[ "$check_dir" != "/" ]]; do
        if [[ -d "$check_dir/.git" ]]; then
            git_root="$check_dir"
            break
        fi
        check_dir="$(dirname "$check_dir")"
    done
    
    # No Git repository found - definitely user mode
    if [[ -z "$git_root" ]]; then
        DEV_MODE_DETECTED=false
        DEV_MODE=false
        return 1
    fi
    
    # ==================================================================
    # LAYER 2: Verify it's THIS project's repository
    # ==================================================================
    local is_our_repo=false
    
    if [[ -f "$git_root/.git/config" ]]; then
        local git_remote=$(grep -E 'url\s*=' "$git_root/.git/config" 2>/dev/null | head -1)
        if [[ "$git_remote" =~ converter-mp4-to-gif-using-ffmpeg ]]; then
            is_our_repo=true
        fi
    fi
    
    # ==================================================================
    # LAYER 3: Check for development indicators
    # ==================================================================
    local dev_indicators=0
    
    # Check for WARP.md (development documentation)
    [[ -f "$git_root/WARP.md" ]] && ((dev_indicators++))
    
    # Check for CHANGELOG.md
    [[ -f "$git_root/CHANGELOG.md" ]] && ((dev_indicators++))
    
    # Check for .gitignore
    [[ -f "$git_root/.gitignore" ]] && ((dev_indicators++))
    
    # Check if script is directly in repository root or subdirectory
    if [[ "$script_dir" == "$git_root" ]] || [[ "$script_dir" == "$git_root"/* ]]; then
        ((dev_indicators++))
    fi
    
    # ==================================================================
    # LAYER 4: Check Git status (tracked vs untracked)
    # ==================================================================
    local is_tracked=false
    
    if command -v git >/dev/null 2>&1; then
        # Check if script file is tracked by Git
        if git -C "$git_root" ls-files --error-unmatch "$script_file" >/dev/null 2>&1; then
            is_tracked=true
            ((dev_indicators++))
        fi
    fi
    
    # ==================================================================
    # LAYER 5: Check for uncommitted changes (strongest indicator)
    # ==================================================================
    local has_uncommitted=false
    
    if command -v git >/dev/null 2>&1; then
        # Check if there are any uncommitted changes in the repo
        if ! git -C "$git_root" diff --quiet 2>/dev/null || \
           ! git -C "$git_root" diff --cached --quiet 2>/dev/null; then
            has_uncommitted=true
            ((dev_indicators++))
        fi
    fi
    
    # ==================================================================
    # LAYER 6: Check for .dev_mode marker file (ABSOLUTE OVERRIDE)
    # ==================================================================
    # If .dev_mode file exists in Git root, FORCE dev mode ON
    # If .no_dev_mode exists, FORCE dev mode OFF
    # This gives you absolute control when needed
    
    local force_dev_mode=false
    local force_user_mode=false
    
    if [[ -f "$git_root/.dev_mode" ]]; then
        force_dev_mode=true
    fi
    
    if [[ -f "$git_root/.no_dev_mode" ]]; then
        force_user_mode=true
    fi
    
    # ABSOLUTE OVERRIDE: .dev_mode file forces development mode
    if [[ "$force_dev_mode" == "true" ]]; then
        DEV_MODE_DETECTED=true
        DEV_MODE=true
        echo -e "${YELLOW}âš ï¸  ${BOLD}DEVELOPMENT MODE ACTIVE${NC}" >&2
        echo -e "${BLUE}ðŸ› ï¸  Auto-update: ${RED}DISABLED${NC}" >&2
        echo -e "${GRAY}   Reason: .dev_mode marker file found${NC}" >&2
        echo -e "${CYAN}   â†’ Your work is protected from auto-updates${NC}" >&2
        echo "" >&2
        return 0
    fi
    
    # ABSOLUTE OVERRIDE: .no_dev_mode file forces user mode (for testing)
    if [[ "$force_user_mode" == "true" ]]; then
        DEV_MODE_DETECTED=false
        DEV_MODE=false
        echo -e "${CYAN}â„¹ï¸  User mode forced by .no_dev_mode marker${NC}" >&2
        return 1
    fi
    
    # ==================================================================
    # DECISION: Enable DEV_MODE if ANY strong indicator is present
    # ==================================================================
    
    # Strong indicators (any one triggers DEV_MODE)
    if [[ "$is_our_repo" == "true" ]] || \
       [[ "$is_tracked" == "true" ]] || \
       [[ "$has_uncommitted" == "true" ]] || \
       [[ $dev_indicators -ge 3 ]]; then
        
        DEV_MODE_DETECTED=true
        DEV_MODE=true
        
        # Show detailed development mode notice
        echo -e "${YELLOW}âš ï¸  ${BOLD}DEVELOPMENT MODE ACTIVE${NC}" >&2
        echo -e "${BLUE}ðŸ› ï¸  Auto-update: ${RED}DISABLED${NC}" >&2
        echo -e "${GRAY}   Git repo: $git_root${NC}" >&2
        
        # Show why DEV_MODE was triggered
        if [[ "$is_our_repo" == "true" ]]; then
            echo -e "${GRAY}   Reason: This repository (converter-mp4-to-gif-using-ffmpeg)${NC}" >&2
        fi
        if [[ "$is_tracked" == "true" ]]; then
            echo -e "${GRAY}   Reason: Script is Git-tracked${NC}" >&2
        fi
        if [[ "$has_uncommitted" == "true" ]]; then
            echo -e "${GRAY}   Reason: Uncommitted changes detected${NC}" >&2
        fi
        if [[ $dev_indicators -ge 3 ]]; then
            echo -e "${GRAY}   Reason: $dev_indicators development indicators found${NC}" >&2
        fi
        
        echo -e "${CYAN}   â†’ Your work is protected from auto-updates${NC}" >&2
        echo "" >&2
        
        return 0
    fi
    
    # ==================================================================
    # FALLBACK: Even if in a Git repo, it's not a development environment
    # ==================================================================
    
    # User might have cloned the repo just to use it (not develop)
    # No strong indicators found - treat as user mode
    DEV_MODE_DETECTED=false
    DEV_MODE=false
    return 1
}

# ðŸ” Check for updates from GitHub Releases
check_for_updates() {
    # ðŸ› ï¸ Skip update check if in development mode
    if [[ "$DEV_MODE" == "true" ]]; then
        return 0  # Silently skip - don't disturb development
    fi
    # Skip if auto-update is disabled
    if [[ "$AUTO_UPDATE_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Skip if checked recently
    if [[ -f "$UPDATE_CHECK_FILE" ]]; then
        local last_check=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo "0")
        local now=$(date +%s)
        local time_diff=$((now - last_check))
        
        if [[ $time_diff -lt $UPDATE_CHECK_INTERVAL ]]; then
            return 0  # Skip check
        fi
    fi
    
    # Validate update URL is reachable with HTTPS certificate verification
    # Use HEAD request but suppress output completely - we only care about exit code
    if ! curl -sI --ssl-reqd --cacert /etc/ssl/certs/ca-certificates.crt "$GITHUB_API_URL" -m 5 >/dev/null 2>&1 && \
       ! curl -sI --ssl-reqd "$GITHUB_API_URL" -m 5 >/dev/null 2>&1; then
        return 0  # Silently fail if GitHub unreachable or SSL verification fails
    fi
    
    # Fetch latest STABLE release info from GitHub API (excludes pre-releases)
    # Using /releases/latest endpoint ensures we get only stable releases
    local release_json=$(curl -s --ssl-reqd --tlsv1.2 "$GITHUB_API_URL" -m 10 2>/dev/null)
    
    if [[ -z "$release_json" ]] || [[ "$release_json" == *"Not Found"* ]] || [[ "$release_json" == *"API rate limit"* ]]; then
        return 0  # Silently fail (return success to avoid ERR trap)
    fi
    
    # Verify this is a stable release (not pre-release or draft)
    local is_prerelease=$(echo "$release_json" | grep -o '"prerelease":[^,]*' | grep -o 'true\|false')
    local is_draft=$(echo "$release_json" | grep -o '"draft":[^,]*' | grep -o 'true\|false')
    
    # Skip if this is a pre-release or draft (protection against RC/beta versions)
    if [[ "$is_prerelease" == "true" ]] || [[ "$is_draft" == "true" ]]; then
        return 0  # Skip pre-releases and drafts
    fi
    
    # Extract version tag and release timestamp
    local remote_tag=$(echo "$release_json" | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p')
    local remote_version=$(echo "$remote_tag" | sed 's/[^0-9.]//g' | sed 's/^[.]\+\|[.]\+$//g' | cut -d'.' -f1-2)
    
    # Extract GitHub release published_at timestamp (ISO 8601 format)
    local remote_timestamp_iso=$(echo "$release_json" | sed -n 's/.*"published_at": *"\([^"]*\)".*/\1/p')
    local remote_timestamp=0
    
    # Convert ISO 8601 to Unix epoch timestamp for comparison
    if [[ -n "$remote_timestamp_iso" ]]; then
        remote_timestamp=$(date -d "$remote_timestamp_iso" +%s 2>/dev/null || echo "0")
    fi
    
    # Additional safety: verify tag doesn't contain RC, beta, alpha, or pre markers
    if [[ "$remote_tag" =~ (rc|RC|beta|BETA|alpha|ALPHA|pre|PRE) ]]; then
        return 0  # Skip release candidates and pre-releases
    fi
    
    [[ -z "$remote_version" ]] && return 0  # Return success to avoid ERR trap
    
    # Save check time
    mkdir -p "$(dirname "$UPDATE_CHECK_FILE")" 2>/dev/null || true
    echo "$(date +%s)" > "$UPDATE_CHECK_FILE" 2>/dev/null || true
    
    # Extract SHA256 from release to compare with installed fingerprint
    local remote_sha256=$(extract_sha256_from_release "$release_json")
    
    # Load current installation fingerprint
    load_release_fingerprint 2>/dev/null
    
    # ðŸ”’ BULLETPROOF: Compare versions, checksums AND timestamps
    # This prevents confusion when same version with different checksums exists
    # and ensures we NEVER consider older releases as updates
    local needs_update=false
    
    # Timestamp validation: ONLY accept releases NEWER than installed version
    if [[ "$remote_timestamp" -gt 0 && "$INSTALLED_RELEASE_TIMESTAMP" != "0" ]]; then
        if [[ "$remote_timestamp" -le "$INSTALLED_RELEASE_TIMESTAMP" ]]; then
            # Remote release is OLDER or SAME age - skip it
            return 0
        fi
    fi
    
    if [[ "$remote_version" != "$CURRENT_VERSION" ]]; then
        # Different version number - check if it's actually newer
        needs_update=true
    elif [[ -n "$remote_sha256" && -n "$INSTALLED_RELEASE_SHA256" ]]; then
        # Same version but check if SHA256 differs (hotfix/rebuild)
        # AND timestamp is newer (already validated above)
        if [[ "$remote_sha256" != "$INSTALLED_RELEASE_SHA256" ]]; then
            needs_update=true
        fi
    fi
    
    if [[ "$needs_update" == "true" ]]; then
        local release_body=$(echo "$release_json" | sed -n 's/.*"body": *"\([^"]*\)".*/\1/p' | sed 's/\\n/\n/g' | sed 's/\\r//g')
        
        # Save update info to file for main menu display
        local update_info_file="$LOG_DIR/.update_available"
        cat > "$update_info_file" 2>/dev/null << EOF
UPDATE_AVAILABLE=true
REMOTE_VERSION="$remote_version"
REMOTE_TAG="$remote_tag"
REMOTE_TIMESTAMP="$remote_timestamp"
REMOTE_SHA256="$remote_sha256"
CHECKED_AT=$(date +%s)
EOF
        
        show_update_available "$remote_version" "$remote_tag" "$release_body" "prompt"
    else
        # No update available - clear the update info file
        local update_info_file="$LOG_DIR/.update_available"
        rm -f "$update_info_file" 2>/dev/null || true
    fi
    
    return 0  # Always return success
}

# ðŸ“¢ Show update notification
show_update_available() {
    local new_version="$1"
    local release_tag="$2"
    local release_notes="$3"
    local mode="${4:-notify}"  # notify or prompt
    
    echo ""
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘               ðŸŽ‰ UPDATE AVAILABLE: v${new_version}                       â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${YELLOW}Current: v${CURRENT_VERSION}${NC} â†’ ${GREEN}${BOLD}New: v${new_version}${NC}"
    echo -e "${BLUE}ðŸ”— View release: ${CYAN}${GITHUB_RELEASES_URL}/tag/${release_tag}${NC}"
    
    # Show release notes preview
    if [[ -n "$release_notes" ]]; then
        echo -e "\n${BLUE}ðŸ“ Release notes (preview):${NC}"
        echo "$release_notes" | head -5 | sed 's/^/  /'
        if [[ $(echo "$release_notes" | wc -l) -gt 5 ]]; then
            echo -e "  ${GRAY}... (see full notes at link above)${NC}"
        fi
    fi
    
    if [[ "$mode" == "prompt" ]]; then
        echo ""
        echo -ne "${YELLOW}Would you like to update now? [Y/n/later]: ${NC}"
        read -r update_response
        
        case "$update_response" in
            [Yy]|"")
                echo -e "${CYAN}â¬‡ï¸  Starting update process...${NC}"
                perform_update "$new_version" "$release_tag" "$release_notes"
                ;;
            [Ll]*)
                echo -e "${BLUE}â„¹ï¸  Update postponed. Run ${GREEN}./convert.sh --update${BLUE} when ready.${NC}"
                ;;
            *)
                echo -e "${YELLOW}â¸ï¸  Update skipped. You can update anytime with: ${GREEN}./convert.sh --update${NC}"
                ;;
        esac
    else
        echo -e "${YELLOW}ðŸ”„ Update with: ${GREEN}./convert.sh --update${NC}"
    fi
    
    echo ""
}

# ðŸ” Verify GPG signature (most secure)
verify_gpg_signature() {
    local file="$1"
    local signature_file="${file}.sig"
    local signature_url="$2"
    
    # Check if GPG is available
    if ! command -v gpg >/dev/null 2>&1 && ! command -v gpg2 >/dev/null 2>&1; then
        if [[ "$GPG_SIGNATURE_REQUIRED" == "true" ]]; then
            echo -e "${RED}âŒ GPG not installed but signature verification required${NC}"
            return 1
        else
            echo -e "${YELLOW}âš ï¸  GPG not available, skipping signature verification${NC}"
            return 0
        fi
    fi
    
    local gpg_cmd="gpg"
    command -v gpg2 >/dev/null 2>&1 && gpg_cmd="gpg2"
    
    # Download signature file
    if [[ -n "$signature_url" ]]; then
        echo -e "${CYAN}ðŸ” Downloading GPG signature...${NC}"
        if ! curl -sL --ssl-reqd --tlsv1.2 "$signature_url" -o "$signature_file" 2>/dev/null; then
            if [[ "$GPG_SIGNATURE_REQUIRED" == "true" ]]; then
                echo -e "${RED}âŒ Failed to download GPG signature${NC}"
                return 1
            else
                echo -e "${YELLOW}âš ï¸  No GPG signature available${NC}"
                return 0
            fi
        fi
        
        # Verify signature
        echo -e "${CYAN}ðŸ” Verifying GPG signature...${NC}"
        if [[ -n "$GPG_KEY_FINGERPRINT" ]]; then
            # Verify with specific key fingerprint
            if $gpg_cmd --verify --status-fd 1 "$signature_file" "$file" 2>/dev/null | grep -q "$GPG_KEY_FINGERPRINT"; then
                echo -e "${GREEN}âœ“ GPG signature verified with trusted key!${NC}"
                rm -f "$signature_file"
                return 0
            else
                echo -e "${RED}âŒ GPG signature verification FAILED!${NC}"
                rm -f "$signature_file"
                return 1
            fi
        else
            # Verify signature exists and is valid (any key)
            if $gpg_cmd --verify "$signature_file" "$file" 2>/dev/null; then
                echo -e "${YELLOW}âš ï¸  GPG signature valid but key not pinned (set GPG_KEY_FINGERPRINT for max security)${NC}"
                rm -f "$signature_file"
                return 0
            else
                if [[ "$GPG_SIGNATURE_REQUIRED" == "true" ]]; then
                    echo -e "${RED}âŒ GPG signature verification FAILED!${NC}"
                    rm -f "$signature_file"
                    return 1
                else
                    echo -e "${YELLOW}âš ï¸  GPG verification failed, continuing anyway${NC}"
                    rm -f "$signature_file"
                    return 0
                fi
            fi
        fi
    else
        if [[ "$GPG_SIGNATURE_REQUIRED" == "true" ]]; then
            echo -e "${RED}âŒ GPG signature required but not found${NC}"
            return 1
        fi
    fi
    
    return 0
}

# ðŸ” Verify SHA256 checksum (MANDATORY)
verify_sha256() {
    local file="$1"
    local expected_sha="$2"
    
    # SHA256 is MANDATORY - no bypasses for security
    if [[ -z "$expected_sha" ]]; then
        echo -e "${RED}âŒ SECURITY ERROR: No SHA256 checksum found!${NC}"
        echo -e "${RED}Update cannot proceed without SHA256 verification.${NC}"
        echo -e "${YELLOW}This protects you from corrupted or malicious files.${NC}"
        return 1
    fi
    
    echo -e "${CYAN}ðŸ” Verifying SHA256 checksum...${NC}"
    local actual_sha=$(sha256sum "$file" | awk '{print $1}')
    
    echo -e "${GRAY}Expected: ${expected_sha}${NC}"
    echo -e "${GRAY}Actual:   ${actual_sha}${NC}"
    
    if [[ "$actual_sha" == "$expected_sha" ]]; then
        echo -e "${GREEN}      âœ“ SHA256 MATCH - File integrity confirmed!${NC}"
        return 0
    else
        echo -e "${RED}âŒ SHA256 MISMATCH! File is corrupted or tampered!${NC}"
        echo -e "${RED}Update aborted for your safety.${NC}"
        return 1
    fi
}

# ðŸ“¥ Extract SHA256 from release body and assets
extract_sha256_from_release() {
    local release_json="$1"
    local sha256=""
    
    # Method 1: Try to fetch SHA256 from GitHub's asset metadata (auto-generated)
    # GitHub automatically computes SHA256 for all release assets
    local assets_url=$(echo "$release_json" | sed -n 's/.*"assets_url": *"\([^"]*\)".*/\1/p')
    if [[ -n "$assets_url" ]]; then
        local assets_json=$(curl -sL --ssl-reqd --tlsv1.2 "$assets_url" -m 10 2>/dev/null)
        
        # Extract the asset object for convert.sh file
        # GitHub provides the SHA256 in the asset URL (after /assets/)
        # Format: https://api.github.com/repos/.../releases/assets/{asset_id}
        # The asset_id is actually derived from the content hash
        
        # First, try to find convert.sh in the assets
        local asset_info=$(echo "$assets_json" | grep -A 20 '"name": *"convert.sh"' | head -25)
        
        if [[ -n "$asset_info" ]]; then
            # GitHub doesn't expose SHA256 directly in API, but we can:
            # 1. Download the convert.sh asset and compute its SHA256
            # 2. Or look for a separate .sha256 file in assets
            
            # Try option 2 first (separate checksum file)
            local sha256_url=$(echo "$assets_json" | sed -n 's/.*"browser_download_url": *"\([^"]*\\.sha256\)".*/\1/p' | head -1)
            if [[ -z "$sha256_url" ]]; then
                sha256_url=$(echo "$assets_json" | sed -n 's/.*"browser_download_url": *"\([^"]*convert\\.sh\\.sha256\)".*/\1/p' | head -1)
            fi
            if [[ -z "$sha256_url" ]]; then
                sha256_url=$(echo "$assets_json" | sed -n 's/.*"browser_download_url": *"\([^"]*checksum\)".*/\1/p' | head -1)
            fi
            
            if [[ -n "$sha256_url" ]]; then
                sha256=$(curl -sL --ssl-reqd --tlsv1.2 "$sha256_url" -m 10 2>/dev/null | grep -oE '[a-f0-9]{64}' | head -1)
                if [[ -n "$sha256" ]]; then
                    echo "$sha256"
                    return 0
                fi
            fi
            
            # Option 1: Download the convert.sh asset and compute SHA256
            # This is our automatic fallback - GitHub will have the file
            local asset_url=$(echo "$asset_info" | sed -n 's/.*"browser_download_url": *"\([^"]*\)".*/\1/p' | head -1)
            if [[ -n "$asset_url" ]]; then
                # Download asset to temp file and compute SHA256
                local temp_asset="/tmp/convert_sh_asset_$$.tmp"
                if curl -sL --ssl-reqd --tlsv1.2 "$asset_url" -o "$temp_asset" -m 30 2>/dev/null; then
                    sha256=$(sha256sum "$temp_asset" 2>/dev/null | awk '{print $1}')
                    rm -f "$temp_asset"
                    if [[ -n "$sha256" && "$sha256" =~ ^[a-f0-9]{64}$ ]]; then
                        echo "$sha256"
                        return 0
                    fi
                fi
            fi
        fi
    fi
    
    # Method 2: Extract from release body
    local release_body=$(echo "$release_json" | sed -n 's/.*"body": *"\([^"]*\)".*/\1/p' | sed 's/\\n/\n/g' | sed 's/\\r//g')
    sha256=$(echo "$release_body" | grep -iE '(sha256|checksum)' | grep -oE '[a-f0-9]{64}' | head -1)
    
    if [[ -n "$sha256" ]]; then
        echo "$sha256"
        return 0
    fi
    
    # No SHA256 found
    return 1
}

# ðŸš€ Perform update with SHA256 verification
perform_update() {
    local new_version="$1"
    local release_tag="$2"
    local release_json="$3"
    
    # Set up atomic update protection
    local update_lock="${BASH_SOURCE[0]}.updating"
    local update_temp="${BASH_SOURCE[0]}.new"
    local update_backup="${BASH_SOURCE[0]}.backup"
    
    # Trap interruptions for cleanup
    trap 'update_cleanup_on_interrupt "$update_lock" "$update_temp" "$update_backup"' INT TERM HUP
    
    # Check if previous update was interrupted
    if [[ -f "$update_lock" ]]; then
        echo -e "${YELLOW}âš ï¸  Previous update was interrupted!${NC}"
        recover_from_interrupted_update "$update_lock" "$update_backup"
    fi
    
    # Create update lock file
    echo "UPDATE_IN_PROGRESS" > "$update_lock"
    
    echo -e "${CYAN}â¬‡ï¸  Downloading v${new_version} from ${release_tag}...${NC}"
    
    # Extract SHA256 from release (tries assets first, then body)
    local expected_sha256=$(extract_sha256_from_release "$release_json")
    
    if [[ -n "$expected_sha256" ]]; then
        echo -e "${GREEN}âœ“ Found SHA256 checksum for verification${NC}"
    else
        echo -e "${YELLOW}âš ï¸  No SHA256 checksum found in release${NC}"
    fi
    
    # Extract release timestamp for fingerprint tracking
    local release_timestamp_iso=$(echo "$release_json" | sed -n 's/.*"published_at": *"\([^"]*\)".*/\1/p')
    local release_timestamp=0
    if [[ -n "$release_timestamp_iso" ]]; then
        release_timestamp=$(date -d "$release_timestamp_iso" +%s 2>/dev/null || echo "0")
    fi
    
    # Create backup (atomic operation)
    local backup_dir="$LOG_DIR/backups"
    mkdir -p "$backup_dir" 2>/dev/null
    local backup_file="$backup_dir/convert.sh.v${CURRENT_VERSION}-$(date +%Y%m%d-%H%M%S)"
    
    # Create atomic backup
    if ! cp "${BASH_SOURCE[0]}" "$update_backup" 2>/dev/null; then
        echo -e "${RED}âŒ Failed to create safety backup${NC}"
        rm -f "$update_lock"
        trap - INT TERM HUP
        return 1
    fi
    
    # Also save to backups directory
    cp "${BASH_SOURCE[0]}" "$backup_file" 2>/dev/null
    echo -e "${GREEN}âœ“ Backup: $backup_file${NC}"
    
    # Download with HTTPS SSL verification
    local download_url="https://raw.githubusercontent.com/${GITHUB_REPO}/${release_tag}/convert.sh"
    local fallback_url="https://raw.githubusercontent.com/${GITHUB_REPO}/main/convert.sh"
    
    # Verify URLs are from trusted GitHub domains
    if [[ ! "$download_url" =~ ^https://raw\.githubusercontent\.com/ ]] || [[ ! "$fallback_url" =~ ^https://raw\.githubusercontent\.com/ ]]; then
        echo -e "${RED}âŒ Security error: Invalid download URL (not from GitHub)${NC}"
        return 1
    fi
    
    echo -e "${BLUE}ðŸ”’ Downloading with SSL certificate verification...${NC}"
    echo -e "${CYAN}Source: ${download_url}${NC}"
    echo ""
    
    # Download with progress bar
    if ! curl -L --ssl-reqd --tlsv1.2 --progress-bar "$download_url" -o convert.sh.new 2>&1 | \
         while IFS= read -r line; do
             # Show curl's progress bar
             echo -ne "\r${CYAN}â¬‡ï¸  ${line}${NC}"
         done || [[ ! -s "convert.sh.new" ]]; then
        echo ""
        echo -e "${YELLOW}âš ï¸  Tag download failed, trying main branch...${NC}"
        echo -e "${CYAN}Source: ${fallback_url}${NC}"
        echo ""
        if ! curl -L --ssl-reqd --tlsv1.2 --progress-bar "$fallback_url" -o convert.sh.new 2>&1 | \
             while IFS= read -r line; do
                 echo -ne "\r${CYAN}â¬‡ï¸  ${line}${NC}"
             done; then
            echo ""
            echo -e "${RED}âŒ SSL verification failed or download error${NC}"
            return 1
        fi
    fi
    echo ""  # New line after progress
    echo -e "${GREEN}âœ“ Download complete${NC}"
    
    if [[ ! -f "convert.sh.new" ]] || [[ ! -s "convert.sh.new" ]]; then
        echo -e "${RED}âŒ Download failed${NC}"
        return 1
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘              ðŸ”’ SECURITY VERIFICATION                       â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${BLUE}Running multiple security checks...${NC}"
    echo ""
    
    # Security Check 1: File size sanity check
    echo -e "${CYAN}[1/6] Checking file size...${NC}"
    local file_size=$(stat -c%s -- "convert.sh.new" 2>/dev/null || echo "0")
    if [[ $file_size -lt $MIN_FILE_SIZE ]]; then
        echo -e "${RED}âŒ Downloaded file too small ($file_size bytes) - possibly corrupted or fake${NC}"
        rm -f convert.sh.new
        return 1
    fi
    echo -e "${GREEN}      âœ“ File size check passed ($file_size bytes)${NC}"
    
    # Security Check 2: Verify file starts with shebang
    echo -e "${CYAN}[2/6] Verifying file format...${NC}"
    local first_line=$(head -n1 "convert.sh.new" 2>/dev/null)
    if [[ ! "$first_line" =~ ^#!/.*bash ]]; then
        echo -e "${RED}âŒ File doesn't appear to be a valid bash script${NC}"
        rm -f convert.sh.new
        return 1
    fi
    echo -e "${GREEN}      âœ“ File format check passed${NC}"
    
    # Security Check 2.5: Verify downloaded file version matches expected version
    echo -e "${CYAN}[2.5/6] Verifying version number...${NC}"
    local downloaded_version=$(grep -m1 '^CURRENT_VERSION=' "convert.sh.new" 2>/dev/null | cut -d'"' -f2)
    
    if [[ -z "$downloaded_version" ]]; then
        echo -e "${RED}âŒ Cannot detect version in downloaded file${NC}"
        rm -f convert.sh.new
        return 1
    fi
    
    # Ensure downloaded version matches the release we're trying to install
    if [[ "$downloaded_version" != "$new_version" ]]; then
        echo -e "${RED}âŒ VERSION MISMATCH!${NC}"
        echo -e "${RED}   Expected: v${new_version}${NC}"
        echo -e "${RED}   Got: v${downloaded_version}${NC}"
        echo -e "${YELLOW}This can happen if a new release was published during download.${NC}"
        echo -e "${YELLOW}Please run the update again to get the correct version.${NC}"
        rm -f convert.sh.new
        return 1
    fi
    echo -e "${GREEN}      âœ“ Version verified: v${downloaded_version}${NC}"
    
    # Security Check 3: GPG signature verification (if available)
    echo -e "${CYAN}[3/6] Checking GPG signature...${NC}"
    local sig_url=""
    if [[ -n "$assets_url" ]]; then
        local assets_json=$(curl -sL --ssl-reqd --tlsv1.2 "$(echo "$release_json" | sed -n 's/.*"assets_url": *"\([^"]*\)".*/\1/p')" -m 10 2>/dev/null)
        sig_url=$(echo "$assets_json" | sed -n 's/.*"browser_download_url": *"\([^"]*\\.sig\)".*/\1/p' | head -1)
    fi
    
    if ! verify_gpg_signature "convert.sh.new" "$sig_url"; then
        rm -f convert.sh.new
        return 1
    fi
    
    # Security Check 4: SHA256 checksum
    echo -e "${CYAN}[4/6] Verifying SHA256 checksum...${NC}"
    if ! verify_sha256 "convert.sh.new" "$expected_sha256"; then
        rm -f convert.sh.new
        return 1
    fi
    
    # Security Check 5: Bash syntax validation
    echo -e "${CYAN}[5/6] Validating bash syntax...${NC}"
    if ! bash -n convert.sh.new 2>/dev/null; then
        echo -e "${RED}âŒ Syntax error in download${NC}"
        rm -f convert.sh.new
        return 1
    fi
    echo -e "${GREEN}      âœ“ Syntax validation passed${NC}"
    
    # Security Check 6: Install (ATOMIC OPERATION)
    echo -e "${CYAN}[6/6] Installing update...${NC}"
    
    # Atomic replace using mv (single syscall, safe even if interrupted)
    if ! mv -f "convert.sh.new" "${BASH_SOURCE[0]}" 2>/dev/null; then
        echo -e "${RED}âŒ Installation failed!${NC}"
        echo -e "${YELLOW}Restoring from backup...${NC}"
        mv -f "$update_backup" "${BASH_SOURCE[0]}" 2>/dev/null
        rm -f "$update_lock"
        trap - INT TERM HUP
        return 1
    fi
    
    chmod +x "${BASH_SOURCE[0]}" 2>/dev/null
    
    # Clean up atomic update files
    rm -f "$update_lock" "$update_backup" 2>/dev/null
    
    # Remove trap
    trap - INT TERM HUP
    
    echo -e "${GREEN}      âœ“ Installation complete${NC}"
    
    # Security Check 7: Update release fingerprint with verified SHA256 and timestamp
    echo -e "${CYAN}[7/7] Updating release fingerprint...${NC}"
    if update_release_fingerprint "$new_version" "$release_tag" "$expected_sha256" "$release_timestamp"; then
        echo -e "${GREEN}      âœ“ Release fingerprint saved${NC}"
    else
        echo -e "${YELLOW}âš ï¸  Warning: Could not update release fingerprint${NC}"
    fi
    
    echo ""
    echo -e "${GREEN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${GREEN}${BOLD}â•‘               âœ“ UPDATE SUCCESSFUL!                          â•‘${NC}"
    echo -e "${GREEN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${CYAN}Updated from v${CURRENT_VERSION} to v${new_version}${NC}"
    echo -e "${BLUE}Backup saved at: ${backup_file}${NC}"
    echo -e "${BLUE}Fingerprint: ${expected_sha256:0:16}...${NC}"
    echo ""
    echo -e "${YELLOW}ðŸ”„ Please restart the script to use the new version${NC}"
    echo ""
    exit 0
}

# ðŸ”§ Manual update command
manual_update() {
    # ðŸ› ï¸ Block manual updates in development mode
    if [[ "$DEV_MODE" == "true" ]]; then
        echo ""
        echo -e "${YELLOW}âš ï¸  Development Mode Active${NC}"
        echo -e "${RED}ðŸš« Auto-update is disabled in Git repositories${NC}"
        echo ""
        echo -e "${BLUE}This protects your development work from being overwritten.${NC}"
        echo -e "${GRAY}If you want to update:${NC}"
        echo -e "${GRAY}1. Commit your changes: ${GREEN}git commit -am 'Your changes'${NC}"
        echo -e "${GRAY}2. Pull latest: ${GREEN}git pull origin main${NC}"
        echo ""
        return 1
    fi
    
    echo -e "${CYAN}ðŸ”„ Checking GitHub Releases for stable versions...${NC}"
    echo -e "${GRAY}   API Endpoint: ${GITHUB_API_URL}${NC}"
    echo -ne "${BLUE}   Fetching... ${NC}"
    
    local release_json=$(curl -s --ssl-reqd --tlsv1.2 "$GITHUB_API_URL" 2>/dev/null)
    
    if [[ -n "$release_json" ]]; then
        echo -e "${GREEN}âœ“${NC}"
    else
        echo -e "${RED}âœ—${NC}"
    fi
    
    # Check if request failed or no releases exist
    if [[ -z "$release_json" ]]; then
        echo -e "${RED}âŒ Cannot connect to GitHub${NC}"
        echo -e "${BLUE}Visit: ${GITHUB_RELEASES_URL}${NC}"
        return 1
    fi
    
    if [[ "$release_json" == *"Not Found"* ]]; then
        echo -e "${YELLOW}âš ï¸  No releases found in repository${NC}"
        echo -e "${GRAY}ðŸ“Š This appears to be the first version (v${CURRENT_VERSION})${NC}"
        echo -e "${BLUE}ðŸ“ GitHub Releases: ${CYAN}${GITHUB_RELEASES_URL}${NC}"
        echo -e "${GRAY}ðŸ’¡ Tip: Create a release on GitHub to enable version checking${NC}"
        return 0
    fi
    
    # Verify this is a stable release (not pre-release or draft)
    local is_prerelease=$(echo "$release_json" | grep -o '"prerelease":[^,]*' | grep -o 'true\|false')
    local is_draft=$(echo "$release_json" | grep -o '"draft":[^,]*' | grep -o 'true\|false')
    
    if [[ "$is_prerelease" == "true" ]] || [[ "$is_draft" == "true" ]]; then
        echo -e "${YELLOW}âš ï¸  Latest release is a pre-release or draft, skipping${NC}"
        echo -e "${BLUE}Only stable releases are used for updates${NC}"
        return 0
    fi
    
    local remote_tag=$(echo "$release_json" | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p' | head -1)
    local release_name=$(echo "$release_json" | sed -n 's/.*"name": *"\([^"]*\)".*/\1/p' | head -1)
    
    # Debug: show what tag we got
    if [[ -z "$remote_tag" ]]; then
        echo -e "${RED}âŒ No releases found in repository${NC}"
        echo -e "${YELLOW}ðŸ“Š This appears to be the first version (v${CURRENT_VERSION})${NC}"
        echo -e "${BLUE}ðŸ“ GitHub Releases: ${CYAN}${GITHUB_RELEASES_URL}${NC}"
        echo -e "${GRAY}ðŸ’¡ Tip: Create a release on GitHub to enable version checking${NC}"
        return 0
    fi
    
    # Try to extract version from tag first, then from release name
    # Bulletproof: remove all non-digit/non-dot characters (handles v8.1, 8.1, v8.1.1, etc)
    local remote_version=$(echo "$remote_tag" | sed 's/[^0-9.]//g' | grep -E '^[0-9]' || echo "")
    
    # If tag doesn't have version, try release name
    if [[ -z "$remote_version" && -n "$release_name" ]]; then
        remote_version=$(echo "$release_name" | sed 's/[^0-9.]//g' | grep -E '^[0-9]' || echo "")
    fi
    
    # Clean up version (remove leading/trailing dots, multiple dots)
    remote_version=$(echo "$remote_version" | sed 's/^\.\+//;s/\.\+$//;s/\.\+/./g')
    
    local release_body=$(echo "$release_json" | sed -n 's/.*"body": *"\([^"]*\)".*/\1/p' | sed 's/\\r//g; s/\\n/\n/g')
    
    # Extract release timestamp for validation
    local remote_timestamp_iso=$(echo "$release_json" | sed -n 's/.*"published_at": *"\([^"]*\)".*/\1/p')
    local remote_timestamp=0
    if [[ -n "$remote_timestamp_iso" ]]; then
        remote_timestamp=$(date -d "$remote_timestamp_iso" +%s 2>/dev/null || echo "0")
    fi
    
    # Additional safety: verify tag doesn't contain RC, beta, alpha, or pre markers
    if [[ "$remote_tag" =~ (rc|RC|beta|BETA|alpha|ALPHA|pre|PRE) ]]; then
        echo -e "${YELLOW}âš ï¸  Skipping release candidate or pre-release: ${remote_tag}${NC}"
        echo -e "${BLUE}Only stable releases are used for updates${NC}"
        return 0
    fi
    
    if [[ -z "$remote_version" ]]; then
        echo -e "${RED}âŒ Cannot parse version from tag: ${remote_tag}${NC}"
        echo -e "${YELLOW}ðŸ’¡ Expected format: v6.1.1 or 6.0${NC}"
        echo -e "${BLUE}ðŸ“ GitHub Releases: ${CYAN}${GITHUB_RELEASES_URL}${NC}"
        return 1
    fi
    
    # Load installed fingerprint for timestamp comparison
    load_release_fingerprint 2>/dev/null
    
    # Timestamp validation: prevent downgrade to older releases
    if [[ "$remote_timestamp" -gt 0 && "$INSTALLED_RELEASE_TIMESTAMP" != "0" ]]; then
        if [[ "$remote_timestamp" -le "$INSTALLED_RELEASE_TIMESTAMP" ]]; then
            echo -e "${YELLOW}âš ï¸  Remote release is not newer than installed version (timestamp check)${NC}"
            echo -e "${GREEN}âœ“ Already have the latest release${NC}"
            return 0
        fi
    fi
    
    if [[ "$remote_version" == "$CURRENT_VERSION" ]]; then
        echo -e "${GREEN}âœ“ Already latest (v${CURRENT_VERSION})${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${YELLOW}Current: v${CURRENT_VERSION}${NC} â†’ ${GREEN}Available: v${remote_version}${NC}"
    echo -e "${BLUE}ðŸ“ Release notes (first 10 lines):${NC}"
    echo "$release_body" | head -10 | sed 's/^/  /'
    echo ""
    echo -ne "${YELLOW}Update now? [y/N]: ${NC}"
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
        perform_update "$remote_version" "$remote_tag" "$release_json"
    fi
}

# ðŸ“ Show version info
show_version_info() {
    echo -e "${CYAN}${BOLD}Smart GIF Converter v${CURRENT_VERSION}${NC}"
    echo -e "${BLUE}Repository: ${CYAN}https://github.com/${GITHUB_REPO}${NC}"
    echo -e "${BLUE}Releases: ${CYAN}${GITHUB_RELEASES_URL}${NC}"
}

# ðŸ›¡ï¸ Cleanup on update interruption
update_cleanup_on_interrupt() {
    local lock_file="$1"
    local temp_file="$2"
    local backup_file="$3"
    
    echo ""
    echo -e "${RED}âŒ Update interrupted!${NC}"
    
    # Clean up temporary files
    rm -f "$temp_file" "convert.sh.new" 2>/dev/null
    
    # Check if original file still exists
    if [[ ! -f "${BASH_SOURCE[0]}" ]] && [[ -f "$backup_file" ]]; then
        echo -e "${YELLOW}Restoring from backup...${NC}"
        mv -f "$backup_file" "${BASH_SOURCE[0]}" 2>/dev/null
        chmod +x "${BASH_SOURCE[0]}" 2>/dev/null
        echo -e "${GREEN}âœ“ Original file restored${NC}"
    fi
    
    # Keep lock file to detect interrupted update on next run
    echo -e "${BLUE}â„¹ï¸  Update was safely cancelled. Original file is intact.${NC}"
    exit 1
}

# ðŸ”„ Recover from previously interrupted update
recover_from_interrupted_update() {
    local lock_file="$1"
    local backup_file="$2"
    
    echo -e "${CYAN}Checking for recovery...${NC}"
    
    # If backup exists and original is missing or corrupted
    if [[ -f "$backup_file" ]]; then
        if [[ ! -f "${BASH_SOURCE[0]}" ]]; then
            echo -e "${YELLOW}Original file missing, restoring from backup...${NC}"
            mv -f "$backup_file" "${BASH_SOURCE[0]}" 2>/dev/null
            chmod +x "${BASH_SOURCE[0]}" 2>/dev/null
            echo -e "${GREEN}âœ“ File restored from backup${NC}"
        elif ! bash -n "${BASH_SOURCE[0]}" 2>/dev/null; then
            echo -e "${YELLOW}Original file corrupted, restoring from backup...${NC}"
            mv -f "$backup_file" "${BASH_SOURCE[0]}" 2>/dev/null
            chmod +x "${BASH_SOURCE[0]}" 2>/dev/null
            echo -e "${GREEN}âœ“ Corrupted file replaced with backup${NC}"
        else
            echo -e "${GREEN}âœ“ Original file is intact${NC}"
            rm -f "$backup_file" 2>/dev/null
        fi
    fi
    
    # Clean up lock file
    rm -f "$lock_file" 2>/dev/null
    echo -e "${GREEN}âœ“ Recovery check complete${NC}"
    echo ""
}

# ðŸ” Load release fingerprint from file
load_release_fingerprint() {
    if [[ -f "$RELEASE_FINGERPRINT_FILE" ]]; then
        # Load fingerprint data
        INSTALLED_RELEASE_SHA256=$(grep '^SHA256=' "$RELEASE_FINGERPRINT_FILE" 2>/dev/null | cut -d'=' -f2)
        INSTALLED_RELEASE_VERSION=$(grep '^VERSION=' "$RELEASE_FINGERPRINT_FILE" 2>/dev/null | cut -d'=' -f2)
        INSTALLED_RELEASE_TAG=$(grep '^TAG=' "$RELEASE_FINGERPRINT_FILE" 2>/dev/null | cut -d'=' -f2)
        INSTALLED_RELEASE_TIMESTAMP=$(grep '^RELEASE_TIMESTAMP=' "$RELEASE_FINGERPRINT_FILE" 2>/dev/null | cut -d'=' -f2)
        
        # Default to 0 if not found
        [[ -z "$INSTALLED_RELEASE_TIMESTAMP" ]] && INSTALLED_RELEASE_TIMESTAMP="0"
        
        # Validate loaded data
        if [[ -n "$INSTALLED_RELEASE_SHA256" && "$INSTALLED_RELEASE_VERSION" == "$CURRENT_VERSION" ]]; then
            return 0  # Valid fingerprint loaded
        fi
    fi
    
    # No fingerprint or version mismatch - create new fingerprint
    create_release_fingerprint
    return $?
}

# ðŸ” Create release fingerprint for current installation
create_release_fingerprint() {
    echo -e "${CYAN}ðŸ” Creating release fingerprint...${NC}"
    
    # Calculate SHA256 of current script
    local script_sha256=$(sha256sum "${BASH_SOURCE[0]}" 2>/dev/null | awk '{print $1}')
    
    if [[ -z "$script_sha256" ]]; then
        echo -e "${YELLOW}âš ï¸  Warning: Cannot calculate script checksum${NC}"
        return 1
    fi
    
    # Create/update fingerprint file
    mkdir -p "$(dirname "$RELEASE_FINGERPRINT_FILE")" 2>/dev/null
    
    cat > "$RELEASE_FINGERPRINT_FILE" <<EOF
# Smart GIF Converter - Release Fingerprint
# This file tracks the SHA256 checksum of the installed version
# Created: $(date '+%Y-%m-%d %H:%M:%S')

VERSION=$CURRENT_VERSION
SHA256=$script_sha256
TAG=
RELEASE_TIMESTAMP=0
INSTALL_DATE=$(date +%s)
INSTALL_DATE_READABLE=$(date '+%Y-%m-%d %H:%M:%S')
EOF
    
    # Update in-memory variables
    INSTALLED_RELEASE_SHA256="$script_sha256"
    INSTALLED_RELEASE_VERSION="$CURRENT_VERSION"
    INSTALLED_RELEASE_TAG=""
    INSTALLED_RELEASE_TIMESTAMP="0"
    
    echo -e "${GREEN}âœ“ Release fingerprint created${NC}"
    echo -e "${GRAY}Version: v${CURRENT_VERSION}${NC}"
    echo -e "${GRAY}SHA256: ${script_sha256:0:16}...${NC}"
    
    return 0
}

# ðŸ” Update release fingerprint after successful update
update_release_fingerprint() {
    local new_version="$1"
    local new_tag="$2"
    local new_sha256="$3"
    local new_timestamp="${4:-0}"  # GitHub release timestamp
    
    if [[ -z "$new_sha256" ]]; then
        # Calculate SHA256 of newly installed script
        new_sha256=$(sha256sum "${BASH_SOURCE[0]}" 2>/dev/null | awk '{print $1}')
    fi
    
    if [[ -z "$new_sha256" ]]; then
        echo -e "${YELLOW}âš ï¸  Warning: Cannot calculate new script checksum${NC}"
        return 1
    fi
    
    # Update fingerprint file
    mkdir -p "$(dirname "$RELEASE_FINGERPRINT_FILE")" 2>/dev/null
    
    cat > "$RELEASE_FINGERPRINT_FILE" <<EOF
# Smart GIF Converter - Release Fingerprint
# This file tracks the SHA256 checksum of the installed version
# Updated: $(date '+%Y-%m-%d %H:%M:%S')

VERSION=$new_version
SHA256=$new_sha256
TAG=$new_tag
RELEASE_TIMESTAMP=$new_timestamp
INSTALL_DATE=$(date +%s)
INSTALL_DATE_READABLE=$(date '+%Y-%m-%d %H:%M:%S')
PREVIOUS_VERSION=$INSTALLED_RELEASE_VERSION
PREVIOUS_SHA256=$INSTALLED_RELEASE_SHA256
PREVIOUS_TIMESTAMP=$INSTALLED_RELEASE_TIMESTAMP
EOF
    
    # Update in-memory variables
    INSTALLED_RELEASE_SHA256="$new_sha256"
    INSTALLED_RELEASE_VERSION="$new_version"
    INSTALLED_RELEASE_TAG="$new_tag"
    INSTALLED_RELEASE_TIMESTAMP="$new_timestamp"
    
    echo -e "${GREEN}âœ“ Release fingerprint updated${NC}"
    
    return 0
}

# ðŸ” Verify current installation matches fingerprint
verify_installation_integrity() {
    if [[ -z "$INSTALLED_RELEASE_SHA256" ]]; then
        # No fingerprint loaded
        return 1
    fi
    
    # Calculate current SHA256
    local current_sha256=$(sha256sum "${BASH_SOURCE[0]}" 2>/dev/null | awk '{print $1}')
    
    if [[ "$current_sha256" == "$INSTALLED_RELEASE_SHA256" ]]; then
        return 0  # Integrity verified
    else
        return 1  # Mismatch detected
    fi
}

# ðŸ†• First-run auto-update preference prompt
prompt_auto_update_preference() {
    # Skip if already asked or if settings exist with preference
    if [[ "$UPDATE_FIRST_RUN_PROMPT_DONE" == "true" ]] || grep -q "AUTO_UPDATE_ENABLED=" "$SETTINGS_FILE" 2>/dev/null; then
        return 0
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘               ðŸ”„ AUTOMATIC UPDATE CHECKS                       â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${BLUE}This script can automatically check for updates from GitHub.${NC}"
    echo -e "${GRAY}Updates include bug fixes, new features, and improvements.${NC}"
    echo ""
    echo -e "${YELLOW}How it works:${NC}"
    echo -e "  ${GREEN}â€¢${NC} Checks GitHub once per day (non-intrusive)"
    echo -e "  ${GREEN}â€¢${NC} Shows a notification when updates are available"
    echo -e "  ${GREEN}â€¢${NC} You choose when to install updates"
    echo -e "  ${GREEN}â€¢${NC} Updates include SHA256 verification for security"
    echo ""
    echo -e "${CYAN}Would you like to enable automatic update checks?${NC}"
    echo -e "${GRAY}(You can change this anytime in settings)${NC}"
    echo ""
    echo -e "  ${GREEN}[Y]${NC} Yes - Check for updates automatically (recommended)"
    echo -e "  ${YELLOW}[N]${NC} No - I'll check manually with ${GREEN}./convert.sh --check-update${NC}"
    echo ""
    echo -ne "${YELLOW}Your choice [Y/n]: ${NC}"
    read -r auto_update_choice
    
    case "$auto_update_choice" in
        [Nn]*)
            AUTO_UPDATE_ENABLED=false
            echo -e "\n${BLUE}â„¹ï¸  Auto-update disabled. You can manually check with: ${GREEN}./convert.sh --check-update${NC}"
            ;;
        *)
            AUTO_UPDATE_ENABLED=true
            echo -e "\n${GREEN}âœ“ Auto-update enabled! Checking for updates once per day.${NC}"
            ;;
    esac
    
    UPDATE_FIRST_RUN_PROMPT_DONE=true
    
    # Save preference to settings
    if [[ -n "$SETTINGS_FILE" ]]; then
        save_settings --silent
    fi
    
    echo -e "${BLUE}ðŸ’¡ Current version: ${BOLD}v${CURRENT_VERSION}${NC}"
    echo -e "${GRAY}Press Enter to continue...${NC}"
    read -r
    
    return 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ðŸ§  REVOLUTIONARY AI TRAINING & LEARNING SYSTEM
# Self-improving duplicate detection through user feedback learning
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Initialize AI training system
init_ai_training() {
    if [[ "$AI_TRAINING_ENABLED" != "true" ]]; then
        return 0
    fi
    
    mkdir -p "$AI_TRAINING_DIR" 2>/dev/null || {
        AI_TRAINING_ENABLED=false
        return 1
    }
    
    if [[ ! -f "$AI_MODEL_FILE" ]]; then
        create_initial_ai_model
    else
        load_ai_model
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] AI Training System initialized - Generation $AI_GENERATION" >> "$AI_TRAINING_LOG" 2>/dev/null
}

# Create initial AI model with default weights
create_initial_ai_model() {
    cat > "$AI_MODEL_FILE" << 'EOF'
# AI Training Model Database - Version 1.0
# Format: feature_type|feature_value|weight|confidence|samples|last_updated
filename_similarity_high|exact_15chars|0.95|0.8|0|TIMESTAMP
filename_similarity_med|exact_10chars|0.75|0.8|0|TIMESTAMP
filename_similarity_low|exact_5chars|0.40|0.7|0|TIMESTAMP
size_similarity_exact|diff_0-5pct|0.90|0.9|0|TIMESTAMP
size_similarity_high|diff_5-15pct|0.70|0.8|0|TIMESTAMP
size_similarity_med|diff_15-30pct|0.45|0.7|0|TIMESTAMP
visual_hash_match|exact|1.00|0.95|0|TIMESTAMP
frame_count_exact|match|0.95|0.9|0|TIMESTAMP
frame_count_close|diff_0-5pct|0.85|0.8|0|TIMESTAMP
duration_exact|match|0.95|0.9|0|TIMESTAMP
duration_close|diff_0-5pct|0.80|0.8|0|TIMESTAMP
content_fingerprint|exact|0.85|0.85|0|TIMESTAMP
EOF
    sed -i "s/TIMESTAMP/$(date +%s)/g" "$AI_MODEL_FILE"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] AI Model created - Generation $AI_GENERATION" >> "$AI_TRAINING_LOG" 2>/dev/null
}

# Load AI model into memory
load_ai_model() {
    declare -gA AI_WEIGHTS
    declare -gA AI_CONFIDENCES
    declare -gA AI_SAMPLES
    
    while IFS='|' read -r feature_type feature_value weight confidence samples last_updated; do
        [[ "$feature_type" =~ ^# ]] && continue
        [[ -z "$feature_type" ]] && continue
        
        local key="${feature_type}:${feature_value}"
        AI_WEIGHTS["$key"]="$weight"
        AI_CONFIDENCES["$key"]="$confidence"
        AI_SAMPLES["$key"]="$samples"
    done < "$AI_MODEL_FILE" 2>/dev/null || true
}

# Train AI from user decision (REVOLUTIONARY LEARNING!)
train_ai_from_decision() {
    local file1="$1"
    local file2="$2"
    local similarity_score="$3"
    local user_decision="$4"
    local detection_level="$5"
    
    [[ "$AI_TRAINING_ENABLED" != "true" ]] && return 0
    
    local name1="$(basename -- "$file1")"
    local name2="$(basename -- "$file2")"
    local size1="${gif_sizes["$file1"]:-${video_sizes["$file1"]:-0}}"
    local size2="${gif_sizes["$file2"]:-${video_sizes["$file2"]:-0}}"
    
    local filename_match_len=0
    for ((i=0; i<${#name1} && i<${#name2}; i++)); do
        [[ "${name1:i:1}" == "${name2:i:1}" ]] && ((filename_match_len++)) || break
    done
    
    local size_diff_pct=0
    if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
        size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
    fi
    
    local is_duplicate=false
    [[ "$user_decision" == "delete_"* ]] && is_duplicate=true
    
    update_feature_weight "filename_similarity" "$filename_match_len" "$is_duplicate" "$detection_level"
    update_feature_weight "size_similarity" "$size_diff_pct" "$is_duplicate" "$detection_level"
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] TRAINING: $detection_level | Decision:$user_decision | Duplicate:$is_duplicate" >> "$AI_TRAINING_LOG" 2>/dev/null
}

# Update feature weight using gradient descent
update_feature_weight() {
    local feature_type="$1"
    local feature_value="$2"
    local is_duplicate="$3"
    local detection_level="$4"
    
    local feature_bucket=""
    case "$feature_type" in
        "filename_similarity")
            if [[ $feature_value -ge 15 ]]; then feature_bucket="exact_15chars"
            elif [[ $feature_value -ge 10 ]]; then feature_bucket="exact_10chars"
            elif [[ $feature_value -ge 5 ]]; then feature_bucket="exact_5chars"
            else return 0; fi
            ;;
        "size_similarity")
            if [[ $feature_value -lt 5 ]]; then feature_bucket="diff_0-5pct"
            elif [[ $feature_value -lt 15 ]]; then feature_bucket="diff_5-15pct"
            elif [[ $feature_value -lt 30 ]]; then feature_bucket="diff_15-30pct"
            else return 0; fi
            ;;
        *) return 0 ;;
    esac
    
    local key="${feature_type}_$(echo $feature_bucket | tr '-' '_')"
    local current_weight="${AI_WEIGHTS[$key]:-0.5}"
    local current_samples="${AI_SAMPLES[$key]:-0}"
    local current_confidence="${AI_CONFIDENCES[$key]:-0.5}"
    
    local target_weight=0.0
    [[ "$is_duplicate" == "true" ]] && target_weight=1.0
    
    local error=$(awk "BEGIN {print $target_weight - $current_weight}")
    local weight_delta=$(awk "BEGIN {print $error * $AI_LEARNING_RATE}")
    local new_weight=$(awk "BEGIN {w=$current_weight + $weight_delta; if(w<0) print 0; else if(w>1) print 1; else print w}")
    
    local new_samples=$((current_samples + 1))
    local new_confidence=$(awk "BEGIN {c=$current_confidence + 0.05 * (1 - $current_confidence); if(c>1) print 1; else print c}")
    
    AI_WEIGHTS["$key"]="$new_weight"
    AI_CONFIDENCES["$key"]="$new_confidence"
    AI_SAMPLES["$key"]="$new_samples"
    
    local temp_model="$(mktemp)"
    awk -v key="${feature_type}|${feature_bucket}" -v w="$new_weight" -v c="$new_confidence" -v s="$new_samples" -v ts="$(date +%s)" '
        BEGIN {FS=OFS="|"; found=0}
        /^#/ {print; next}
        $1"|"$2 == key {print $1,$2,w,c,s,ts; found=1; next}
        {print}
        END {if(!found) print key,w,c,s,ts}
    ' "$AI_MODEL_FILE" > "$temp_model" 2>/dev/null
    
    mv "$temp_model" "$AI_MODEL_FILE" 2>/dev/null || rm -f "$temp_model"
}

# Show AI training statistics
show_ai_training_stats() {
    [[ "$AI_TRAINING_ENABLED" != "true" || ! -f "$AI_MODEL_FILE" ]] && return 0
    
    echo -e "\n${MAGENTA}${BOLD}ðŸ§  AI TRAINING STATUS${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    local total_samples=0
    while IFS='|' read -r ft fv w c s lu; do
        [[ "$ft" =~ ^# || -z "$ft" ]] && continue
        total_samples=$((total_samples + s))
    done < "$AI_MODEL_FILE" 2>/dev/null || true
    
    echo -e "${CYAN}Training samples:${NC} $total_samples"
    if [[ $total_samples -lt $AI_TRAINING_MIN_SAMPLES ]]; then
        echo -e "${YELLOW}âš ï¸  AI needs $AI_TRAINING_MIN_SAMPLES samples to activate (current: $total_samples)${NC}"
    else
        echo -e "${GREEN}âœ… AI is active and learning!${NC}"
    fi
    echo ""
}

# ðŸ—„ï¸ AI Smart Cache Management System (Corruption-Proof)
# =================================================================

# Initialize AI cache system with corruption protection
init_ai_cache() {
    if [[ "$AI_CACHE_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Create cache directory structure
    mkdir -p "$AI_CACHE_DIR" 2>/dev/null || {
        echo -e "${YELLOW}âš ï¸  Warning: Cannot create AI cache directory, disabling cache${NC}" >&2
        AI_CACHE_ENABLED=false
        return 1
    }
    
    # Initialize or validate cache index
    if ! validate_cache_index; then
        echo -e "${YELLOW}ðŸ”„ Cache corruption detected, rebuilding index...${NC}" >&2
        rebuild_cache_index
    fi
    
    # Create backup of cache index
    create_cache_backup
    
    # Smart cleanup: only run every 7 days to avoid slowdown on every launch
    local cleanup_marker="${AI_CACHE_DIR}/.last_cleanup"
    local current_time=$(date +%s)
    local cleanup_interval=$((7 * 86400))  # 7 days in seconds
    local should_cleanup=false
    
    if [[ ! -f "$cleanup_marker" ]]; then
        # No marker file, definitely clean up
        should_cleanup=true
    else
        local last_cleanup=$(cat "$cleanup_marker" 2>/dev/null || echo "0")
        local time_since_cleanup=$((current_time - last_cleanup))
        if [[ $time_since_cleanup -gt $cleanup_interval ]]; then
            should_cleanup=true
        fi
    fi
    
    if [[ "$should_cleanup" == "true" ]]; then
        # Run cleanup in background to not slow down script startup
        (
            cleanup_ai_cache
            echo "$current_time" > "$cleanup_marker" 2>/dev/null
        ) &
        # Save the cleanup PID so we can wait for it later if needed
        CLEANUP_PID=$!
    fi
}

# Validate cache index integrity
validate_cache_index() {
    # Check if cache index exists
    [[ -f "$AI_CACHE_INDEX" ]] || return 1
    
    # Check if file is readable
    [[ -r "$AI_CACHE_INDEX" ]] || return 1
    
    # Check if file has proper header
    local header_line=$(head -n 1 "$AI_CACHE_INDEX" 2>/dev/null || echo "")
    [[ "$header_line" =~ ^#.*Version ]] || return 1
    
    # Check if using old format (md5hash in field 2) - needs migration
    local sample_line=$(grep -v '^#' "$AI_CACHE_INDEX" | head -n 1)
    if [[ -n "$sample_line" ]]; then
        local field2=$(echo "$sample_line" | cut -d'|' -f2)
        # Old format has 32-char hex MD5, new format has numeric filesize
        if [[ "$field2" =~ ^[0-9a-f]{32}$ ]]; then
            echo -e "${YELLOW}ðŸ”„ Old cache format detected, migrating to new format...${NC}" >&2
            migrate_cache_format
            return $?
        fi
    fi
    
    # Check if file structure is valid (no broken lines)
    local line_count=0
    local corrupted_lines=0
    
    while IFS= read -r line; do
        ((line_count++))
        [[ $line_count -le 3 ]] && continue  # Skip header
        
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        
        # Check line format: should have 5+ fields separated by |
        local field_count=$(echo "$line" | tr -cd '|' | wc -c)
        if [[ $field_count -lt 4 ]]; then
            ((corrupted_lines++))
            # If more than 10% of lines are corrupted, fail validation
            if [[ $corrupted_lines -gt 10 ]] && [[ $((corrupted_lines * 10)) -gt $line_count ]]; then
                return 1
            fi
        fi
    done < "$AI_CACHE_INDEX" 2>/dev/null || return 1
    
    return 0
}

# Migrate cache from old format (md5|size) to new format (size|mtime)
migrate_cache_format() {
    local old_cache="${AI_CACHE_INDEX}.old_format.$(date +%s)"
    
    # Backup old cache
    cp "$AI_CACHE_INDEX" "$old_cache" 2>/dev/null
    
    echo -e "  ${BLUE}ðŸ’¾ Backing up old cache to: $(basename -- "$old_cache")${NC}" >&2
    
    # Create new format cache with header
    cat > "$AI_CACHE_INDEX" << EOF
# AI Analysis Cache Index - Version $AI_CACHE_VERSION (Migrated)
# Format: filename|filesize|filemtime|timestamp|analysis_data
# Note: Uses size+mtime for FAST validation (no MD5 recalc needed!)
# Migrated from old format: $(date)
EOF
    
    local migrated=0
    local skipped=0
    
    # Read old format and convert
    while IFS='|' read -r filename md5hash filesize timestamp analysis_data; do
        # Skip headers and empty lines
        [[ "$filename" =~ ^# || -z "$filename" ]] && continue
        
        # Get current mtime for this file (if it still exists)
        local file_path="$filename"
        if [[ ! -f "$file_path" ]]; then
            # Try just the basename in current directory
            file_path="./$(basename -- "$filename" 2>/dev/null)"
        fi
        
        if [[ -f "$file_path" ]]; then
            local filemtime=$(stat -c%Y -- "$file_path" 2>/dev/null || echo "0")
            # Write new format: filename|filesize|filemtime|timestamp|analysis_data
            echo "$filename|$filesize|$filemtime|$timestamp|$analysis_data" >> "$AI_CACHE_INDEX"
            ((migrated++))
        else
            # File doesn't exist anymore, skip it
            ((skipped++))
        fi
    done < "$old_cache"
    
    echo -e "  ${GREEN}âœ“ Migrated $migrated cache entries${NC}" >&2
    [[ $skipped -gt 0 ]] && echo -e "  ${GRAY}âš ï¸  Skipped $skipped entries (files no longer exist)${NC}" >&2
    
    return 0
}

# Rebuild corrupted cache index
rebuild_cache_index() {
    local backup_file="${AI_CACHE_INDEX}.backup.$(date +%s)"
    
    # Backup corrupted file for analysis
    [[ -f "$AI_CACHE_INDEX" ]] && cp "$AI_CACHE_INDEX" "$backup_file" 2>/dev/null
    
    # Create fresh index
    cat > "$AI_CACHE_INDEX" << EOF
# AI Analysis Cache Index - Version $AI_CACHE_VERSION (Rebuilt)
# Format: filename|filesize|filemtime|timestamp|analysis_data
# Note: Uses size+mtime for FAST validation (no MD5 recalc needed!)
# Rebuilt: $(date)
EOF
    
    # Try to recover valid entries from backup
    if [[ -f "$backup_file" ]]; then
        local recovered=0
        while IFS= read -r line; do
            # Skip header and empty lines
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            
            # Validate line format
            local field_count=$(echo "$line" | tr -cd '|' | wc -c)
            if [[ $field_count -ge 4 ]]; then
                echo "$line" >> "$AI_CACHE_INDEX"
                ((recovered++))
            fi
        done < "$backup_file" 2>/dev/null || true
        
        if [[ $recovered -gt 0 ]]; then
            echo -e "${GREEN}âœ… Recovered $recovered cache entries${NC}" >&2
        fi
        
        # Keep backup for a while, then clean up
        (sleep 300 && rm -f "$backup_file") &
    fi
}

# Create atomic backup of cache index
create_cache_backup() {
    if [[ -f "$AI_CACHE_INDEX" ]]; then
        local backup_file="${AI_CACHE_INDEX}.safe"
        cp "$AI_CACHE_INDEX" "$backup_file" 2>/dev/null || true
    fi
}

# Clean up old cache entries, remove duplicates, and purge deleted files
cleanup_ai_cache() {
    if [[ "$AI_CACHE_ENABLED" != "true" || ! -f "$AI_CACHE_INDEX" ]]; then
        return 0
    fi
    
    local cutoff_time=$(($(date +%s) - (AI_CACHE_MAX_AGE_DAYS * 86400)))
    local temp_index="$(mktemp)"
    
    # Keep header
    head -n 3 "$AI_CACHE_INDEX" > "$temp_index"
    
    # Use associative array to keep only the LATEST entry per file (deduplication)
    declare -A latest_entries
    declare -A latest_timestamps
    
    local old_entries=0
    local deleted_files=0
    local duplicate_entries=0
    
    # Read all entries and keep only the most recent per filename
    while IFS='|' read -r filename filesize filemtime timestamp analysis_data; do
        [[ "$filename" =~ ^# ]] && continue  # Skip comments
        [[ -z "$filename" ]] && continue     # Skip empty lines
        
        # Skip old entries (beyond max age)
        if [[ $timestamp -lt $cutoff_time ]]; then
            ((old_entries++))
            continue
        fi
        
        # Check if file still exists (check both absolute path and basename)
        local file_exists=false
        if [[ -f "$filename" ]]; then
            file_exists=true
        elif [[ -f "$(basename -- "$filename")" ]]; then
            file_exists=true
        fi
        
        if [[ "$file_exists" == "false" ]]; then
            ((deleted_files++))
            continue
        fi
        
        # Keep only the latest entry for each filename (deduplication)
        local existing_ts="${latest_timestamps[$filename]:-0}"
        if [[ $timestamp -gt $existing_ts ]]; then
            # This is a newer entry, check if we're replacing an old one
            [[ $existing_ts -gt 0 ]] && ((duplicate_entries++))
            
            latest_timestamps[$filename]=$timestamp
            latest_entries[$filename]="$filename|$filesize|$filemtime|$timestamp|$analysis_data"
        else
            # Older duplicate entry
            ((duplicate_entries++))
        fi
    done < <(tail -n +4 "$AI_CACHE_INDEX")
    
    # Write deduplicated entries to temp file
    for filename in "${!latest_entries[@]}"; do
        echo "${latest_entries[$filename]}" >> "$temp_index"
    done
    
    # Atomically replace cache with cleaned version
    mv "$temp_index" "$AI_CACHE_INDEX"
    
    # Report cleanup results
    local total_cleaned=$((old_entries + deleted_files + duplicate_entries))
    if [[ $total_cleaned -gt 0 ]]; then
        echo -e "  ${BLUE}ðŸ§¹ Cache cleanup complete:${NC}" >&2
        [[ $old_entries -gt 0 ]] && echo -e "    ${GRAY}â° Removed $old_entries old entries (>${AI_CACHE_MAX_AGE_DAYS} days)${NC}" >&2
        [[ $deleted_files -gt 0 ]] && echo -e "    ${YELLOW}ðŸ—‘ï¸  Removed $deleted_files entries (files deleted)${NC}" >&2
        [[ $duplicate_entries -gt 0 ]] && echo -e "    ${GREEN}âœ”ï¸ Removed $duplicate_entries duplicate entries${NC}" >&2
        
        # Show size reduction
        local new_count=$(tail -n +4 "$AI_CACHE_INDEX" 2>/dev/null | wc -l)
        local cache_size=$(du -h "$AI_CACHE_INDEX" 2>/dev/null | cut -f1 || echo "0")
        echo -e "    ${CYAN}ðŸ“Š Cache size: ${cache_size}B, ${new_count} entries${NC}" >&2
    fi
    
    # Clean up old backup files
    find "$AI_CACHE_DIR" -name "analysis_cache.db.backup.*" -mtime +7 -delete 2>/dev/null || true
}

# Get file fingerprint for change detection (FAST - uses size + mtime, not MD5!)
get_file_fingerprint() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        echo "MISSING"
        return 1
    fi
    
    # Use file size and modification time for FAST change detection
    # MD5 is stored in cache data, no need to recalculate here!
    local filesize=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
    local filemtime=$(stat -c%Y -- "$file" 2>/dev/null || echo "0")
    
    echo "${filesize}:${filemtime}"
}

# Check if file analysis is cached and valid (with corruption protection)
check_ai_cache() {
    local file="$1"
    
    if [[ "$AI_CACHE_ENABLED" != "true" ]]; then
        return 1
    fi
    
    # Validate cache integrity first
    if ! validate_cache_index; then
        echo -e "${YELLOW}ðŸ”„ Cache corrupted during read, rebuilding...${NC}" >&2
        rebuild_cache_index
        return 1
    fi
    
    local current_fingerprint=$(get_file_fingerprint "$file")
    [[ "$current_fingerprint" == "MISSING" || "$current_fingerprint" == "ERROR:0" ]] && return 1
    
    # Search for cached entry with error handling
    local cached_line
    if ! cached_line=$(grep -F "$(basename -- "$file")|" "$AI_CACHE_INDEX" 2>/dev/null | tail -n 1); then
        return 1
    fi
    
    if [[ -n "$cached_line" ]]; then
        # Validate cached line format
        local field_count=$(echo "$cached_line" | tr -cd '|' | wc -c)
        if [[ $field_count -lt 4 ]]; then
            # Corrupted cache entry, ignore
            return 1
        fi
        
        local cached_fingerprint=$(echo "$cached_line" | cut -d'|' -f2-3 | tr '|' ':')
        
        if [[ "$cached_fingerprint" == "$current_fingerprint" ]]; then
            # Cache hit - return cached analysis
            local analysis_data=$(echo "$cached_line" | cut -d'|' -f5-)
            # Validate analysis data is not empty
            [[ -n "$analysis_data" ]] && echo "$analysis_data" && return 0
        fi
    fi
    
    return 1
}

# Save analysis results to cache (atomic operation)
save_to_ai_cache() {
    local file="$1"
    local analysis_data="$2"
    
    if [[ "$AI_CACHE_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Validate cache before write
    if ! validate_cache_index; then
        echo -e "${YELLOW}ðŸ”„ Cache corrupted during write, rebuilding...${NC}" >&2
        rebuild_cache_index
    fi
    
    local fingerprint=$(get_file_fingerprint "$file")
    [[ "$fingerprint" == "MISSING" ]] && return 1
    
    local filesize=$(echo "$fingerprint" | cut -d':' -f1)
    local filemtime=$(echo "$fingerprint" | cut -d':' -f2)
    local timestamp=$(date +%s)
    local filename=$(basename -- "$file")
    
    # Validate data before saving
    if [[ -z "$analysis_data" || ${#analysis_data} -gt 10000 ]]; then
        echo -e "${YELLOW}âš ï¸  Invalid analysis data, skipping cache save${NC}" >&2
        return 1
    fi
    
    # Atomic write operation using temporary file
    local temp_entry="$(mktemp)"
    local cache_entry="$filename|$filesize|$filemtime|$timestamp|$analysis_data"
    
    # Write to temp file first
    if echo "$cache_entry" > "$temp_entry" 2>/dev/null; then
        # Atomic append from temp file
        if cat "$temp_entry" >> "$AI_CACHE_INDEX" 2>/dev/null; then
            rm -f "$temp_entry"
            return 0
        fi
    fi
    
    # Cleanup on failure
    rm -f "$temp_entry" 2>/dev/null || true
    return 1
}

# Get cache statistics
get_cache_stats() {
    if [[ "$AI_CACHE_ENABLED" != "true" || ! -f "$AI_CACHE_INDEX" ]]; then
        echo "Cache disabled"
        return
    fi
    
    local total_entries=$(grep -v '^#' "$AI_CACHE_INDEX" | grep -c '|' || echo "0")
    local cache_size=$(du -h "$AI_CACHE_DIR" 2>/dev/null | cut -f1 || echo "0")
    
    echo "$total_entries entries, ${cache_size}B"
}

# ðŸš€ REVOLUTIONARY: Ultra-Fast Hash Detection System
# =================================================================
# Detects and uses the fastest available hash algorithm:
# 1. xxhash (10-20x faster than MD5)
# 2. blake3 (5-10x faster than MD5)  
# 3. md5sum (fallback)
# Combined with TRUE parallelization for maximum speed!

# Detect best available hash algorithm
detect_hash_algorithm() {
    # Check for xxhash (fastest)
    if command -v xxh128sum >/dev/null 2>&1; then
        echo "xxh128sum"
        return 0
    elif command -v xxh64sum >/dev/null 2>&1; then
        echo "xxh64sum"
        return 0
    elif command -v xxhsum >/dev/null 2>&1; then
        echo "xxhsum"
        return 0
    # Check for blake3 (very fast)
    elif command -v b3sum >/dev/null 2>&1; then
        echo "b3sum"
        return 0
    # Fallback to md5sum
    else
        echo "md5sum"
        return 0
    fi
}

# Calculate hash with auto-detection of best algorithm
fast_hash() {
    local file="$1"
    local hash_cmd="${HASH_ALGORITHM:-md5sum}"
    
    # Calculate hash and extract just the hash value
    local result=$("$hash_cmd" "$file" 2>/dev/null | awk '{print $1}')
    echo "$result"
}

# ðŸ”¥ PARALLEL hash calculation (uses all CPU cores!)
parallel_hash_batch() {
    local -n files_array=$1  # Array of files to hash
    local output_file="$2"    # Where to write results
    
    local hash_cmd="${HASH_ALGORITHM:-md5sum}"
    local max_jobs="${AI_DUPLICATE_THREADS:-4}"
    
    # Use GNU parallel if available (best performance)
    if command -v parallel >/dev/null 2>&1; then
        printf '%s\0' "${files_array[@]}" | \
            parallel -0 -j "$max_jobs" --will-cite \
            "$hash_cmd {} 2>/dev/null | awk '{print \$1,\"{}\"}' || echo ERROR {}" \
            >> "$output_file" 2>/dev/null
    # Fallback: xargs with parallelization (fixed escaping)
    elif command -v xargs >/dev/null 2>&1; then
        printf '%s\0' "${files_array[@]}" | \
            xargs -0 -n 1 -P "$max_jobs" -I '{}' \
            sh -c '$hash_cmd "{}" 2>/dev/null | awk '"'"'{print $1,"{}"}'"'"' || echo ERROR "{}"' \
            >> "$output_file" 2>/dev/null
    # Native bash parallel implementation (no external tools needed!)
    else
        echo "  ${YELLOW}âš ï¸  Using native bash parallel hashing (xargs not found)${NC}" >&2
        
        # Split files into batches
        local batch_size=$(( (${#files_array[@]} + max_jobs - 1) / max_jobs ))
        [[ $batch_size -lt 1 ]] && batch_size=1
        
        local pids=()
        local temp_files=()
        local batch_idx=0
        
        for ((i=0; i<${#files_array[@]}; i+=batch_size)); do
            local temp_batch="${output_file}.batch${batch_idx}"
            temp_files+=("$temp_batch")
            
            # Process batch in background
            (
                for ((j=i; j<i+batch_size && j<${#files_array[@]}; j++)); do
                    local file="${files_array[$j]}"
                    if [[ -f "$file" && -r "$file" ]]; then
                        local hash=$(fast_hash "$file" 2>/dev/null || echo "ERROR")
                        echo "$hash $file"
                    else
                        echo "ERROR $file"
                    fi
                done > "$temp_batch"
            ) &
            pids+=("$!")
            ((batch_idx++))
            
            # Limit concurrent batches
            if [[ ${#pids[@]} -ge $max_jobs ]]; then
                wait "${pids[0]}" 2>/dev/null
                pids=("${pids[@]:1}")
            fi
        done
        
        # Wait for all background jobs
        for pid in "${pids[@]}"; do
            wait "$pid" 2>/dev/null
        done
        
        # Merge all batch files
        for temp_file in "${temp_files[@]}"; do
            [[ -f "$temp_file" ]] && cat "$temp_file" >> "$output_file" 2>/dev/null
            rm -f "$temp_file" 2>/dev/null
        done
    fi
}

# Initialize hash system
init_hash_system() {
    HASH_ALGORITHM=$(detect_hash_algorithm)
    local algo_name="${HASH_ALGORITHM%sum}"
    
    # Display what we're using
    case "$HASH_ALGORITHM" in
        xxh*)
            HASH_SPEED="20-30x faster than MD5"
            ;;
        b3sum)
            HASH_SPEED="10-15x faster than MD5"
            ;;
        md5sum)
            HASH_SPEED="baseline (consider installing xxhash!)"
            ;;
    esac
    
    export HASH_ALGORITHM
    export HASH_SPEED
}

# ðŸ” Checksum Cache System for Duplicate Detection
# =================================================================
# Dramatically speeds up duplicate detection by caching checksums
# Only recalculates if file mtime has changed

# Initialize checksum cache
init_checksum_cache() {
    if [[ "$CHECKSUM_CACHE_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Create cache directory
    mkdir -p "$CHECKSUM_CACHE_DIR" 2>/dev/null || {
        echo -e "${YELLOW}âš ï¸  Warning: Cannot create checksum cache directory, disabling cache${NC}" >&2
        CHECKSUM_CACHE_ENABLED=false
        return 1
    }
    
    # Create cache DB if it doesn't exist OR if hash algorithm changed
    local cache_needs_rebuild=false
    if [[ ! -f "$CHECKSUM_CACHE_DB" ]]; then
        cache_needs_rebuild=true
    else
        # Check if cache uses the same hash algorithm
        local cache_header=$(head -n 2 "$CHECKSUM_CACHE_DB" 2>/dev/null | grep 'Format:')
        if [[ ! "$cache_header" =~ "hash_algo=${HASH_ALGORITHM}" ]]; then
            echo -e "  ${YELLOW}ðŸ”„ Hash algorithm changed (${HASH_ALGORITHM}), rebuilding cache...${NC}" >&2
            cache_needs_rebuild=true
        fi
    fi
    
    if [[ "$cache_needs_rebuild" == "true" ]]; then
        cat > "$CHECKSUM_CACHE_DB" << EOF
# Checksum Cache Database - Version $CHECKSUM_CACHE_VERSION
# Format: filepath|filesize|filemtime|checksum|timestamp (hash_algo=${HASH_ALGORITHM})
# Created: $(date)
EOF
    fi
    
    # Smart cleanup: only run every 14 days
    local cleanup_marker="${CHECKSUM_CACHE_DIR}/.last_cleanup"
    local current_time=$(date +%s)
    local cleanup_interval=$((14 * 86400))  # 14 days
    
    if [[ ! -f "$cleanup_marker" ]]; then
        ( cleanup_checksum_cache && echo "$current_time" > "$cleanup_marker" ) &
    else
        local last_cleanup=$(cat "$cleanup_marker" 2>/dev/null || echo "0")
        local time_since=$((current_time - last_cleanup))
        if [[ $time_since -gt $cleanup_interval ]]; then
            ( cleanup_checksum_cache && echo "$current_time" > "$cleanup_marker" ) &
        fi
    fi
}

# Get cached checksum or calculate new one
get_cached_checksum() {
    local filepath="$1"
    
    if [[ ! -f "$filepath" ]]; then
        echo ""
        return 1
    fi
    
    local filesize=$(stat -c%s -- "$filepath" 2>/dev/null || echo "0")
    local filemtime=$(stat -c%Y -- "$filepath" 2>/dev/null || echo "0")
    
    # Check cache if enabled
    if [[ "$CHECKSUM_CACHE_ENABLED" == "true" && -f "$CHECKSUM_CACHE_DB" ]]; then
        # Search for cached entry
        local cached_line=$(grep -F "$filepath|" "$CHECKSUM_CACHE_DB" 2>/dev/null | tail -n 1)
        
        if [[ -n "$cached_line" ]]; then
            local cached_size=$(echo "$cached_line" | cut -d'|' -f2)
            local cached_mtime=$(echo "$cached_line" | cut -d'|' -f3)
            local cached_checksum=$(echo "$cached_line" | cut -d'|' -f4)
            
            # Validate cache entry (size and mtime must match)
            if [[ "$cached_size" == "$filesize" && "$cached_mtime" == "$filemtime" ]]; then
                # Cache hit!
                ((DUPLICATE_STATS_CACHE_HITS++))
                echo "$cached_checksum"
                return 0
            fi
        fi
    fi
    
    # Cache miss - calculate checksum with fast hash
    ((DUPLICATE_STATS_CACHE_MISSES++))
    local checksum=$(fast_hash "$filepath" || echo "")
    
    if [[ -n "$checksum" && "$CHECKSUM_CACHE_ENABLED" == "true" ]]; then
        # Save to cache (atomic operation)
        local timestamp=$(date +%s)
        local cache_entry="$filepath|$filesize|$filemtime|$checksum|$timestamp"
        echo "$cache_entry" >> "$CHECKSUM_CACHE_DB" 2>/dev/null || true
    fi
    
    echo "$checksum"
    return 0
}

# Clean up old checksum cache entries
cleanup_checksum_cache() {
    if [[ "$CHECKSUM_CACHE_ENABLED" != "true" || ! -f "$CHECKSUM_CACHE_DB" ]]; then
        return 0
    fi
    
    local cutoff_time=$(($(date +%s) - (CHECKSUM_CACHE_MAX_AGE_DAYS * 86400)))
    local temp_db="$(mktemp)"
    
    # Keep header
    head -n 3 "$CHECKSUM_CACHE_DB" > "$temp_db"
    
    declare -A latest_checksums
    declare -A latest_timestamps
    
    local old_entries=0
    local deleted_files=0
    local duplicate_entries=0
    
    # Deduplicate and clean
    while IFS='|' read -r filepath filesize filemtime checksum timestamp; do
        [[ "$filepath" =~ ^# || -z "$filepath" ]] && continue
        
        # Skip old entries
        if [[ $timestamp -lt $cutoff_time ]]; then
            ((old_entries++))
            continue
        fi
        
        # Check if file exists
        if [[ ! -f "$filepath" ]]; then
            ((deleted_files++))
            continue
        fi
        
        # Keep only latest entry per file
        local existing_ts="${latest_timestamps[$filepath]:-0}"
        if [[ $timestamp -gt $existing_ts ]]; then
            [[ $existing_ts -gt 0 ]] && ((duplicate_entries++))
            latest_timestamps[$filepath]=$timestamp
            latest_checksums[$filepath]="$filepath|$filesize|$filemtime|$checksum|$timestamp"
        else
            ((duplicate_entries++))
        fi
    done < <(tail -n +4 "$CHECKSUM_CACHE_DB")
    
    # Write deduplicated entries
    for filepath in "${!latest_checksums[@]}"; do
        echo "${latest_checksums[$filepath]}" >> "$temp_db"
    done
    
    # Atomic replace
    mv "$temp_db" "$CHECKSUM_CACHE_DB"
    
    # Report if significant cleanup
    local total_cleaned=$((old_entries + deleted_files + duplicate_entries))
    if [[ $total_cleaned -gt 50 ]]; then
        echo -e "  ${BLUE}ðŸ§¹ Checksum cache cleaned: removed $total_cleaned entries${NC}" >&2
    fi
}

# Get checksum cache statistics
get_checksum_cache_stats() {
    if [[ "$CHECKSUM_CACHE_ENABLED" != "true" || ! -f "$CHECKSUM_CACHE_DB" ]]; then
        echo "disabled"
        return
    fi
    
    local total=$(grep -v '^#' "$CHECKSUM_CACHE_DB" | grep -c '|' || echo "0")
    local hits=$DUPLICATE_STATS_CACHE_HITS
    local misses=$DUPLICATE_STATS_CACHE_MISSES
    local total_lookups=$((hits + misses))
    
    if [[ $total_lookups -gt 0 ]]; then
        local hit_rate=$((hits * 100 / total_lookups))
        echo "$total entries, $hit_rate% hit rate"
    else
        echo "$total entries"
    fi
}

# ðŸ’¡ Smart Comparison Cache System (Multi-Layer)
# ================================================================
# Layer 1: In-memory hash table (current session)
# Layer 2: Persistent pair cache with metadata
# Layer 3: Auto-validation and repair
# Layer 4: Health monitoring and statistics
# ================================================================

# Initialize comparison cache (video or GIF)
init_comparison_cache() {
    local cache_type="$1"  # "video" or "gif"
    local cache_file="$HOME/.smart-gif-converter/${cache_type}_comparison_cache.db"
    
    mkdir -p "$(dirname "$cache_file")" 2>/dev/null || return 1
    
    # Check if cache needs initialization or rebuild
    if [[ ! -f "$cache_file" ]] || ! validate_comparison_cache "$cache_file"; then
        rebuild_comparison_cache "$cache_file" "$cache_type"
    fi
    
    echo "$cache_file"
}

# Validate comparison cache integrity
validate_comparison_cache() {
    local cache_file="$1"
    
    [[ -f "$cache_file" && -r "$cache_file" ]] || return 1
    
    # Check header
    local header=$(head -n 1 "$cache_file" 2>/dev/null || echo "")
    [[ "$header" =~ ^#.*Comparison.*Cache ]] || return 1
    
    # Check version
    local version_line=$(head -n 2 "$cache_file" 2>/dev/null | tail -n 1)
    [[ "$version_line" =~ ^#.*Version ]] || return 1
    
    # Validate structure (sample check)
    local data_line=$(grep -v '^#' "$cache_file" 2>/dev/null | head -n 1)
    if [[ -n "$data_line" ]]; then
        # Format: pair_hash|checksum1|checksum2|result|timestamp|duration_ms
        local fields=$(echo "$data_line" | tr -cd '|' | wc -c)
        [[ $fields -eq 5 ]] || return 1
    fi
    
    return 0
}

# Rebuild corrupted comparison cache
rebuild_comparison_cache() {
    local cache_file="$1"
    local cache_type="$2"
    
    local backup="${cache_file}.backup.$(date +%s)"
    [[ -f "$cache_file" ]] && cp "$cache_file" "$backup" 2>/dev/null
    
    # Create fresh cache with structured header
    cat > "$cache_file" << EOF
# Smart ${cache_type^} Comparison Cache - Multi-Layer System
# Version: 2.0
# Format: pair_hash|checksum1|checksum2|result|timestamp|duration_ms
# Result: DUPLICATE (Level1/2/3) or NOT_DUPLICATE
# Created: $(date '+%Y-%m-%d %H:%M:%S')
# Hash Algorithm: ${HASH_ALGORITHM}
EOF
    
    # Try to recover valid entries from backup
    if [[ -f "$backup" ]]; then
        local recovered=0
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            local fields=$(echo "$line" | tr -cd '|' | wc -c)
            if [[ $fields -eq 5 ]]; then
                echo "$line" >> "$cache_file"
                ((recovered++))
            fi
        done < "$backup" 2>/dev/null || true
        
        [[ $recovered -gt 0 ]] && echo -e "${GREEN}âœ… Recovered $recovered comparison entries${NC}" >&2
    fi
}

# Load comparison cache into memory (Layer 1 + Layer 2)
load_comparison_cache() {
    local cache_file="$1"
    local -n cache_array=$2  # Pass associative array by reference
    
    local loaded=0
    local skipped=0
    local current_time=$(date +%s)
    local max_age=$((180 * 86400))  # 180 days
    
    if [[ -f "$cache_file" ]]; then
        while IFS='|' read -r pair_hash checksum1 checksum2 result timestamp duration_ms; do
            [[ -z "$pair_hash" || "$pair_hash" =~ ^# ]] && continue
            
            # Skip very old entries (automatic aging)
            local age=$((current_time - timestamp))
            if [[ $age -gt $max_age ]]; then
                ((skipped++))
                continue
            fi
            
            # Store in memory with metadata
            cache_array["$pair_hash"]="$result|$timestamp|$duration_ms"
            ((loaded++))
        done < "$cache_file"
    fi
    
    echo "$loaded" # Return count
}

# Save comparison result to cache (Layer 2 - persistent)
save_comparison_to_cache() {
    local cache_file="$1"
    local pair_hash="$2"
    local checksum1="$3"
    local checksum2="$4"
    local result="$5"
    local duration_ms="${6:-0}"
    
    local timestamp=$(date +%s)
    local cache_entry="$pair_hash|$checksum1|$checksum2|$result|$timestamp|$duration_ms"
    
    # Atomic append
    echo "$cache_entry" >> "$cache_file" 2>/dev/null || true
}

# Cleanup and optimize comparison cache (Layer 4 - maintenance)
cleanup_comparison_cache() {
    local cache_file="$1"
    local cache_type="$2"
    
    [[ ! -f "$cache_file" ]] && return 0
    
    local current_time=$(date +%s)
    local max_age=$((180 * 86400))  # 180 days
    local cutoff_time=$((current_time - max_age))
    
    local temp_cache="$(mktemp)"
    
    # Keep header
    head -n 6 "$cache_file" > "$temp_cache"
    
    declare -A latest_results
    declare -A latest_timestamps
    
    local old_entries=0
    local duplicate_entries=0
    local total_entries=0
    
    # Deduplicate and remove old entries
    while IFS='|' read -r pair_hash checksum1 checksum2 result timestamp duration_ms; do
        [[ "$pair_hash" =~ ^# || -z "$pair_hash" ]] && continue
        ((total_entries++))
        
        # Skip old entries
        if [[ $timestamp -lt $cutoff_time ]]; then
            ((old_entries++))
            continue
        fi
        
        # Keep only latest entry per pair
        local existing_ts="${latest_timestamps[$pair_hash]:-0}"
        if [[ $timestamp -gt $existing_ts ]]; then
            [[ $existing_ts -gt 0 ]] && ((duplicate_entries++))
            latest_timestamps[$pair_hash]=$timestamp
            latest_results[$pair_hash]="$pair_hash|$checksum1|$checksum2|$result|$timestamp|$duration_ms"
        else
            ((duplicate_entries++))
        fi
    done < <(tail -n +7 "$cache_file")
    
    # Write deduplicated entries
    for pair_hash in "${!latest_results[@]}"; do
        echo "${latest_results[$pair_hash]}" >> "$temp_cache"
    done
    
    # Atomic replace
    mv "$temp_cache" "$cache_file"
    
    local cleaned=$((old_entries + duplicate_entries))
    local kept=${#latest_results[@]}
    
    echo -e "  ${BLUE}ðŸ§º ${cache_type^} cache optimized: removed $cleaned entries, kept $kept${NC}" >&2
}

# Get comparison cache statistics (Layer 4 - monitoring)
get_comparison_cache_stats() {
    local cache_file="$1"
    local cache_type="$2"
    
    if [[ ! -f "$cache_file" ]]; then
        echo "${cache_type^}: 0 comparisons cached"
        return
    fi
    
    local total=$(grep -v '^#' "$cache_file" | grep -c '|' || echo "0")
    local duplicates=$(grep -v '^#' "$cache_file" | grep -c 'DUPLICATE' || echo "0")
    local not_duplicates=$((total - duplicates))
    
    # Calculate cache age
    local creation_date=$(grep '^# Created:' "$cache_file" | sed 's/^# Created: //')
    local cache_age="unknown"
    if [[ -n "$creation_date" ]]; then
        local created_ts=$(date -d "$creation_date" +%s 2>/dev/null || echo "0")
        if [[ $created_ts -gt 0 ]]; then
            local current_ts=$(date +%s)
            local age_days=$(( (current_ts - created_ts) / 86400 ))
            cache_age="${age_days}d"
        fi
    fi
    
    # Calculate average comparison time
    local avg_time="N/A"
    local total_time=0
    local count_with_time=0
    while IFS='|' read -r pair_hash checksum1 checksum2 result timestamp duration_ms; do
        [[ "$pair_hash" =~ ^# || -z "$duration_ms" || "$duration_ms" == "0" ]] && continue
        total_time=$((total_time + duration_ms))
        ((count_with_time++))
    done < <(tail -n +7 "$cache_file")
    
    if [[ $count_with_time -gt 0 ]]; then
        avg_time="$((total_time / count_with_time))ms"
    fi
    
    echo "${cache_type^}: $total cached ($duplicates dups, $not_duplicates unique) Age: $cache_age, Avg: $avg_time"
}

# Validate cache health and repair if needed (Layer 3 - auto-repair)
validate_and_repair_comparison_cache() {
    local cache_file="$1"
    local cache_type="$2"
    
    if [[ ! -f "$cache_file" ]]; then
        return 0  # No cache to validate
    fi
    
    local issues=0
    
    # Check 1: File readable
    if [[ ! -r "$cache_file" ]]; then
        echo -e "  ${RED}âš  ${cache_type^} cache not readable${NC}" >&2
        ((issues++))
    fi
    
    # Check 2: Valid header
    if ! validate_comparison_cache "$cache_file"; then
        echo -e "  ${YELLOW}ðŸ”§ ${cache_type^} cache header corrupted, rebuilding...${NC}" >&2
        rebuild_comparison_cache "$cache_file" "$cache_type"
        ((issues++))
    fi
    
    # Check 3: Size check (if > 100MB, cleanup recommended)
    local cache_size=$(stat -c%s "$cache_file" 2>/dev/null || echo "0")
    if [[ $cache_size -gt 104857600 ]]; then  # 100MB
        local size_mb=$((cache_size / 1048576))
        echo -e "  ${YELLOW}ðŸ’¾ ${cache_type^} cache is ${size_mb}MB - cleanup recommended${NC}" >&2
        cleanup_comparison_cache "$cache_file" "$cache_type"
    fi
    
    # Check 4: Corruption check (sample validation)
    local corrupted_lines=0
    local sample_size=100
    local sample_lines=$(tail -n $sample_size "$cache_file" 2>/dev/null | grep -v '^#')
    
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local fields=$(echo "$line" | tr -cd '|' | wc -c)
        [[ $fields -ne 5 ]] && ((corrupted_lines++))
    done <<< "$sample_lines"
    
    if [[ $corrupted_lines -gt 10 ]]; then  # More than 10% corruption in sample
        echo -e "  ${RED}ðŸ› ${cache_type^} cache corruption detected ($corrupted_lines/$sample_size lines), repairing...${NC}" >&2
        rebuild_comparison_cache "$cache_file" "$cache_type"
        ((issues++))
    fi
    
    [[ $issues -eq 0 ]] && return 0 || return 1
}

# ðŸŽ¬ Video Cache System
# =======================================

# Initialize video analysis cache
init_video_cache() {
    local video_cache_dir="${GIF_CONVERTER_DIR}/video_cache"
    local video_cache_index="$video_cache_dir/video_analysis.db"
    
    # Create video cache directory (silently fail if not possible)
    mkdir -p "$video_cache_dir" 2>/dev/null || return 1
    
    # Check if cache exists and has correct hash algorithm
    local cache_needs_rebuild=false
    if [[ ! -f "$video_cache_index" ]]; then
        cache_needs_rebuild=true
    else
        # Check if cache header mentions hash algorithm
        local cache_header=$(head -n 3 "$video_cache_index" 2>/dev/null | grep -E 'Format:|hash_algo')
        if [[ -n "$cache_header" && ! "$cache_header" =~ "hash_algo=${HASH_ALGORITHM}" ]]; then
            echo -e "${YELLOW}ðŸ”„ Video cache hash algorithm changed (${HASH_ALGORITHM}), rebuilding...${NC}" >&2
            cache_needs_rebuild=true
        elif [[ -z "$cache_header" ]]; then
            # Old cache without hash algorithm marker - rebuild
            echo -e "${YELLOW}ðŸ”„ Video cache missing hash algorithm marker, rebuilding...${NC}" >&2
            cache_needs_rebuild=true
        fi
    fi
    
    if [[ "$cache_needs_rebuild" == "true" ]]; then
        cat > "$video_cache_index" << EOF
# Smart GIF Converter - Video Analysis Cache
# Format: filename|filesize|filemtime|timestamp|analysis_data (hash_algo=${HASH_ALGORITHM})
# analysis_data: checksum|size|fingerprint|perceptual_hash|duration|resolution
EOF
    fi
    
    # Validate cache integrity
    if ! validate_video_cache_index "$video_cache_index"; then
        echo -e "${YELLOW}ðŸ”„ Video cache corruption detected, rebuilding...${NC}" >&2
        rebuild_video_cache_index "$video_cache_index"
    fi
}

# Validate video cache index integrity
validate_video_cache_index() {
    local cache_index="$1"
    
    [[ -f "$cache_index" && -r "$cache_index" ]] || return 1
    
    # Check header
    local header=$(head -n 1 "$cache_index" 2>/dev/null || echo "")
    [[ "$header" =~ ^#.*Video.*Analysis.*Cache ]] || return 1
    
    # Basic structure validation
    head -n 10 "$cache_index" >/dev/null 2>&1 || return 1
    
    return 0
}

# Rebuild video cache index
rebuild_video_cache_index() {
    local cache_index="$1"
    local temp_index="${cache_index}.rebuilding"
    
    # Create new header
    cat > "$temp_index" << 'EOF'
# Smart GIF Converter - Video Analysis Cache
# Format: filename|filesize|filemtime|timestamp|analysis_data
# analysis_data: checksum|size|fingerprint|perceptual_hash|duration|resolution
EOF
    
    # Try to recover valid entries from old cache
    if [[ -f "$cache_index" ]]; then
        while IFS='|' read -r filename filesize filemtime timestamp analysis_data; do
            [[ "$filename" =~ ^# ]] && continue
            [[ -z "$filename" ]] && continue
            
            # Validate entry format
            if [[ -n "$filename" && -n "$filesize" && -n "$filemtime" && -n "$timestamp" && -n "$analysis_data" ]]; then
                echo "$filename|$filesize|$filemtime|$timestamp|$analysis_data" >> "$temp_index"
            fi
        done < "$cache_index" 2>/dev/null
    fi
    
    # Atomic replace
    mv "$temp_index" "$cache_index"
}

# Check video cache for existing analysis
check_video_cache() {
    local video_file="$1"
    local video_cache_dir="${GIF_CONVERTER_DIR}/video_cache"
    local video_cache_index="$video_cache_dir/video_analysis.db"
    
    [[ -f "$video_cache_index" ]] || return 1
    
    local basename=$(basename -- "$video_file")
    local current_filesize=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
    local current_filemtime=$(stat -c%Y -- "$video_file" 2>/dev/null || echo "0")
    
    # Search for matching entry
    while IFS='|' read -r filename filesize filemtime timestamp analysis_data; do
        [[ "$filename" == "$basename" ]] || continue
        
        # Check if file unchanged
        if [[ "$filesize" == "$current_filesize" && "$filemtime" == "$current_filemtime" ]]; then
            echo "$analysis_data"
            return 0
        fi
    done < <(grep -v '^#' "$video_cache_index" 2>/dev/null)
    
    return 1
}

# Save video analysis to cache
save_video_analysis_to_cache() {
    local video_file="$1"
    local analysis_result="$2"
    local video_cache_dir="${GIF_CONVERTER_DIR}/video_cache"
    local video_cache_index="$video_cache_dir/video_analysis.db"
    
    [[ -f "$video_cache_index" ]] || return 1
    
    local basename=$(basename -- "$video_file")
    local filesize=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
    local filemtime=$(stat -c%Y -- "$video_file" 2>/dev/null || echo "0")
    local timestamp=$(date +%s)
    
    # Atomic append
    local temp_cache="${video_cache_index}.tmp.$$"
    cp "$video_cache_index" "$temp_cache" 2>/dev/null
    echo "$basename|$filesize|$filemtime|$timestamp|$analysis_result" >> "$temp_cache"
    mv "$temp_cache" "$video_cache_index"
}

# Get video cache statistics
get_video_cache_stats() {
    local video_cache_dir="${GIF_CONVERTER_DIR}/video_cache"
    local video_cache_index="$video_cache_dir/video_analysis.db"
    
    if [[ ! -f "$video_cache_index" ]]; then
        echo "0 entries"
        return
    fi
    
    local total=$(grep -v '^#' "$video_cache_index" | grep -c '|' || echo "0")
    echo "$total entries"
}

# Save AI analysis results to cache
save_ai_analysis_to_cache() {
    local file="$1"
    
    if [[ "$AI_CACHE_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Prepare AI analysis data for caching
    local ai_data="FRAMERATE=$FRAMERATE|DITHER_MODE=$DITHER_MODE|MAX_COLORS=$MAX_COLORS"
    ai_data="$ai_data|CROP_FILTER=${CROP_FILTER:-none}|AI_CONTENT_CACHE=${AI_CONTENT_CACHE:-none}"
    
    save_to_ai_cache "$file" "AI_ANALYSIS:$ai_data"
}

# Restore AI analysis variables from cache
restore_ai_analysis_from_cache() {
    local cached_data="$1"
    
    # Check if this is AI analysis data
    if [[ "$cached_data" =~ ^AI_ANALYSIS: ]]; then
        # Remove prefix and parse variables
        local ai_vars="${cached_data#AI_ANALYSIS:}"
        
        # Parse each variable
        IFS='|' read -ra VAR_ARRAY <<< "$ai_vars"
        for var_assignment in "${VAR_ARRAY[@]}"; do
            case "$var_assignment" in
                FRAMERATE=*) FRAMERATE="${var_assignment#*=}" ;;
                DITHER_MODE=*) DITHER_MODE="${var_assignment#*=}" ;;
                MAX_COLORS=*) MAX_COLORS="${var_assignment#*=}" ;;
                CROP_FILTER=*) 
                    local crop_val="${var_assignment#*=}"
                    [[ "$crop_val" != "none" ]] && CROP_FILTER="$crop_val" || CROP_FILTER=""
                    ;;
                AI_CONTENT_CACHE=*) 
                    local cache_val="${var_assignment#*=}"
                    [[ "$cache_val" != "none" ]] && AI_CONTENT_CACHE="$cache_val" || AI_CONTENT_CACHE=""
                    ;;
            esac
        done
        return 0
    fi
    
    return 1
}

# ðŸ§  AI Training & Learning System
# =======================================

# Initialize AI training system (corruption-proof)
init_ai_training() {
    if [[ "$AI_TRAINING_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Create training directory structure
    mkdir -p "$AI_TRAINING_DIR" 2>/dev/null || {
        echo -e "${YELLOW}âš ï¸  Warning: Cannot create AI training directory, disabling training${NC}" >&2
        AI_TRAINING_ENABLED=false
        return 1
    }
    
    # Validate or rebuild model file
    if ! validate_ai_model; then
        echo -e "${YELLOW}ðŸ”„ AI model corruption detected, rebuilding...${NC}" >&2
        rebuild_ai_model
    fi
    
    # Validate or rebuild training log
    if ! validate_training_log; then
        echo -e "${YELLOW}ðŸ”„ Training log corruption detected, rebuilding...${NC}" >&2
        rebuild_training_log
    fi
    
    # Create backups
    create_training_backups
    
    # Clean up old training data if version changed
    local current_version=$(head -n 1 "$AI_MODEL_FILE" 2>/dev/null | grep -o 'Version [0-9.]*' | cut -d' ' -f2 2>/dev/null || echo "")
    if [[ "$current_version" != "$AI_MODEL_VERSION" ]]; then
        echo -e "${BLUE}ðŸ”„ AI Model version updated, reinitializing training data${NC}" >&2
        rebuild_ai_model
        rebuild_training_log
    fi
}

# Validate AI model file integrity
validate_ai_model() {
    # Check if model file exists and is readable
    [[ -f "$AI_MODEL_FILE" && -r "$AI_MODEL_FILE" ]] || return 1
    
    # Check proper header
    local header=$(head -n 1 "$AI_MODEL_FILE" 2>/dev/null || echo "")
    [[ "$header" =~ ^#.*AI.*Model.*Version ]] || return 1
    
    # Try to load AI generation from model file if available
    local model_generation=$(head -n 5 "$AI_MODEL_FILE" 2>/dev/null | grep "^# AI Generation:" | sed 's/^# AI Generation: //' | head -n 1)
    if [[ -n "$model_generation" && "$model_generation" =~ ^[0-9]+$ ]]; then
        AI_GENERATION="$model_generation"
    fi
    
    # Validate structure (check for major corruption)
    local corrupted=0
    local data_lines=0
    while IFS= read -r line; do
        # Skip header lines (first 4-6 lines starting with #)
        [[ "$line" =~ ^# ]] && continue
        # Skip empty lines
        [[ -z "$line" ]] && continue
        
        ((data_lines++))
        
        # Check format: feature_pattern|settings|confidence|samples|timestamp
        local fields=$(echo "$line" | tr -cd '|' | wc -c)
        [[ $fields -eq 4 ]] || ((corrupted++))
    done < "$AI_MODEL_FILE" 2>/dev/null || return 1
    
    # Only fail if we have substantial corruption:
    # - If we have 10+ data lines and >50% are corrupted, OR
    # - If we have >20 corrupted entries
    if [[ $data_lines -ge 10 ]] && [[ $((corrupted * 2)) -gt $data_lines ]]; then
        return 1
    elif [[ $corrupted -gt 20 ]]; then
        return 1
    fi
    
    # Model is valid (or has too few entries to judge)
    return 0
}

# Validate training log integrity
validate_training_log() {
    # Check if log exists and is readable
    [[ -f "$AI_TRAINING_LOG" && -r "$AI_TRAINING_LOG" ]] || return 1
    
    # Check proper header
    local header=$(head -n 1 "$AI_TRAINING_LOG" 2>/dev/null || echo "")
    [[ "$header" =~ ^#.*Training.*History ]] || return 1
    
    # Basic structure validation (at least readable)
    head -n 10 "$AI_TRAINING_LOG" >/dev/null 2>&1 || return 1
    
    return 0
}

# Rebuild corrupted AI model
rebuild_ai_model() {
    local backup="${AI_MODEL_FILE}.backup.$(date +%s)"
    [[ -f "$AI_MODEL_FILE" ]] && cp "$AI_MODEL_FILE" "$backup" 2>/dev/null
    
    # Increment AI generation on rebuild
    AI_GENERATION=$((AI_GENERATION + 1))
    
    # Save updated generation to settings
    save_settings --silent 2>/dev/null || true
    
    # Create fresh model file
    cat > "$AI_MODEL_FILE" << EOF
# AI Smart Model Database - Version $AI_MODEL_VERSION (Rebuilt)
# AI Generation: $AI_GENERATION
# Format: feature_pattern|optimal_settings|confidence|sample_count|last_updated
# Features: content_type:resolution:duration:motion_level:complexity
# Settings: framerate:dither:colors:crop
# Rebuilt: $(date)
EOF
    
    # Try to recover valid entries
    if [[ -f "$backup" ]]; then
        local recovered=0
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            local fields=$(echo "$line" | tr -cd '|' | wc -c)
            if [[ $fields -eq 4 ]]; then
                echo "$line" >> "$AI_MODEL_FILE"
                ((recovered++))
            fi
        done < "$backup" 2>/dev/null || true
        
        [[ $recovered -gt 0 ]] && echo -e "${GREEN}âœ… Recovered $recovered model entries${NC}" >&2
        (sleep 300 && rm -f "$backup") &
    fi
}

# Rebuild corrupted training log
rebuild_training_log() {
    local backup="${AI_TRAINING_LOG}.backup.$(date +%s)"
    [[ -f "$AI_TRAINING_LOG" ]] && cp "$AI_TRAINING_LOG" "$backup" 2>/dev/null
    
    # Create fresh training log
    cat > "$AI_TRAINING_LOG" << EOF
# AI Training History - Version $AI_MODEL_VERSION (Rebuilt)
# Format: timestamp|action|feature_pattern|settings|outcome|confidence
# Rebuilt: $(date)
EOF
    
    # Optionally recover recent entries (last 100 lines)
    if [[ -f "$backup" ]]; then
        local recovered=0
        tail -n 100 "$backup" 2>/dev/null | while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            local fields=$(echo "$line" | tr -cd '|' | wc -c)
            if [[ $fields -ge 4 ]]; then
                echo "$line" >> "$AI_TRAINING_LOG"
                ((recovered++))
            fi
        done
        
        (sleep 300 && rm -f "$backup") &
    fi
}

# Create training system backups
create_training_backups() {
    if [[ -f "$AI_MODEL_FILE" ]]; then
        cp "$AI_MODEL_FILE" "${AI_MODEL_FILE}.safe" 2>/dev/null || true
    fi
    if [[ -f "$AI_TRAINING_LOG" ]]; then
        cp "$AI_TRAINING_LOG" "${AI_TRAINING_LOG}.safe" 2>/dev/null || true
    fi
}

# Extract feature pattern from video characteristics
extract_feature_pattern() {
    local content_type="$1"
    local width="$2"
    local height="$3"
    local duration="$4"
    local motion_level="$5"
    local complexity="$6"
    
    # Normalize resolution into categories
    local resolution_class
    local total_pixels=$((width * height))
    if [[ $total_pixels -ge 8294400 ]]; then
        resolution_class="4k"
    elif [[ $total_pixels -ge 2073600 ]]; then
        resolution_class="1080p"
    elif [[ $total_pixels -ge 921600 ]]; then
        resolution_class="720p"
    else
        resolution_class="sd"
    fi
    
    # Normalize duration into categories
    local duration_class
    if [[ $duration -lt 10 ]]; then
        duration_class="short"
    elif [[ $duration -lt 60 ]]; then
        duration_class="medium"
    elif [[ $duration -lt 300 ]]; then
        duration_class="long"
    else
        duration_class="movie"
    fi
    
    # Create feature pattern
    echo "${content_type}:${resolution_class}:${duration_class}:${motion_level}:${complexity}"
}

# Predict optimal settings using AI training data
ai_predict_settings() {
    local feature_pattern="$1"
    
    if [[ "$AI_TRAINING_ENABLED" != "true" || ! -f "$AI_MODEL_FILE" ]]; then
        return 1
    fi
    
    # Search for exact match first
    local exact_match=$(grep "^$feature_pattern|" "$AI_MODEL_FILE" | tail -n 1)
    if [[ -n "$exact_match" ]]; then
        local confidence=$(echo "$exact_match" | cut -d'|' -f3)
        local sample_count=$(echo "$exact_match" | cut -d'|' -f4)
        
        # Only use prediction if we have enough samples and confidence
        if [[ $(echo "$confidence > $AI_CONFIDENCE_MIN" | bc -l 2>/dev/null || echo 0) -eq 1 ]] && \
           [[ $sample_count -ge $AI_TRAINING_MIN_SAMPLES ]]; then
            local settings=$(echo "$exact_match" | cut -d'|' -f2)
            echo "EXACT:$confidence:$settings"
            return 0
        fi
    fi
    
    # Try partial matches with similarity scoring
    local best_match=""
    local best_score=0
    local best_confidence=0
    
    while IFS='|' read -r pattern settings confidence samples timestamp; do
        [[ "$pattern" =~ ^# ]] && continue  # Skip comments
        [[ -z "$pattern" ]] && continue     # Skip empty lines
        
        # Calculate similarity score
        local similarity=$(calculate_pattern_similarity "$feature_pattern" "$pattern")
        local weighted_score=$(echo "$similarity * $confidence" | bc -l 2>/dev/null || echo "0")
        
        if [[ $(echo "$weighted_score > $best_score" | bc -l 2>/dev/null || echo 0) -eq 1 ]] && \
           [[ $samples -ge $AI_TRAINING_MIN_SAMPLES ]]; then
            best_match="$settings"
            best_score="$weighted_score"
            best_confidence="$confidence"
        fi
    done < <(tail -n +4 "$AI_MODEL_FILE")
    
    if [[ -n "$best_match" && $(echo "$best_score > $AI_CONFIDENCE_MIN" | bc -l 2>/dev/null || echo 0) -eq 1 ]]; then
        echo "SIMILAR:$best_confidence:$best_match"
        return 0
    fi
    
    return 1
}

# Calculate similarity between feature patterns
calculate_pattern_similarity() {
    local pattern1="$1"
    local pattern2="$2"
    
    IFS=':' read -ra features1 <<< "$pattern1"
    IFS=':' read -ra features2 <<< "$pattern2"
    
    local matches=0
    local total=${#features1[@]}
    
    for ((i=0; i<total; i++)); do
        if [[ "${features1[i]}" == "${features2[i]}" ]]; then
            ((matches++))
        fi
    done
    
    # Return similarity as decimal (0.0 to 1.0)
    echo "scale=2; $matches / $total" | bc -l 2>/dev/null || echo "0"
}

# Train AI model with successful conversion results
train_ai_model() {
    local file="$1"
    local content_type="$2"
    local width="$3"
    local height="$4"
    local duration="$5"
    local motion_level="$6"
    local complexity="$7"
    local final_framerate="$8"
    local final_dither="$9"
    local final_colors="${10}"
    local final_crop="${11:-none}"
    local outcome="${12:-success}"  # success, partial, failure
    
    if [[ "$AI_TRAINING_ENABLED" != "true" ]]; then
        return 0
    fi
    
    local feature_pattern=$(extract_feature_pattern "$content_type" "$width" "$height" "$duration" "$motion_level" "$complexity")
    local settings_pattern="${final_framerate}:${final_dither}:${final_colors}:${final_crop}"
    local timestamp=$(date +%s)
    
    # Calculate outcome score
    local outcome_score
    case "$outcome" in
        "success") outcome_score=1.0 ;;
        "partial") outcome_score=0.6 ;;
        "failure") outcome_score=0.1 ;;
        *) outcome_score=0.5 ;;
    esac
    
    # Log training event (atomic)
    atomic_append_training_log "$timestamp|train|$feature_pattern|$settings_pattern|$outcome|$outcome_score"
    
    # Update or create model entry (atomic)
    atomic_update_model_entry "$feature_pattern" "$settings_pattern" "$outcome_score"
}

# Atomic append to training log
atomic_append_training_log() {
    local log_entry="$1"
    [[ -z "$log_entry" ]] && return 1
    
    # Validate log integrity before writing
    if ! validate_training_log; then
        echo -e "${YELLOW}ðŸ”„ Training log corrupted, rebuilding...${NC}" >&2
        rebuild_training_log
    fi
    
    local temp_log="${AI_TRAINING_LOG}.append.$$"
    
    # Copy existing log and append new entry atomically
    if [[ -f "$AI_TRAINING_LOG" ]]; then
        cp "$AI_TRAINING_LOG" "$temp_log" 2>/dev/null || return 1
        echo "$log_entry" >> "$temp_log" 2>/dev/null || {
            rm -f "$temp_log"
            return 1
        }
        mv "$temp_log" "$AI_TRAINING_LOG"
    else
        echo "$log_entry" > "$AI_TRAINING_LOG"
    fi
}

# Atomic update AI model entry with new training data
atomic_update_model_entry() {
    local feature_pattern="$1"
    local settings_pattern="$2"
    local outcome_score="$3"
    
    # Validate inputs
    if [[ "${#feature_pattern}" -gt 500 || "${#settings_pattern}" -gt 200 ]]; then
        echo -e "${YELLOW}âš ï¸  Warning: Training data too large, skipping save${NC}" >&2
        return 1
    fi
    
    # Ensure model file integrity before modification
    if ! validate_ai_model; then
        echo -e "${YELLOW}ðŸ”„ Model corrupted before update, rebuilding...${NC}" >&2
        rebuild_ai_model
    fi
    
    local temp_model="${AI_MODEL_FILE}.atomic.$$"
    local updated=false
    local timestamp=$(date +%s)
    
    # Create backup before modification
    cp "$AI_MODEL_FILE" "${AI_MODEL_FILE}.preupdate" 2>/dev/null || true
    
    # Copy header first
    head -n 4 "$AI_MODEL_FILE" 2>/dev/null > "$temp_model" || {
        cat > "$temp_model" << EOF
# AI Smart Model Database - Version $AI_MODEL_VERSION
# Format: feature_pattern|optimal_settings|confidence|sample_count|last_updated
# Features: content_type:resolution:duration:motion_level:complexity
# Settings: framerate:dither:colors:crop
EOF
    }
    
    # Process existing entries
    while IFS='|' read -r pattern settings confidence samples last_updated; do
        [[ "$pattern" =~ ^# ]] && continue  # Skip comments
        [[ -z "$pattern" ]] && continue     # Skip empty lines
        
        # Validate entry format before processing
        local fields=$(echo "$pattern|$settings|$confidence|$samples|$last_updated" | tr -cd '|' | wc -c)
        [[ $fields -ne 4 ]] && continue
        
        if [[ "$pattern" == "$feature_pattern" ]]; then
            # Update existing entry using adaptive learning
            local new_samples=$((samples + 1))
            local new_confidence=$(echo "scale=3; ($confidence * $samples + $outcome_score * $AI_LEARNING_RATE) / $new_samples" | bc -l 2>/dev/null || echo "$confidence")
            
            # Prefer settings with higher success rate
            local updated_settings="$settings_pattern"
            if [[ $(echo "$outcome_score > 0.7" | bc -l 2>/dev/null || echo 0) -eq 1 ]]; then
                updated_settings="$settings_pattern"  # Use new successful settings
            fi
            
            echo "$pattern|$updated_settings|$new_confidence|$new_samples|$timestamp" >> "$temp_model"
            updated=true
        else
            echo "$pattern|$settings|$confidence|$samples|$last_updated" >> "$temp_model"
        fi
    done < <(tail -n +5 "$AI_MODEL_FILE" 2>/dev/null || true)
    
    # Add new entry if not updated
    if [[ "$updated" == "false" ]]; then
        echo "$feature_pattern|$settings_pattern|$outcome_score|1|$timestamp" >> "$temp_model"
    fi
    
    # Validate new file before replacing
    if [[ -s "$temp_model" ]] && head -n 1 "$temp_model" | grep -q "^#.*AI.*Model"; then
        mv "$temp_model" "$AI_MODEL_FILE"
        rm -f "${AI_MODEL_FILE}.preupdate"
    else
        echo -e "${YELLOW}âš ï¸  Warning: Failed to create valid model file, rolling back${NC}" >&2
        rm -f "$temp_model"
        [[ -f "${AI_MODEL_FILE}.preupdate" ]] && mv "${AI_MODEL_FILE}.preupdate" "$AI_MODEL_FILE"
        return 1
    fi
}

# Get AI training statistics
# ðŸ”— Create clickable file path with terminal hyperlink
make_clickable_path() {
    local file_path="$1"
    local display_text="${2:-$file_path}"
    
    # Convert ~ back to full path for the hyperlink
    local full_path="$(echo "$file_path" | sed "s|^~|$HOME|g")"
    
    # Enhanced terminal and hyperlink support detection
    local supports_hyperlinks=false
    
    # Check for terminals that support OSC 8 hyperlinks
    if [[ -n "$TERM" && "$TERM" != "dumb" && -t 1 ]]; then
        # Warp terminal always supports hyperlinks
        if [[ "$TERM_PROGRAM" == "WarpTerminal" ]]; then
            supports_hyperlinks=true
        # Other modern terminals
        elif [[ "$TERM_PROGRAM" =~ ^(iTerm\.app|vscode|Terminal\.app)$ ]]; then
            supports_hyperlinks=true
        # Standard terminal types that support hyperlinks
        elif [[ "$TERM" =~ ^(xterm|screen|tmux) ]]; then
            supports_hyperlinks=true
        fi
    fi
    
    if [[ "$supports_hyperlinks" == "true" ]]; then
        # Use OSC 8 hyperlink escape sequence
        # Format: \033]8;;file://path\033\\text\033]8;;\033\\
        printf "\033]8;;file://%s\033\\%s\033]8;;\033\\" "$full_path" "$display_text"
    else
        # Fallback: show only display text (no parentheses)
        echo "$display_text"
    fi
}

# ðŸ¤– Comprehensive AI System Status Display
show_ai_status() {
    echo -e "${CYAN}${BOLD}ðŸ¤– AI SYSTEM COMPREHENSIVE STATUS${NC}\\n"
    
    # Display main settings location prominently at the top
    local settings_display_path="$(echo "$SETTINGS_FILE" | sed "s|$HOME|~|g")"
    local clickable_settings=$(make_clickable_path "$SETTINGS_FILE" "$settings_display_path")
    echo -e "${YELLOW}ðŸ“ Settings Location: ${BOLD}$clickable_settings${NC}"
    if [[ -f "$SETTINGS_FILE" ]]; then
        local mod_time=$(stat -c %Y -- "$SETTINGS_FILE" 2>/dev/null || echo "0")
        local readable_time=$(date -d "@$mod_time" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
        echo -e "${GRAY}   Last updated: $readable_time${NC}"
    else
        echo -e "${GRAY}   (will be created on first use)${NC}"
    fi
    echo ""
    
    # Basic AI Configuration
    echo -e "${BLUE}ðŸ“Š AI Configuration:${NC}"
    echo -e "  ðŸ”§ AI Enabled: $([[ "$AI_ENABLED" == true ]] && echo "${GREEN}âœ“ YES${NC}" || echo "${RED}âœ— NO${NC}")"
    echo -e "  ðŸ§  AI Mode: ${BOLD}$AI_MODE${NC} (smart/content/motion/quality)"
    echo -e "  ðŸŽ¯ Confidence Threshold: ${BOLD}$AI_CONFIDENCE_THRESHOLD${NC}%"
    echo -e "  âš¡ Auto Quality: $([[ "$AI_AUTO_QUALITY" == true ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${YELLOW}OFF${NC}")"
    echo -e "  ðŸŽ¬ Scene Analysis: $([[ "$AI_SCENE_ANALYSIS" == true ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${YELLOW}OFF${NC}")"
    echo -e "  ðŸ‘€ Visual Similarity: $([[ "$AI_VISUAL_SIMILARITY" == true ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${YELLOW}OFF${NC}")"
    echo -e "  âœ‚ï¸  Smart Crop: $([[ "$AI_SMART_CROP" == true ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${YELLOW}OFF${NC}")"
    echo -e "  ðŸŽžï¸  Dynamic Framerate: $([[ "$AI_DYNAMIC_FRAMERATE" == true ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${YELLOW}OFF${NC}")"
    echo ""
    
    # AI Cache System Status
    echo -e "${BLUE}ðŸ’¾ AI Cache System:${NC}"
    local cache_display_path="$(echo "$AI_CACHE_DIR" | sed "s|$HOME|~|g")"
    local clickable_cache_dir=$(make_clickable_path "$AI_CACHE_DIR" "$cache_display_path")
    echo -e "  ðŸ“ Cache Directory: ${BOLD}$clickable_cache_dir${NC}"
    echo -e "  ðŸ”§ Cache Enabled: $([[ "$AI_CACHE_ENABLED" == true ]] && echo "${GREEN}âœ“ YES${NC}" || echo "${RED}âœ— NO${NC}")"
    echo -e "  ðŸ“‹ Cache Version: ${BOLD}$AI_CACHE_VERSION${NC}"
    echo -e "  ðŸ—“ï¸  Max Age: ${BOLD}$AI_CACHE_MAX_AGE_DAYS${NC} days"
    
    # Cache file status
    if [[ -f "$AI_CACHE_INDEX" ]]; then
        local cache_size=$(stat -c%s -- "$AI_CACHE_INDEX" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "?")
        local cache_entries=$(grep -v '^#' "$AI_CACHE_INDEX" 2>/dev/null | grep -c '|' 2>/dev/null || echo "0")
        echo -e "  ðŸ“ˆ Cache Status: ${GREEN}âœ“ Active${NC} ($cache_entries entries, $cache_size)"
        
        # Cache validation status
        if validate_cache_index; then
            echo -e "  âœ… Cache Integrity: ${GREEN}âœ“ Valid${NC}"
        else
            echo -e "  âš ï¸  Cache Integrity: ${YELLOW}! Needs rebuild${NC}"
        fi
    else
        echo -e "  ðŸ“ˆ Cache Status: ${YELLOW}! Not initialized${NC}"
    fi
    echo ""
    
    # AI Training System Status
    echo -e "${BLUE}ðŸ§  AI Training System:${NC}"
    echo -e "  ðŸŽ“ Training Enabled: $([[ "$AI_TRAINING_ENABLED" == true ]] && echo "${GREEN}âœ“ YES${NC}" || echo "${RED}âœ— NO${NC}")"
    local training_display_path="$(echo "$AI_TRAINING_DIR" | sed "s|$HOME|~|g")"
    local clickable_training_dir=$(make_clickable_path "$AI_TRAINING_DIR" "$training_display_path")
    echo -e "  ðŸ“ Training Directory: ${BOLD}$clickable_training_dir${NC}"
    echo -e "  ðŸ“Š Model Version: ${BOLD}$AI_MODEL_VERSION${NC}"
    echo -e "  ðŸ¤– AI Generation: ${BOLD}$AI_GENERATION${NC}"
    echo -e "  ðŸ“ˆ Learning Rate: ${BOLD}$AI_LEARNING_RATE${NC}"
    echo -e "  ðŸŽ¯ Confidence Min: ${BOLD}$AI_CONFIDENCE_MIN${NC}"
    echo -e "  ðŸ“‹ Min Samples: ${BOLD}$AI_TRAINING_MIN_SAMPLES${NC}"
    
    # Training data status
    if [[ "$AI_TRAINING_ENABLED" == true ]]; then
        if [[ -f "$AI_MODEL_FILE" ]]; then
            local model_size=$(stat -c%s -- "$AI_MODEL_FILE" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "?")
            local total_patterns=$(grep -v '^#' "$AI_MODEL_FILE" 2>/dev/null | grep -c '|' 2>/dev/null || echo "0")
            local avg_confidence="0.00"
            
            # Clean the variable to ensure it contains only numbers
            total_patterns=${total_patterns//[^0-9]/}
            [[ -z "$total_patterns" ]] && total_patterns="0"
            
            if [[ $total_patterns -gt 0 ]]; then
                avg_confidence=$(awk -F'|' 'NR>4 && NF>=3 {sum+=$3; count++} END {if(count>0) printf "%.2f", sum/count; else print "0.00"}' "$AI_MODEL_FILE" 2>/dev/null || echo "0.00")
            fi
            
            echo -e "  ðŸ“Š Model Status: ${GREEN}âœ“ Active${NC} ($total_patterns patterns, $model_size)"
            echo -e "  ðŸ“ˆ Average Confidence: ${BOLD}$avg_confidence${NC}"
            
            # Model validation status
            if validate_ai_model; then
                echo -e "  âœ… Model Integrity: ${GREEN}âœ“ Valid${NC}"
            else
                echo -e "  âš ï¸  Model Integrity: ${YELLOW}! Needs rebuild${NC}"
            fi
        else
            echo -e "  ðŸ“Š Model Status: ${YELLOW}! Not initialized${NC}"
        fi
        
        if [[ -f "$AI_TRAINING_LOG" ]]; then
            local log_size=$(stat -c%s -- "$AI_TRAINING_LOG" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "?")
            local training_events=$(grep -v '^#' "$AI_TRAINING_LOG" 2>/dev/null | grep -c '|' 2>/dev/null || echo "0")
            echo -e "  ðŸ“œ Training Log: ${GREEN}âœ“ Active${NC} ($training_events sessions, $log_size)"
            
            # Training log validation
            if validate_training_log; then
                echo -e "  âœ… Log Integrity: ${GREEN}âœ“ Valid${NC}"
            else
                echo -e "  âš ï¸  Log Integrity: ${YELLOW}! Needs rebuild${NC}"
            fi
        else
            echo -e "  ðŸ“œ Training Log: ${YELLOW}! Not found${NC}"
        fi
    else
        echo -e "  ðŸ“Š Training Status: ${GRAY}Disabled${NC}"
    fi
    echo ""
    
    # AI Performance Settings
    echo -e "${BLUE}âš¡ AI Performance Settings:${NC}"
    echo -e "  ðŸ§® CPU Cores: ${BOLD}$CPU_CORES${NC} total, ${BOLD}$CPU_PHYSICAL_CORES${NC} physical"
    echo -e "  ðŸ”„ Max Parallel Jobs: ${BOLD}$AI_MAX_PARALLEL_JOBS${NC}"
    echo -e "  ðŸ•¸ï¸  Duplicate Detection Threads: ${BOLD}$AI_DUPLICATE_THREADS${NC}"
    echo -e "  ðŸ“¦ Analysis Batch Size: ${BOLD}$AI_ANALYSIS_BATCH_SIZE${NC}"
    echo -e "  ðŸ§µ Optimal Threads: ${BOLD}$AI_THREADS_OPTIMAL${NC}"
    echo -e "  ðŸ§  Memory Optimization: ${BOLD}$AI_MEMORY_OPT${NC}"
    echo ""
    
    # Recent AI Activity (if available)
    echo -e "${BLUE}ðŸ“Š Recent AI Activity:${NC}"
    if [[ -f "$AI_TRAINING_LOG" && "$AI_TRAINING_ENABLED" == true ]]; then
        local recent_sessions=$(tail -n 5 "$AI_TRAINING_LOG" 2>/dev/null | grep -v '^#' | wc -l)
        if [[ $recent_sessions -gt 0 ]]; then
            echo -e "  ðŸ“ˆ Last 5 Training Sessions:"
            tail -n 5 "$AI_TRAINING_LOG" 2>/dev/null | grep -v '^#' | while IFS='|' read -r timestamp action pattern settings outcome confidence; do
                local status_icon
                case "$outcome" in
                    "success") status_icon="${GREEN}âœ“${NC}" ;;
                    "partial") status_icon="${YELLOW}~${NC}" ;;
                    "failure") status_icon="${RED}âœ—${NC}" ;;
                    *) status_icon="${BLUE}?${NC}" ;;
                esac
                echo -e "    $status_icon $(echo "$pattern" | cut -d':' -f1-2) â†’ conf:$confidence"
            done
        else
            echo -e "  ${GRAY}No recent training activity${NC}"
        fi
    else
        echo -e "  ${GRAY}Training disabled or no log available${NC}"
    fi
    echo ""
    
    # AI Health Check
    echo -e "${BLUE}ðŸ¥ AI System Health Check:${NC}"
    local health_issues=0
    
    # Check cache health
    if [[ "$AI_CACHE_ENABLED" == true ]]; then
        if [[ ! -d "$AI_CACHE_DIR" ]]; then
            echo -e "  âš ï¸  Cache directory missing"
            ((health_issues++))
        elif ! validate_cache_index 2>/dev/null; then
            echo -e "  âš ï¸  Cache index corrupted"
            ((health_issues++))
        fi
    fi
    
    # Check training health
    if [[ "$AI_TRAINING_ENABLED" == true ]]; then
        if [[ ! -d "$AI_TRAINING_DIR" ]]; then
            echo -e "  âš ï¸  Training directory missing"
            ((health_issues++))
        elif [[ -f "$AI_MODEL_FILE" ]] && ! validate_ai_model 2>/dev/null; then
            echo -e "  âš ï¸  AI model corrupted"
            ((health_issues++))
        elif [[ -f "$AI_TRAINING_LOG" ]] && ! validate_training_log 2>/dev/null; then
            echo -e "  âš ï¸  Training log corrupted"
            ((health_issues++))
        fi
    fi
    
    # Check dependencies
    if ! command -v bc >/dev/null 2>&1; then
        echo -e "  âš ï¸  'bc' command missing (needed for AI calculations)"
        ((health_issues++))
    fi
    
    if [[ $health_issues -eq 0 ]]; then
        echo -e "  ${GREEN}âœ… All systems healthy${NC}"
    else
        echo -e "  ${YELLOW}âš ï¸  $health_issues issue(s) detected${NC}"
        echo -e "  ðŸ’¡ Run the script to auto-repair most issues"
    fi
    
    echo -e "\n${CYAN}ðŸ’¡ Tips:${NC}"
    echo -e "  ${BLUE}â€¢${NC} Use interactive menu options to manage AI settings"
    echo -e "  ${BLUE}â€¢${NC} Click on file paths above to open them in your file manager"
    echo -e "  ${BLUE}â€¢${NC} Settings are automatically saved when changed"
}

# ðŸ¦º AI File Health Detection & Learning System
# ===============================================

# Analyze file health using AI with learning capabilities
ai_analyze_file_health() {
    local file="$1"
    local context="$2"  # md5_failed, analysis_timeout, suspicious_size, etc.
    
    # SAFETY: Only analyze GIF files - never touch video sources
    if [[ "${file##*.}" != "gif" ]]; then
        echo "SKIP_NON_GIF"  # Don't analyze non-GIF files
        return 0
    fi
    
    # Refuse to analyze video files (double safety check)
    if [[ "$file" =~ \.(mp4|avi|mov|mkv|webm|MP4|AVI|MOV|MKV|WEBM)$ ]]; then
        echo "SKIP_VIDEO_FILE"  # Never analyze video files
        return 0
    fi
    
    # Quick validation
    [[ -z "$file" || ! -f "$file" ]] && echo "CORRUPTED" && return 1
    
    # Get file characteristics for AI analysis
    local file_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
    local file_age=$(stat -c%Y -- "$file" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local age_days=$(( (current_time - file_age) / 86400 ))
    
    # Create feature signature for AI analysis
    local feature_signature="${context}:${file_size}:${age_days}"
    
    # Check if we have learned patterns for this type of issue
    local ai_confidence=$(query_ai_health_model "$feature_signature")
    local health_verdict="UNCERTAIN"
    
    # AI decision making based on context and learned patterns
    case "$context" in
        "md5_failed")
            # MD5 failure is usually serious
            if [[ $file_size -eq 0 ]]; then
                health_verdict="CORRUPTED"  # Empty file
            elif [[ $file_size -gt 104857600 ]]; then
                health_verdict="COMPLEX"    # Very large file might cause MD5 issues
            elif [[ $age_days -lt 1 && $file_size -gt 1024 ]]; then
                health_verdict="COMPLEX"    # Recent file with reasonable size might be OK
            else
                health_verdict="CORRUPTED"  # Default to corrupted for MD5 failures
            fi
            ;;
        "analysis_timeout")
            # Timeouts can indicate complexity or corruption
            if [[ $file_size -gt 52428800 ]]; then  # > 50MB
                health_verdict="COMPLEX"    # Large files legitimately take time
            elif [[ $file_size -lt 1024 ]]; then
                health_verdict="CORRUPTED"  # Very small files shouldn't timeout
            elif [[ $age_days -gt 30 ]]; then
                health_verdict="CORRUPTED"  # Old files with timeouts likely corrupted
            else
                # Use AI confidence if available
                if [[ -n "$ai_confidence" && "$ai_confidence" != "0" ]]; then
                    local confidence_num=${ai_confidence%.*}  # Remove decimal part
                    confidence_num=${confidence_num:-0}
                    if [[ $confidence_num -gt 70 ]]; then
                        health_verdict="COMPLEX"
                    elif [[ $confidence_num -lt 30 ]]; then
                        health_verdict="CORRUPTED"
                    else
                        health_verdict="UNCERTAIN"
                    fi
                else
                    health_verdict="COMPLEX"  # Default to complex for reasonable files
                fi
            fi
            ;;
        "suspicious_size")
            # Size-based analysis
            if [[ $file_size -eq 0 ]]; then
                health_verdict="CORRUPTED"
            elif [[ $file_size -lt 100 ]]; then
                health_verdict="CORRUPTED"  # Too small to be valid GIF
            else
                health_verdict="COMPLEX"
            fi
            ;;
        *)
            # Default analysis for unknown contexts
            if [[ $file_size -eq 0 ]]; then
                health_verdict="CORRUPTED"
            elif [[ $file_size -gt 209715200 ]]; then  # > 200MB
                health_verdict="COMPLEX"
            else
                health_verdict="UNCERTAIN"
            fi
            ;;
    esac
    
    echo "$health_verdict"
}

# Query AI health model for learned patterns
query_ai_health_model() {
    local feature_signature="$1"
    
    if [[ "$AI_TRAINING_ENABLED" != "true" || ! -f "$AI_MODEL_FILE" ]]; then
        echo "50"  # Default neutral confidence (as integer)
        return 1
    fi
    
    # Search for similar patterns in the AI model
    local pattern_match=$(grep "^health_pattern:$feature_signature" "$AI_MODEL_FILE" 2>/dev/null | tail -1)
    if [[ -n "$pattern_match" ]]; then
        # Extract confidence score: health_pattern:signature|verdict|confidence|samples|timestamp
        local confidence=$(echo "$pattern_match" | cut -d'|' -f3)
        # Convert to integer percentage
        local confidence_int=$(echo "$confidence * 100" | bc 2>/dev/null | cut -d. -f1 2>/dev/null || echo "50")
        echo "${confidence_int:-50}"
    else
        # Look for partial matches (same context)
        local context="${feature_signature%%:*}"
        local partial_matches=$(grep "^health_pattern:$context:" "$AI_MODEL_FILE" 2>/dev/null | wc -l)
        if [[ $partial_matches -gt 0 ]]; then
            # Calculate average confidence for this context
            local avg_confidence=$(grep "^health_pattern:$context:" "$AI_MODEL_FILE" 2>/dev/null | \
                cut -d'|' -f3 | awk '{sum+=$1; count++} END {if(count>0) printf "%.0f", sum*100/count; else print "50"}')
            echo "${avg_confidence:-50}"
        else
            echo "50"  # No learned patterns, neutral confidence
        fi
    fi
}

# Train AI model with file health patterns
train_ai_file_health() {
    local file="$1"
    local verdict="$2"      # corrupted, complex, suspicious, uncertain
    local context="$3"      # md5_failed, analysis_timeout, etc.
    local outcome="$4"      # confirmed, legitimate, learning
    
    # SAFETY: Only train on GIF files - never video files
    if [[ "${file##*.}" != "gif" ]]; then
        return 0  # Skip training for non-GIF files
    fi
    
    # Double safety: refuse video files
    if [[ "$file" =~ \.(mp4|avi|mov|mkv|webm|MP4|AVI|MOV|MKV|WEBM)$ ]]; then
        return 0  # Never train on video files
    fi
    
    if [[ "$AI_TRAINING_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Get file characteristics
    local file_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
    local file_age=$(stat -c%Y -- "$file" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local age_days=$(( (current_time - file_age) / 86400 ))
    
    # Create feature signature
    local feature_signature="${context}:${file_size}:${age_days}"
    
    # Calculate outcome score for training
    local outcome_score
    case "$outcome" in
        "confirmed") outcome_score="1.0" ;;    # High confidence
        "legitimate") outcome_score="0.8" ;;   # Good confidence
        "learning") outcome_score="0.5" ;;     # Neutral for learning
        "uncertain") outcome_score="0.3" ;;    # Low confidence
        *) outcome_score="0.5" ;;
    esac
    
    # Log training event
    local timestamp=$(date +%s)
    atomic_append_training_log "$timestamp|health_train|$feature_signature|$verdict|$outcome|$outcome_score"
    
    # Update AI health model
    atomic_update_health_model "$feature_signature" "$verdict" "$outcome_score"
}

# Update AI health model with new patterns
atomic_update_health_model() {
    local feature_signature="$1"
    local verdict="$2"
    local outcome_score="$3"
    
    # Ensure model file integrity
    if ! validate_ai_model; then
        rebuild_ai_model
    fi
    
    local temp_model="${AI_MODEL_FILE}.health.$$"
    local updated=false
    local timestamp=$(date +%s)
    
    # Create backup
    cp "$AI_MODEL_FILE" "${AI_MODEL_FILE}.health_backup" 2>/dev/null || true
    
    # Copy existing model
    cp "$AI_MODEL_FILE" "$temp_model" 2>/dev/null || {
        echo "# AI Health Model - Auto-generated" > "$temp_model"
    }
    
    # Look for existing health pattern
    local pattern_key="health_pattern:$feature_signature"
    if grep -q "^$pattern_key" "$temp_model" 2>/dev/null; then
        # Update existing pattern using adaptive learning
        local current_line=$(grep "^$pattern_key" "$temp_model" | tail -1)
        local current_confidence=$(echo "$current_line" | cut -d'|' -f3 2>/dev/null || echo "0.5")
        local current_samples=$(echo "$current_line" | cut -d'|' -f4 2>/dev/null || echo "1")
        
        # Calculate new confidence with learning rate
        local new_samples=$((current_samples + 1))
        local new_confidence
        if command -v bc >/dev/null 2>&1; then
            new_confidence=$(echo "scale=3; ($current_confidence * $current_samples + $outcome_score * $AI_LEARNING_RATE) / $new_samples" | bc 2>/dev/null || echo "$outcome_score")
        else
            new_confidence="$outcome_score"  # Fallback if bc not available
        fi
        
        # Remove old pattern and add updated one
        grep -v "^$pattern_key" "$temp_model" > "${temp_model}.tmp"
        echo "$pattern_key|$verdict|$new_confidence|$new_samples|$timestamp" >> "${temp_model}.tmp"
        mv "${temp_model}.tmp" "$temp_model"
        updated=true
    else
        # Add new health pattern
        echo "$pattern_key|$verdict|$outcome_score|1|$timestamp" >> "$temp_model"
        updated=true
    fi
    
    # Replace model file atomically
    if [[ "$updated" == "true" ]] && [[ -s "$temp_model" ]]; then
        mv "$temp_model" "$AI_MODEL_FILE"
        rm -f "${AI_MODEL_FILE}.health_backup"
    else
        rm -f "$temp_model"
        [[ -f "${AI_MODEL_FILE}.health_backup" ]] && mv "${AI_MODEL_FILE}.health_backup" "$AI_MODEL_FILE"
    fi
}

# Legacy function for backward compatibility
get_ai_training_stats() {
    if [[ "$AI_TRAINING_ENABLED" != "true" || ! -f "$AI_MODEL_FILE" ]]; then
        echo "Training disabled"
        return
    fi
    
    local total_patterns=$(grep -v '^#' "$AI_MODEL_FILE" 2>/dev/null | grep -c '|' 2>/dev/null || echo "0")
    local total_training_events=$(grep -v '^#' "$AI_TRAINING_LOG" 2>/dev/null | grep -c '|' 2>/dev/null || echo "0")
    local avg_confidence
    
    # Clean the variables to ensure they contain only numbers
    total_patterns=${total_patterns//[^0-9]/}
    total_training_events=${total_training_events//[^0-9]/}
    [[ -z "$total_patterns" ]] && total_patterns="0"
    [[ -z "$total_training_events" ]] && total_training_events="0"
    
    if [[ $total_patterns -gt 0 ]]; then
        avg_confidence=$(awk -F'|' 'NR>4 && NF>=3 {sum+=$3; count++} END {if(count>0) printf "%.2f", sum/count; else print "0.00"}' "$AI_MODEL_FILE")
    else
        avg_confidence="0.00"
    fi
    
    echo "$total_patterns patterns, $total_training_events sessions, ${avg_confidence} avg confidence"
}
RAM_OPTIMIZATION=true
RAM_CACHE_SIZE="auto"
RAM_DISK_ENABLED=false
RAM_DISK_PATH=""
DYNAMIC_FILE_DETECTION=false
FILE_MONITOR_INTERVAL=10

# ðŸ“ Initialize log directory and temp work directory
init_log_directory() {
    # Create log directory if it doesn't exist
    if [[ ! -d "$LOG_DIR" ]]; then
        if ! mkdir -p "$LOG_DIR" 2>/dev/null; then
            echo -e "${RED}âŒ Error: Cannot create log directory at $LOG_DIR${NC}"
            echo -e "${YELLOW}Falling back to current directory for logs${NC}"
            LOG_DIR="."
            ERROR_LOG="./gif-converter-errors.log"
            CONVERSION_LOG="./gif-converter-conversions.log"
            SETTINGS_FILE="./gif-converter-settings.conf"
            return 1
        fi
        echo -e "${GREEN}âœ“ Created log directory: $LOG_DIR${NC}"
    fi
    
    # Create temporary work directory for intermediate files
    TEMP_WORK_DIR="$LOG_DIR/temp_work"
    if [[ ! -d "$TEMP_WORK_DIR" ]]; then
        if ! mkdir -p "$TEMP_WORK_DIR" 2>/dev/null; then
            echo -e "${YELLOW}âš ï¸ Warning: Cannot create temp work directory, using /tmp${NC}"
            TEMP_WORK_DIR="/tmp/gif-converter-$$"
            mkdir -p "$TEMP_WORK_DIR" 2>/dev/null || TEMP_WORK_DIR="/tmp"
        fi
    fi
    
    # Set settings file path
    SETTINGS_FILE="$LOG_DIR/settings.conf"
    
    # Initialize error log
    echo "# Smart GIF Converter Error Log - $(date)" > "$ERROR_LOG"
    echo "# Log directory: $LOG_DIR" >> "$ERROR_LOG"
    echo "# Working directory: $(pwd)" >> "$ERROR_LOG"
    echo "" >> "$ERROR_LOG"
    
    # Initialize conversion log
    if [[ ! -f "$CONVERSION_LOG" ]]; then
        echo "# Smart GIF Converter Conversion History" > "$CONVERSION_LOG"
        echo "# Format: [TIMESTAMP] STATUS: source_file -> output_file (size_info)" >> "$CONVERSION_LOG"
        echo "" >> "$CONVERSION_LOG"
    fi
    
    # Log rotation - keep only last 1000 lines of each log
    if [[ -f "$ERROR_LOG" ]] && [[ $(wc -l < "$ERROR_LOG") -gt 1000 ]]; then
        tail -800 "$ERROR_LOG" > "${ERROR_LOG}.tmp" && mv "${ERROR_LOG}.tmp" "$ERROR_LOG"
    fi
    
    if [[ -f "$CONVERSION_LOG" ]] && [[ $(wc -l < "$CONVERSION_LOG") -gt 1000 ]]; then
        tail -800 "$CONVERSION_LOG" > "${CONVERSION_LOG}.tmp" && mv "${CONVERSION_LOG}.tmp" "$CONVERSION_LOG"
    fi
    
    # Clean up old validation cache corrupt backups (keep only last 5, delete the rest)
    # Do this in background to not slow down startup
    (
        local corrupt_count=$(ls -1 "$LOG_DIR/validation_cache.db.corrupt."* 2>/dev/null | wc -l)
        if [[ $corrupt_count -gt 5 ]]; then
            ls -t "$LOG_DIR/validation_cache.db.corrupt."* 2>/dev/null | tail -n +6 | xargs -r rm -f 2>/dev/null
        fi
    ) &
}

# ðŸ”’ Check and fix file/directory permissions
check_and_fix_permissions() {
    local silent_mode=false
    [[ "$1" == "--silent" ]] && silent_mode=true
    
    local issues_found=0
    local fix_commands=()
    local files_to_check=()
    local dirs_to_check=()
    
    # Directories that should be writable
    dirs_to_check+=(
        "$LOG_DIR"
        "$TEMP_WORK_DIR"
        "$AI_CACHE_DIR"
        "$AI_TRAINING_DIR"
    )
    
    # Files that should be readable and writable
    files_to_check+=(
        "$SETTINGS_FILE"
        "$ERROR_LOG"
        "$CONVERSION_LOG"
    )
    
    # Optional files (don't fail if they don't exist)
    local optional_files=(
        "$AI_CACHE_INDEX"
        "$AI_MODEL_FILE"
        "$AI_TRAINING_LOG"
        "$PROGRESS_FILE"
    )
    
    if [[ "$silent_mode" != true ]]; then
        echo -e "${CYAN}ðŸ” Checking file and directory permissions...${NC}"
    fi
    
    # Check directories
    for dir in "${dirs_to_check[@]}"; do
        [[ -z "$dir" || "$dir" == "." || "$dir" == "/tmp"* ]] && continue
        
        if [[ -d "$dir" ]]; then
            # Check if directory is readable
            if [[ ! -r "$dir" ]]; then
                ((issues_found++))
                echo -e "${RED}âŒ Directory not readable: $dir${NC}" >&2
                fix_commands+=("chmod u+r \"$dir\"")
            fi
            
            # Check if directory is writable
            if [[ ! -w "$dir" ]]; then
                ((issues_found++))
                echo -e "${RED}âŒ Directory not writable: $dir${NC}" >&2
                fix_commands+=("chmod u+w \"$dir\"")
            fi
            
            # Check if directory is executable (needed to access contents)
            if [[ ! -x "$dir" ]]; then
                ((issues_found++))
                echo -e "${RED}âŒ Directory not accessible: $dir${NC}" >&2
                fix_commands+=("chmod u+x \"$dir\"")
            fi
            
            # Check ownership
            local dir_owner=$(stat -c '%U' "$dir" 2>/dev/null)
            if [[ -n "$dir_owner" && "$dir_owner" != "$USER" ]]; then
                ((issues_found++))
                echo -e "${YELLOW}âš ï¸  Directory owned by different user: $dir (owner: $dir_owner)${NC}" >&2
                fix_commands+=("sudo chown $USER:\$(id -gn) \"$dir\"")
            fi
        fi
    done
    
    # Check required files
    for file in "${files_to_check[@]}"; do
        [[ -z "$file" ]] && continue
        
        if [[ -f "$file" ]]; then
            # Check if file is readable
            if [[ ! -r "$file" ]]; then
                ((issues_found++))
                echo -e "${RED}âŒ File not readable: $file${NC}" >&2
                fix_commands+=("chmod u+r \"$file\"")
            fi
            
            # Check if file is writable
            if [[ ! -w "$file" ]]; then
                ((issues_found++))
                echo -e "${RED}âŒ File not writable: $file${NC}" >&2
                fix_commands+=("chmod u+w \"$file\"")
            fi
            
            # Check ownership
            local file_owner=$(stat -c '%U' "$file" 2>/dev/null)
            if [[ -n "$file_owner" && "$file_owner" != "$USER" ]]; then
                ((issues_found++))
                echo -e "${YELLOW}âš ï¸  File owned by different user: $file (owner: $file_owner)${NC}" >&2
                fix_commands+=("sudo chown $USER:\$(id -gn) \"$file\"")
            fi
        fi
    done
    
    # Check optional files (only if they exist)
    for file in "${optional_files[@]}"; do
        [[ -z "$file" || ! -f "$file" ]] && continue
        
        if [[ ! -r "$file" || ! -w "$file" ]]; then
            ((issues_found++))
            echo -e "${YELLOW}âš ï¸  Optional file has permission issues: $(basename "$file")${NC}" >&2
            fix_commands+=("chmod u+rw \"$file\"")
        fi
        
        local file_owner=$(stat -c '%U' "$file" 2>/dev/null)
        if [[ -n "$file_owner" && "$file_owner" != "$USER" ]]; then
            ((issues_found++))
            echo -e "${YELLOW}âš ï¸  Optional file owned by: $file_owner - $(basename "$file")${NC}" >&2
            fix_commands+=("sudo chown $USER:\$(id -gn) \"$file\"")
        fi
    done
    
    # If issues found, prompt user to fix them
    if [[ $issues_found -gt 0 ]]; then
        echo -e "\n${RED}${BOLD}âš ï¸  PERMISSION ISSUES DETECTED${NC}"
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${YELLOW}Found $issues_found permission issue(s) that may prevent the script from working.${NC}\n"
        
        echo -e "${CYAN}${BOLD}How would you like to fix these issues?${NC}"
        echo -e "  ${GREEN}[1]${NC} Let the script automatically fix them (recommended)"
        echo -e "  ${GREEN}[2]${NC} Show me the commands to run manually"
        echo -e "  ${GREEN}[3]${NC} Continue anyway (may cause errors)"
        echo -e "  ${GREEN}[4]${NC} Exit and fix manually later\n"
        
        echo -ne "${MAGENTA}Enter your choice [1-4]: ${NC}"
        read -r fix_choice
        
        case "$fix_choice" in
            1)
                echo -e "\n${CYAN}ðŸ”§ Attempting to fix permissions automatically...${NC}\n"
                
                local fixed=0
                local failed=0
                
                # Deduplicate and execute fix commands
                local executed_commands=()
                for cmd in "${fix_commands[@]}"; do
                    # Skip if already executed
                    local already_done=false
                    for executed in "${executed_commands[@]}"; do
                        [[ "$cmd" == "$executed" ]] && already_done=true && break
                    done
                    [[ "$already_done" == true ]] && continue
                    
                    echo -e "${BLUE}â–¶ Running: ${GRAY}$cmd${NC}"
                    
                    if eval "$cmd" 2>/dev/null; then
                        echo -e "  ${GREEN}âœ“ Success${NC}"
                        ((fixed++))
                    else
                        echo -e "  ${RED}âœ— Failed${NC}"
                        ((failed++))
                    fi
                    
                    executed_commands+=("$cmd")
                done
                
                echo -e "\n${GREEN}âœ“ Fixed: $fixed issues${NC}"
                [[ $failed -gt 0 ]] && echo -e "${RED}âœ— Failed: $failed issues${NC}"
                
                if [[ $failed -eq 0 ]]; then
                    echo -e "\n${GREEN}${BOLD}All permission issues resolved!${NC}"
                else
                    echo -e "\n${YELLOW}Some issues remain. You may need to run with sudo or fix manually.${NC}"
                fi
                ;;
            2)
                echo -e "\n${CYAN}${BOLD}Commands to fix permissions manually:${NC}\n"
                
                # Deduplicate commands
                local printed_commands=()
                for cmd in "${fix_commands[@]}"; do
                    local already_printed=false
                    for printed in "${printed_commands[@]}"; do
                        [[ "$cmd" == "$printed" ]] && already_printed=true && break
                    done
                    [[ "$already_printed" == true ]] && continue
                    
                    echo -e "  ${GRAY}$cmd${NC}"
                    printed_commands+=("$cmd")
                done
                
                echo -e "\n${YELLOW}Copy and run these commands in your terminal.${NC}"
                ;;
            3)
                echo -e "\n${YELLOW}âš ï¸  Continuing with permission issues...${NC}"
                echo -e "${YELLOW}Note: You may encounter errors during conversion.${NC}"
                ;;
            4)
                echo -e "\n${CYAN}Exiting. Please fix permissions and try again.${NC}"
                exit 1
                ;;
            *)
                echo -e "\n${RED}Invalid choice. Continuing anyway...${NC}"
                ;;
        esac
    else
        if [[ "$silent_mode" != true ]]; then
            echo -e "${GREEN}âœ“ All permissions are correct${NC}"
        fi
    fi
    
    return $issues_found
}

# ðŸš¨ Robust error logging system
log_error() {
    # Don't show errors if user interrupted the script
    if [[ "$INTERRUPT_REQUESTED" == true ]]; then
        return 0
    fi
    
    local error_msg="$1"
    local file="$2"
    local detailed_error="$3"
    local line_num="$4"
    local func_name="$5"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Ensure log directory exists
    [[ ! -d "$(dirname "$ERROR_LOG")" ]] && mkdir -p "$(dirname "$ERROR_LOG")" 2>/dev/null
    
    # Comprehensive logging to file
    {
        echo "[$timestamp] ==================== ERROR ===================="
        echo "[$timestamp] MESSAGE: $error_msg"
        [[ -n "$file" ]] && echo "[$timestamp] FILE: $file"
        [[ -n "$line_num" ]] && echo "[$timestamp] LINE: $line_num"
        [[ -n "$func_name" ]] && echo "[$timestamp] FUNCTION: $func_name"
        [[ -n "$detailed_error" ]] && echo "[$timestamp] DETAILS: $detailed_error"
        echo "[$timestamp] PWD: $(pwd)"
        echo "[$timestamp] USER: $USER"
        echo "[$timestamp] SHELL: $SHELL"
        echo "[$timestamp] PID: $$"
        echo "[$timestamp] PPID: $PPID"
        echo "[$timestamp] ================================================"
        echo ""
    } >> "$ERROR_LOG" 2>/dev/null || {
        # Fallback to current directory if log directory fails
        echo "[$timestamp] ERROR: $error_msg" >> "./error-fallback.log" 2>/dev/null
    }
    
    # Only show errors in terminal if not in silent validation mode
    if [[ "$VALIDATION_SILENT_MODE" != "true" ]]; then
        {
            echo -e "\n${RED}${BOLD}ðŸ’¥ CRITICAL ERROR${NC}"
            echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
            echo -e "${RED}ðŸ“‹ Message: $error_msg${NC}"
            [[ -n "$file" ]] && echo -e "${RED}ðŸ“ File: $(basename -- "$file")${NC}"
            [[ -n "$line_num" ]] && echo -e "${RED}ðŸ“ Line: $line_num${NC}"
            [[ -n "$func_name" ]] && echo -e "${RED}âš™ï¸  Function: $func_name${NC}"
            [[ -n "$detailed_error" ]] && echo -e "${RED}ðŸ” Details: $detailed_error${NC}"
            echo -e "${YELLOW}ðŸ“‹ Full log: $ERROR_LOG${NC}"
            echo -e "${CYAN}ðŸ”§ Debug: tail -20 \"$ERROR_LOG\"${NC}"
            echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        } >&2
    fi
}

# âš ï¸ Log warnings (non-critical issues)
log_warning() {
    # Don't show warnings if user interrupted the script
    if [[ "$INTERRUPT_REQUESTED" == true ]]; then
        return 0
    fi
    
    local warning_msg="$1"
    local file="$2"
    local detailed_info="$3"
    local line_num="$4"
    local func_name="$5"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Ensure log directory exists
    [[ ! -d "$(dirname "$ERROR_LOG")" ]] && mkdir -p "$(dirname "$ERROR_LOG")" 2>/dev/null
    
    # Comprehensive logging to file
    {
        echo "[$timestamp] ==================== WARNING ===================="
        echo "[$timestamp] MESSAGE: $warning_msg"
        [[ -n "$file" ]] && echo "[$timestamp] FILE: $file"
        [[ -n "$line_num" ]] && echo "[$timestamp] LINE: $line_num"
        [[ -n "$func_name" ]] && echo "[$timestamp] FUNCTION: $func_name"
        [[ -n "$detailed_info" ]] && echo "[$timestamp] DETAILS: $detailed_info"
        echo "[$timestamp] ===================================================="
        echo ""
    } >> "$ERROR_LOG" 2>/dev/null || {
        # Fallback to current directory if log directory fails
        echo "[$timestamp] WARNING: $warning_msg" >> "./warning-fallback.log" 2>/dev/null
    }
    
    # Show warnings in terminal with less alarming format
    {
        echo -e "\n${YELLOW}${BOLD}âš ï¸ WARNING${NC}"
        echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo -e "${YELLOW}ðŸ“ Message: $warning_msg${NC}"
        [[ -n "$file" ]] && echo -e "${YELLOW}ðŸ“ File: $(basename -- "$file")${NC}"
        [[ -n "$line_num" ]] && echo -e "${YELLOW}ðŸ“ Line: $line_num${NC}"
        [[ -n "$func_name" ]] && echo -e "${YELLOW}âš™ï¸  Function: $func_name${NC}"
        [[ -n "$detailed_info" ]] && echo -e "${YELLOW}ðŸ” Details: $detailed_info${NC}"
        echo -e "${CYAN}ðŸ“‹ Full log: $ERROR_LOG${NC}"
        echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    } >&2
}

# ðŸ›¡ï¸ Robust crash handler
handle_crash() {
    local exit_code=$?
    local line_num=$1
    local func_name="${FUNCNAME[2]:-main}"
    local command="${BASH_COMMAND:-unknown}"
    
    log_error "Script crashed unexpectedly" "" "Command: $command, Exit code: $exit_code" "$line_num" "$func_name"
    
    echo -e "\n${RED}${BOLD}ðŸ’€ SCRIPT CRASHED${NC}" >&2
    echo -e "${RED}The script encountered a fatal error and had to stop.${NC}" >&2
    echo -e "${YELLOW}Check the error log for details: $ERROR_LOG${NC}" >&2
    echo -e "${CYAN}Recent errors: tail -10 \"$ERROR_LOG\"${NC}" >&2
    
    # Show last few lines of error log
    if [[ -f "$ERROR_LOG" ]]; then
        echo -e "\n${YELLOW}Last error entries:${NC}" >&2
        tail -5 "$ERROR_LOG" 2>/dev/null | while IFS= read -r line; do
            echo -e "  ${RED}$line${NC}" >&2
        done
    fi
    
    # Cleanup
    cleanup_temp_files "*" 2>/dev/null || true
    
    exit $exit_code
}

# ðŸ” Function call tracer for debugging
trace_function() {
    local func_name="$1"
    local timestamp=$(date '+%H:%M:%S')
    echo "[$timestamp] TRACE: Entering function $func_name" >> "$ERROR_LOG.trace" 2>/dev/null || true
}

# ðŸ§¾ Log a one-time settings snapshot for easier debugging
log_settings_snapshot_once() {
    if [[ -n "$__SETTINGS_SNAPSHOT_DONE" ]]; then return; fi
    __SETTINGS_SNAPSHOT_DONE=1
    local ts=$(date '+%Y-%m-%d %H:%M:%S')
    {
        echo "[$ts] ==================== SETTINGS SNAPSHOT ===================="
        echo "[$ts] QUALITY=$QUALITY FRAMERATE=$FRAMERATE RESOLUTION=$RESOLUTION ASPECT=$ASPECT_RATIO"
        echo "[$ts] MAX_COLORS=$MAX_COLORS DITHER=$DITHER_MODE SCALING=$SCALING_ALGO FORMAT=$OUTPUT_FORMAT"
        echo "[$ts] AUTO_OPTIMIZE=$AUTO_OPTIMIZE OPTIMIZE_AGGRESSIVE=$OPTIMIZE_AGGRESSIVE"
        echo "[$ts] PARALLEL_JOBS=$PARALLEL_JOBS FORCE_CONVERSION=$FORCE_CONVERSION"
        echo "[$ts] LOG DIR=$LOG_DIR SETTINGS_FILE=$SETTINGS_FILE"
        echo "[$ts] ============================================================="
        echo ""
    } >> "$ERROR_LOG" 2>/dev/null || true
}

# ðŸ§ª Get concise media info for logs (widthxheight @ fps, duration)
probe_media_brief() {
    local f="$1"
    local w h r d
    w=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$f" 2>/dev/null)
    h=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$f" 2>/dev/null)
    r=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of csv=p=0 "$f" 2>/dev/null | awk -F'/' '{if($2>0) printf("%.2f", $1/$2); else print $1}')
    d=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$f" 2>/dev/null | awk '{printf("%.2fs", $1)}')
    [[ -z "$w" || -z "$h" ]] && echo "unknown" && return
    echo "${w}x${h}@${r:-?} ${d:-?}"
}

# ðŸ“Š Smart GIF size estimation and optimization
estimate_and_optimize_gif_settings() {
    local file="$1"
    echo -e "  ${BLUE}ðŸ“ˆ Analyzing video for optimal GIF settings...${NC}"
    
    # Get video properties
    local duration=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$file" 2>/dev/null | awk '{printf("%.1f", $1)}')
    local width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$file" 2>/dev/null)
    local height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$file" 2>/dev/null)
    local input_size=$(stat -c%s -- "$file" 2>/dev/null || echo "1000000")
    
    # Convert to MB for easier calculation
    local input_size_mb=$((input_size / 1024 / 1024))
    [[ $input_size_mb -eq 0 ]] && input_size_mb=1
    
    # Estimate GIF size using empirical formula
    # GIF size â‰ˆ (width * height * fps * duration * colors) / compression_factor
    local current_fps=${FRAMERATE:-15}
    local current_colors=${MAX_COLORS:-256}
    local current_width=$(echo "$RESOLUTION" | cut -d':' -f1)
    local current_height=$(echo "$RESOLUTION" | cut -d':' -f2)
    
    # Use video dimensions if resolution not set
    [[ -z "$current_width" || "$current_width" == "$RESOLUTION" ]] && current_width=$width
    [[ -z "$current_height" || "$current_height" == "$RESOLUTION" ]] && current_height=$height
    
    # Estimated GIF size in MB (rough calculation)
    local estimated_size_mb=0
    if [[ -n "$duration" && "$duration" != "0" && -n "$current_width" && -n "$current_height" ]]; then
        # Formula: (width * height * fps * duration * colors) / (1024^2 * compression_factor)
        # Compression factor varies by content type (typically 8-20 for GIFs)
        estimated_size_mb=$(awk -v w="$current_width" -v h="$current_height" -v f="$current_fps" -v d="$duration" -v c="$current_colors" \
            'BEGIN { printf("%.0f", (w * h * f * d * c) / (1024 * 1024 * 12)) }')
    fi
    
    echo -e "    ${CYAN}Input: ${input_size_mb}MB, ${width}x${height}, ${duration}s${NC}"
    echo -e "    ${CYAN}Current settings: ${current_width}x${current_height}, ${current_fps}fps, ${current_colors} colors${NC}"
    echo -e "    ${YELLOW}Estimated GIF size: ~${estimated_size_mb}MB${NC}"
    
    # Always apply smart sizing for better GIF sizes
    local optimization_applied=false
    echo -e "    ${BLUE}ðŸ§  Applying smart size optimization...${NC}"
    
    # Aggressive resolution reduction for all content
    if [[ "$current_width" -gt 1920 ]]; then
        RESOLUTION="854:480"
        echo -e "      ${GREEN}âœ“ Reduced resolution to 854x480 (4K+ â†’ web-friendly)${NC}"
        optimization_applied=true
    elif [[ "$current_width" -gt 1280 ]]; then
        RESOLUTION="720:480"
        echo -e "      ${GREEN}âœ“ Reduced resolution to 720x480 (HD â†’ compact)${NC}"
        optimization_applied=true
    elif [[ "$current_width" -gt 854 ]]; then
        RESOLUTION="640:360"
        echo -e "      ${GREEN}âœ“ Reduced resolution to 640x360 (optimized for GIF)${NC}"
        optimization_applied=true
    fi
    
    # Smart framerate optimization based on content type
    if [[ "$input_size_mb" -lt 1 && "$current_width" -gt 1080 ]]; then
        # High-res artwork from small file - likely anime/static content
        if [[ "$current_fps" -gt 10 ]]; then
            FRAMERATE="8"
            echo -e "      ${GREEN}âœ“ Reduced framerate to 8fps (artwork optimized)${NC}"
            optimization_applied=true
        fi
        MAX_COLORS="64"
        echo -e "      ${GREEN}âœ“ Reduced colors to 64 (artwork optimized)${NC}"
        optimization_applied=true
    else
        # Regular content optimization
        if [[ "$current_fps" -gt 12 ]]; then
            FRAMERATE="10"
            echo -e "      ${GREEN}âœ“ Reduced framerate to 10fps (smooth playback)${NC}"
            optimization_applied=true
        fi
        if [[ "$current_colors" -gt 96 ]]; then
            MAX_COLORS="96"
            echo -e "      ${GREEN}âœ“ Reduced colors to 96 (balanced quality/size)${NC}"
            optimization_applied=true
        fi
    fi
    
    # Special handling for high-resolution content (likely anime/artwork)
    local is_high_res=false
    if [[ "$current_width" -gt 1080 && "$input_size_mb" -lt 2 ]]; then
        is_high_res=true
        echo -e "      ${YELLOW}ðŸŽ¨ High-resolution artwork detected${NC}"
        
        # Extra aggressive for artwork since it compresses very well
        if [[ "$current_colors" -gt 48 ]]; then
            MAX_COLORS="48"
            echo -e "      ${GREEN}âœ“ Reduced colors to 48 (artwork has fewer color variations)${NC}"
            optimization_applied=true
        fi
    fi
    
    # Recalculate estimated size
    if [[ "$optimization_applied" == true ]]; then
        local new_width=$(echo "$RESOLUTION" | cut -d':' -f1)
        local new_height=$(echo "$RESOLUTION" | cut -d':' -f2)
        estimated_size_mb=$(awk -v w="$new_width" -v h="$new_height" -v f="$FRAMERATE" -v d="$duration" -v c="$MAX_COLORS" \
            'BEGIN { printf("%.0f", (w * h * f * d * c) / (1024 * 1024 * 15)) }')
        echo -e "      ${GREEN}Smart-optimized estimated size: ~${estimated_size_mb}MB${NC}"
    fi
    
    # Apply optimizations if estimated size is too large
    if [[ "$estimated_size_mb" -gt "$MAX_GIF_SIZE_MB" ]]; then
        echo -e "    ${RED}âš ï¸  Estimated size (${estimated_size_mb}MB) exceeds limit (${MAX_GIF_SIZE_MB}MB)${NC}"
        echo -e "    ${BLUE}ðŸ”§ Applying automatic optimizations...${NC}"
        
        local optimization_applied=false
        
        # Step 1: Reduce resolution if too high
        if [[ "$current_width" -gt 1280 ]]; then
            RESOLUTION="1280:720"
            echo -e "      ${GREEN}âœ“ Reduced resolution to 1280x720${NC}"
            optimization_applied=true
        elif [[ "$current_width" -gt 854 ]]; then
            RESOLUTION="854:480"
            echo -e "      ${GREEN}âœ“ Reduced resolution to 854x480${NC}"
            optimization_applied=true
        fi
        
        # Step 2: Reduce framerate if too high
        if [[ "$current_fps" -gt 15 ]]; then
            FRAMERATE="12"
            echo -e "      ${GREEN}âœ“ Reduced framerate to 12fps${NC}"
            optimization_applied=true
        elif [[ "$current_fps" -gt 10 ]] && [[ "$estimated_size_mb" -gt $((MAX_GIF_SIZE_MB * 2)) ]]; then
            FRAMERATE="8"
            echo -e "      ${GREEN}âœ“ Reduced framerate to 8fps${NC}"
            optimization_applied=true
        fi
        
        # Step 3: Reduce color palette
        if [[ "$current_colors" -gt 128 ]]; then
            MAX_COLORS="128"
            echo -e "      ${GREEN}âœ“ Reduced colors to 128${NC}"
            optimization_applied=true
        elif [[ "$current_colors" -gt 64 ]] && [[ "$estimated_size_mb" -gt $((MAX_GIF_SIZE_MB * 3)) ]]; then
            MAX_COLORS="64"
            echo -e "      ${GREEN}âœ“ Reduced colors to 64${NC}"
            optimization_applied=true
        fi
        
        # Step 4: Clip duration if extremely long
        if [[ -n "$duration" ]] && awk -v d="$duration" 'BEGIN { exit (d > 30) }'; then
            echo -e "      ${YELLOW}âš ï¸  Video duration (${duration}s) is very long for GIF${NC}"
            echo -e "      ${BLUE}Consider using --duration-limit to clip the video${NC}"
        fi
        
        # Re-estimate size with new settings
        if [[ "$optimization_applied" == true ]]; then
            local new_width=$(echo "$RESOLUTION" | cut -d':' -f1)
            local new_height=$(echo "$RESOLUTION" | cut -d':' -f2)
            local new_estimated_size=$(awk -v w="$new_width" -v h="$new_height" -v f="$FRAMERATE" -v d="$duration" -v c="$MAX_COLORS" \
                'BEGIN { printf("%.0f", (w * h * f * d * c) / (1024 * 1024 * 12)) }')
            echo -e "      ${GREEN}New estimated size: ~${new_estimated_size}MB${NC}"
        fi
    else
        echo -e "    ${GREEN}âœ“ Estimated size looks reasonable${NC}"
    fi
    
    echo ""
}

# ðŸ¤– AI-lite analysis: crop, motion, and dynamic parameter tuning (no heavy deps)
# ðŸ¤– Advanced AI Video Analysis System
ai_smart_analyze() {
    local file="$1"
    local ai_log_ts=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Reset AI variables
    CROP_FILTER=""
    AI_CONTENT_CACHE=""
    
    echo -e "  ðŸ§  ${CYAN}Advanced AI Analysis Starting (${BOLD}$AI_MAX_PARALLEL_JOBS threads${NC}${CYAN})...${NC}"
    
    # Initialize AI training system
    init_ai_training
    local training_stats=$(get_ai_training_stats)
    echo -e "  ðŸ§  AI Training: $training_stats"
    
    # Check cache first for AI analysis
    local cached_ai_analysis=$(check_ai_cache "$file" 2>/dev/null)
    if [[ $? -eq 0 && -n "$cached_ai_analysis" ]]; then
        echo -e "  ðŸ—„ï¸ ${GREEN}Using cached AI analysis${NC}"
        # Parse cached analysis and restore AI variables
        restore_ai_analysis_from_cache "$cached_ai_analysis"
        echo -e "  âœ… ${GREEN}AI Analysis Complete (from cache)${NC}"
        return 0
    fi
    
    echo -e "  ðŸ”„ ${YELLOW}Performing fresh AI analysis...${NC}"
    
    # Get basic video properties first
    local video_info=$(get_video_properties "$file")
    local duration=$(echo "$video_info" | cut -d'|' -f1)
    local width=$(echo "$video_info" | cut -d'|' -f2) 
    local height=$(echo "$video_info" | cut -d'|' -f3)
    local fps=$(echo "$video_info" | cut -d'|' -f4)
    local bitrate=$(echo "$video_info" | cut -d'|' -f5)
    
    # Store original settings for training comparison
    local original_framerate="$FRAMERATE"
    local original_dither="$DITHER_MODE"
    local original_colors="$MAX_COLORS"
    
    # Multi-dimensional analysis based on AI_MODE
    case "$AI_MODE" in
        "smart")
            ai_smart_analysis "$file" "$duration" "$width" "$height" "$fps" "$bitrate"
            ;;
        "content")
            ai_content_analysis "$file" "$duration" "$width" "$height"
            ;;
        "motion")
            ai_motion_analysis "$file" "$duration"
            ;;
        "quality")
            ai_quality_analysis "$file" "$width" "$height" "$bitrate"
            ;;
        *)
            ai_smart_analysis "$file" "$duration" "$width" "$height" "$fps" "$bitrate"
            ;;
    esac
    
    # Log comprehensive AI decisions
    {
        echo "[$ai_log_ts] AI-ANALYSIS: mode=$AI_MODE file=$(basename -- "$file")"
        echo "[$ai_log_ts] AI-INPUT: duration=${duration}s resolution=${width}x${height} fps=$fps bitrate=$bitrate"
        echo "[$ai_log_ts] AI-OUTPUT: framerate=$FRAMERATE dither=$DITHER_MODE crop=${CROP_FILTER:-none} max_colors=$MAX_COLORS"
        [[ -n "$AI_CONTENT_CACHE" ]] && echo "[$ai_log_ts] AI-DETECTED: $AI_CONTENT_CACHE"
    } >> "$ERROR_LOG" 2>/dev/null || true
    
    # Save analysis results to cache for future runs
    save_ai_analysis_to_cache "$file"
    
    echo -e "  âœ… ${GREEN}AI Analysis Complete${NC}"
}

# ðŸ“Š Get comprehensive video properties with optimal threading
get_video_properties() {
    local file="$1"
    local properties
    local optimal_threads=$(get_optimal_threads "io" 1)
    
    # Use ffprobe to get detailed information with optimal threading
    if command -v jq >/dev/null 2>&1; then
        # Enhanced analysis with jq and optimized threading
        properties=$(ffprobe -v quiet -threads $optimal_threads -print_format json -show_format -show_streams "$file" 2>/dev/null)
        
        local duration=$(echo "$properties" | jq -r '.format.duration // "0"' | cut -d. -f1)
        local width=$(echo "$properties" | jq -r '.streams[0].width // "0"')
        local height=$(echo "$properties" | jq -r '.streams[0].height // "0"')
        local fps=$(echo "$properties" | jq -r '.streams[0].r_frame_rate // "0"' | cut -d'/' -f1)
        local bitrate=$(echo "$properties" | jq -r '.format.bit_rate // "0"')
        
        echo "${duration}|${width}|${height}|${fps}|${bitrate}"
    else
        # Fallback without jq but with optimal threading
        local duration=$(ffprobe -v error -threads $optimal_threads -show_entries format=duration -of csv=p=0 "$file" 2>/dev/null | cut -d. -f1)
        local width=$(ffprobe -v error -threads $optimal_threads -select_streams v:0 -show_entries stream=width -of csv=p=0 "$file" 2>/dev/null)
        local height=$(ffprobe -v error -threads $optimal_threads -select_streams v:0 -show_entries stream=height -of csv=p=0 "$file" 2>/dev/null)
        local fps=$(ffprobe -v error -threads $optimal_threads -select_streams v:0 -show_entries stream=r_frame_rate -of csv=p=0 "$file" 2>/dev/null | cut -d'/' -f1)
        local bitrate="0"
        
        echo "${duration:-0}|${width:-0}|${height:-0}|${fps:-0}|${bitrate}"
    fi
}

# ðŸ§  Smart AI Analysis (comprehensive)
ai_smart_analysis() {
    local file="$1" duration="$2" width="$3" height="$4" fps="$5" bitrate="$6"
    
    echo -e "    ðŸ” ${BLUE}Smart Analysis: Content + Motion + Quality${NC}"
    
    # 1. Content Type Detection
    local content_type=$(detect_content_type "$file" "$duration" "$width" "$height")
    AI_CONTENT_CACHE="content_type=$content_type"
    
    # 2. Motion Analysis
    local motion_level=$(analyze_motion_complexity "$file" "$duration")
    AI_CONTENT_CACHE+=" motion=$motion_level"
    
    # 3. Visual Complexity Analysis  
    local complexity_score=$(analyze_visual_complexity "$file")
    AI_CONTENT_CACHE+=" complexity=$complexity_score"
    
    # 4. AI-Powered Prediction (NEW!)
    local feature_pattern=$(extract_feature_pattern "$content_type" "$width" "$height" "$duration" "$motion_level" "$complexity_score")
    local ai_prediction=$(ai_predict_settings "$feature_pattern" 2>/dev/null)
    
    if [[ $? -eq 0 && -n "$ai_prediction" ]]; then
        local prediction_type=$(echo "$ai_prediction" | cut -d':' -f1)
        local confidence=$(echo "$ai_prediction" | cut -d':' -f2)
        local settings=$(echo "$ai_prediction" | cut -d':' -f3)
        
        echo -e "    ðŸ¤– ${GREEN}AI Prediction ($prediction_type, confidence: $confidence):${NC}"
        
        # Parse and apply AI-recommended settings
        IFS=':' read -ra ai_settings <<< "$settings"
        if [[ ${#ai_settings[@]} -ge 3 ]]; then
            echo -e "      ðŸŽ¯ Applying AI-learned settings..."
            FRAMERATE="${ai_settings[0]}"
            DITHER_MODE="${ai_settings[1]}"
            MAX_COLORS="${ai_settings[2]}"
            if [[ -n "${ai_settings[3]}" && "${ai_settings[3]}" != "none" ]]; then
                CROP_FILTER="${ai_settings[3]}"
            fi
            AI_CONTENT_CACHE+=" ai_applied=true"
            echo -e "      âœ… ${GREEN}AI settings applied: ${FRAMERATE}fps, ${DITHER_MODE} dither, ${MAX_COLORS} colors${NC}"
        fi
    else
        echo -e "    ðŸ¤– ${YELLOW}No AI prediction available (learning mode)${NC}"
        AI_CONTENT_CACHE+=" ai_applied=false"
    fi
    
    # 4. Intelligent Cropping
    local crop_result=$(intelligent_crop_detection "$file" "$width" "$height")
    if [[ "$crop_result" != "none" ]]; then
        CROP_FILTER="$crop_result"
        AI_CONTENT_CACHE+=" crop=applied"
    fi
    
    # 5. AI Speed Optimization
    ai_speed_optimizer "$file" "$motion_level" "content_type=$content_type complexity=$complexity_score"
    ai_performance_analysis "$file"
    
    # 6. Apply intelligent optimizations based on analysis
    apply_ai_optimizations "$content_type" "$motion_level" "$complexity_score" "$duration" "$width" "$height"
}

# ðŸŽ¨ Hyper-Optimized Content Type Detection with Multi-Threading
detect_content_type() {
    local file="$1" duration="$2" width="$3" height="$4"
    local cpu_threads=$(get_optimal_threads "cpu" 5)
    
    # Multi-stage parallel analysis for maximum performance
    local content_scores=()
    
    # Stage 1: Visual Pattern Analysis (optimized with maximum threads)
    local histogram_variance=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 6 -vf "histogram=level_height=150,scale=80:80:flags=fast_bilinear" -frames:v 8 -f null - 2>&1 | wc -l 2>/dev/null || echo "0")
    
    # Stage 2: Advanced Edge Detection with multiple thresholds (parallel processing)
    local edge_low=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 4 -vf "edgedetect=low=0.05:high=0.2:flags=fast_bilinear" -frames:v 6 -f null - 2>&1 | grep -c "frame=" 2>/dev/null || echo "0")
    local edge_high=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 4 -vf "edgedetect=low=0.2:high=0.6:flags=fast_bilinear" -frames:v 6 -f null - 2>&1 | grep -c "frame=" 2>/dev/null || echo "0")
    
    # Stage 3: Color Complexity Analysis (optimized)
    local color_stats=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 3 -vf "signalstats" -f null - 2>&1 | grep -E "YAVG=|UAVG=|VAVG=" | wc -l 2>/dev/null || echo "0")
    local color_range=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 3 -vf "signalstats" -f null - 2>&1 | grep -E "YMAX=|YMIN=" | wc -l 2>/dev/null || echo "0")
    
    # Stage 4: Motion Vector Analysis (accelerated)
    local motion_vectors=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 5 -vf "select='gt(scene,0.1)',showinfo" -f null - 2>&1 | grep -c "scene:" 2>/dev/null || echo "0")
    
    # Stage 5: Frame Rate Pattern Analysis (optimized)
    local fps_consistency=$(ffmpeg -v error -threads $cpu_threads -i "$file" -t 3 -vf "select='not(mod(n,4))',showinfo" -f null - 2>&1 | grep -c "pkt_pts_time=" 2>/dev/null || echo "0")
    
    # Sanitize and normalize values
    histogram_variance=${histogram_variance//[^0-9]/}; histogram_variance=${histogram_variance:-0}
    edge_low=${edge_low//[^0-9]/}; edge_low=${edge_low:-0}
    edge_high=${edge_high//[^0-9]/}; edge_high=${edge_high:-0}
    color_stats=${color_stats//[^0-9]/}; color_stats=${color_stats:-0}
    color_range=${color_range//[^0-9]/}; color_range=${color_range:-0}
    motion_vectors=${motion_vectors//[^0-9]/}; motion_vectors=${motion_vectors:-0}
    fps_consistency=${fps_consistency//[^0-9]/}; fps_consistency=${fps_consistency:-0}
    
    # AI-inspired scoring system
    local animation_score=0
    local screencast_score=0
    local movie_score=0
    local clip_score=0
    
    # Animation detection (high edge density, consistent colors, smooth motion)
    if [[ $edge_high -gt 12 && $color_stats -gt 15 && $fps_consistency -gt 8 ]]; then
        ((animation_score += 30))
    fi
    if [[ $histogram_variance -gt 8 && $motion_vectors -lt 4 ]]; then
        ((animation_score += 20))
    fi
    
    # Screencast detection (sharp edges, limited colors, static elements)
    if [[ $edge_low -gt 15 && $color_range -lt 8 && $motion_vectors -lt 3 ]]; then
        ((screencast_score += 35))
    fi
    if [[ $width -ge 1280 && $height -ge 720 && $fps_consistency -lt 5 ]]; then
        ((screencast_score += 15))
    fi
    
    # Movie detection (complex color patterns, natural motion, high resolution)
    if [[ $color_stats -gt 20 && $color_range -gt 10 && $motion_vectors -gt 5 ]]; then
        ((movie_score += 25))
    fi
    if [[ $width -ge 1920 && $height -ge 1080 && $duration -gt 60 ]]; then
        ((movie_score += 20))
    fi
    if [[ $histogram_variance -gt 15 && $edge_low -lt 10 ]]; then
        ((movie_score += 15))
    fi
    
    # Clip detection (short duration, variable motion, mixed patterns)
    if [[ $duration -lt 30 && $motion_vectors -gt 3 && $motion_vectors -lt 8 ]]; then
        ((clip_score += 25))
    fi
    if [[ $fps_consistency -gt 6 && $color_stats -gt 8 && $color_stats -lt 18 ]]; then
        ((clip_score += 20))
    fi
    
    # Determine content type based on highest score
    local max_score=0
    local content_type="clip"  # default fallback
    
    if [[ $animation_score -gt $max_score ]]; then
        max_score=$animation_score
        content_type="animation"
    fi
    if [[ $screencast_score -gt $max_score ]]; then
        max_score=$screencast_score
        content_type="screencast"
    fi
    if [[ $movie_score -gt $max_score ]]; then
        max_score=$movie_score
        content_type="movie"
    fi
    if [[ $clip_score -gt $max_score ]]; then
        max_score=$clip_score
        content_type="clip"
    fi
    
    # Confidence-based fallback for low scores
    if [[ $max_score -lt 25 ]]; then
        # Fallback to basic heuristics
        if [[ $width -ge 1920 && $height -ge 1080 && $duration -gt 300 ]]; then
            content_type="movie"
        elif [[ $duration -lt 15 ]]; then
            content_type="clip"
        elif [[ $width -ge 1280 && $color_range -lt 6 ]]; then
            content_type="screencast"
        else
            content_type="animation"
        fi
    fi
    
    echo "$content_type"
}

# ðŸ’¨ Advanced Motion Analysis
analyze_motion_complexity() {
    local file="$1" duration="$2"
    local sample_duration=$((duration > 30 ? 30 : duration))
    
    # Multi-stage motion analysis
    local scene_changes
    scene_changes=$(ffmpeg -v error -i "$file" -t $sample_duration -vf "select=gt(scene\,0.12)" -vsync vfr -f null - 2>&1 | grep -c "frame=" || echo "0")
    
    # Motion vector analysis (if available)
    local motion_vectors=0
    if ffmpeg -v error -f lavfi -i testsrc=duration=1:size=320x240:rate=1 -c:v libx264 -f null - 2>/dev/null; then
        motion_vectors=$(ffmpeg -v error -i "$file" -t 5 -vf "mestimate=epzs,showinfo" -f null - 2>&1 | grep -c "pos:" || echo "0")
    fi
    
    # Classify motion level
    # Ensure numeric values
    scene_changes=${scene_changes//[^0-9]/}
    motion_vectors=${motion_vectors//[^0-9]/}
    scene_changes=${scene_changes:-0}
    motion_vectors=${motion_vectors:-0}
    
    local total_motion_score=$((scene_changes + motion_vectors / 10))
    
    if [[ $total_motion_score -gt 20 ]]; then
        echo "high"
    elif [[ $total_motion_score -gt 8 ]]; then
        echo "medium"
    elif [[ $total_motion_score -gt 2 ]]; then
        echo "low"
    else
        echo "static"
    fi
}

# ðŸ” Visual Complexity Analysis
analyze_visual_complexity() {
    local file="$1"
    
    # Analyze visual complexity using multiple metrics
    local complexity_metrics
    complexity_metrics=$(ffmpeg -v error -i "$file" -t 8 -vf "signalstats,metadata=print" -f null - 2>&1 | grep -E "YAVG|UAVG|VAVG" | wc -l)
    
    # Texture analysis through noise detection
    local noise_level
    noise_level=$(ffmpeg -v error -i "$file" -t 5 -vf "noise=c0s=7:allf=t,signalstats" -f null - 2>&1 | grep -c "YAVG" || echo "0")
    
    # Calculate complexity score (0-100)
    # Ensure numeric values
    complexity_metrics=${complexity_metrics//[^0-9]/}
    noise_level=${noise_level//[^0-9]/}
    complexity_metrics=${complexity_metrics:-0}
    noise_level=${noise_level:-0}
    
    local complexity_score=$(((complexity_metrics * 10 + noise_level * 5) / 2))
    [[ $complexity_score -gt 100 ]] && complexity_score=100
    
    echo "$complexity_score"
}

# âœ‚ï¸ Intelligent Crop Detection
intelligent_crop_detection() {
    local file="$1" width="$2" height="$3"
    
    # Advanced crop detection with multiple samples
    local crop_samples=()
    local sample_times=("3" "25%" "50%" "75%")
    
    for sample_time in "${sample_times[@]}"; do
        local crop_line
        crop_line=$(ffmpeg -v error -ss "$sample_time" -i "$file" -t 1 -vf "cropdetect=24:16:0" -f null - 2>&1 | grep -o "crop=[0-9]*:[0-9]*:[0-9]*:[0-9]*" | tail -1)
        [[ -n "$crop_line" ]] && crop_samples+=("$crop_line")
    done
    
    # Find the most conservative crop (keeps most content)
    local best_crop="none"
    local best_area=0
    
    for crop in "${crop_samples[@]}"; do
        local cw=$(echo "$crop" | cut -d'=' -f2 | cut -d: -f1)
        local ch=$(echo "$crop" | cut -d'=' -f2 | cut -d: -f2)
        local area=$((cw * ch))
        
        # Only accept crops that preserve at least 70% of original area
        local original_area=$((width * height))
        local area_ratio=$((area * 100 / original_area))
        
        if [[ $area_ratio -ge 70 && $area -gt $best_area ]]; then
            best_crop="$crop"
            best_area=$area
        fi
    done
    
    echo "$best_crop"
}

# ðŸŽ¬ Advanced Scene Detection and Analysis
ai_scene_detection() {
    local file="$1" duration="$2"
    local sample_duration=$((duration > 60 ? 60 : duration))
    
    echo -e "      ðŸŽ¬ ${BLUE}Analyzing scene transitions and visual patterns...${NC}"
    
    # Detect scene changes with multiple thresholds
    local major_scenes=$(ffmpeg -v error -i "$file" -t $sample_duration -vf "select=gt(scene\,0.25)" -vsync vfr -f null - 2>&1 | grep -c "frame=" || echo "0")
    local minor_scenes=$(ffmpeg -v error -i "$file" -t $sample_duration -vf "select=gt(scene\,0.12)" -vsync vfr -f null - 2>&1 | grep -c "frame=" || echo "0")
    
    # Analyze frame consistency for optimal frame rate
    local frame_consistency=$(ffmpeg -v error -i "$file" -t 10 -vf "select='not(mod(n\,3))',showinfo" -f null - 2>&1 | grep -c "pkt_pts_time=" || echo "0")
    
    # Detect static regions (useful for optimizing GIF size)
    local static_regions=$(ffmpeg -v error -i "$file" -t 15 -vf "select='lt(scene\,0.003)',showinfo" -f null - 2>&1 | grep -c "pkt_pts_time=" || echo "0")
    
    # Clean numeric values
    major_scenes=${major_scenes//[^0-9]/}; major_scenes=${major_scenes:-0}
    minor_scenes=${minor_scenes//[^0-9]/}; minor_scenes=${minor_scenes:-0}
    frame_consistency=${frame_consistency//[^0-9]/}; frame_consistency=${frame_consistency:-0}
    static_regions=${static_regions//[^0-9]/}; static_regions=${static_regions:-0}
    
    # Calculate scene complexity score
    local scene_density=0
    [[ $sample_duration -gt 0 ]] && scene_density=$((major_scenes * 100 / sample_duration))
    local transition_smoothness=$((minor_scenes - major_scenes))
    local static_ratio=$((static_regions * 100 / (frame_consistency + 1)))
    
    # Return scene analysis results
    echo "${scene_density}|${transition_smoothness}|${static_ratio}"
}

# ðŸ“Š Smart Frame Rate Optimization
ai_smart_framerate_adjustment() {
    local file="$1" duration="$2" motion_level="$3" scene_data="$4"
    
    echo -e "      ðŸ“Š ${BLUE}Optimizing frame rate based on motion and scene analysis...${NC}"
    
    # Parse scene data
    local scene_density="${scene_data%%|*}"
    local temp_data="${scene_data#*|}"
    local transition_smoothness="${temp_data%%|*}"
    local static_ratio="${scene_data##*|}"
    
    # Ensure numeric values
    scene_density=${scene_density//[^0-9]/}; scene_density=${scene_density:-0}
    transition_smoothness=${transition_smoothness//[^0-9-]/}; transition_smoothness=${transition_smoothness:-0}
    static_ratio=${static_ratio//[^0-9]/}; static_ratio=${static_ratio:-0}
    
    # Base frame rate selection
    local optimal_fps=12
    
    # Adjust based on motion level
    case "$motion_level" in
        "high")
            optimal_fps=18
            [[ $scene_density -gt 15 ]] && optimal_fps=20
            ;;
        "medium")
            optimal_fps=15
            [[ $transition_smoothness -gt 10 ]] && optimal_fps=16
            ;;
        "low")
            optimal_fps=12
            [[ $static_ratio -gt 60 ]] && optimal_fps=10
            ;;
        "static")
            optimal_fps=8
            [[ $static_ratio -gt 80 ]] && optimal_fps=6
            ;;
    esac
    
    # Content duration adjustments
    if [[ $duration -gt 180 ]]; then
        # Long content - reduce fps to manage size
        optimal_fps=$((optimal_fps - 2))
        [[ $optimal_fps -lt 6 ]] && optimal_fps=6
    elif [[ $duration -lt 5 ]]; then
        # Very short content - can afford higher fps
        optimal_fps=$((optimal_fps + 4))
        [[ $optimal_fps -gt 24 ]] && optimal_fps=24
    fi
    
    echo "$optimal_fps"
}

# ðŸ”§ Intelligent Quality Scaling
ai_intelligent_quality_scaling() {
    local file="$1" width="$2" height="$3" complexity_score="$4" content_type="$5"
    
    echo -e "      ðŸ”§ ${BLUE}Calculating optimal quality parameters...${NC}"
    
    local total_pixels=$((width * height))
    local base_colors=128
    local scaling_quality="bicubic"
    
    # Adjust color palette based on visual complexity and content type
    if [[ $complexity_score -gt 80 ]]; then
        base_colors=256  # High complexity needs more colors
    elif [[ $complexity_score -gt 60 ]]; then
        base_colors=192
    elif [[ $complexity_score -gt 40 ]]; then
        base_colors=128
    elif [[ $complexity_score -gt 20 ]]; then
        base_colors=96
    else
        base_colors=64   # Low complexity can use fewer colors
    fi
    
    # Content-specific adjustments
    case "$content_type" in
        "animation")
            base_colors=$((base_colors + 32))  # Animations benefit from more colors
            scaling_quality="lanczos"
            ;;
        "screencast")
            base_colors=$((base_colors - 16))  # Screencasts have limited color palette
            scaling_quality="neighbor"  # Preserve sharp edges
            ;;
        "movie")
            # Keep base colors as calculated
            scaling_quality="bicubic"
            ;;
        "clip")
            base_colors=$((base_colors + 16))  # Short clips can afford more colors
            scaling_quality="lanczos"
            ;;
    esac
    
    # Resolution-based scaling quality
    if [[ $total_pixels -ge 8294400 ]]; then  # 4K+
        scaling_quality="lanczos"  # Best quality for downscaling
    elif [[ $total_pixels -le 307200 ]]; then  # 480p or lower
        scaling_quality="neighbor"  # Preserve low-res content
    fi
    
    # Cap colors at reasonable limits
    [[ $base_colors -gt 256 ]] && base_colors=256
    [[ $base_colors -lt 32 ]] && base_colors=32
    
    echo "${base_colors}|${scaling_quality}"
}

# âœ‚ï¸ Enhanced Intelligent Crop with AI Analysis
ai_enhanced_crop_detection() {
    local file="$1" width="$2" height="$3" content_type="$4"
    
    echo -e "      âœ‚ï¸ ${BLUE}AI crop analysis for optimal framing...${NC}"
    
    # Content-aware crop detection
    local crop_samples=()
    local sample_strategy=()
    
    # Different sampling strategies based on content type
    case "$content_type" in
        "movie"|"clip")
            # Sample more frequently for dynamic content
            sample_strategy=("5" "15%" "30%" "50%" "70%" "85%")
            ;;
        "screencast")
            # Fewer samples for static content
            sample_strategy=("10%" "50%" "90%")
            ;;
        "animation")
            # Sample at quarter intervals
            sample_strategy=("25%" "50%" "75%")
            ;;
        *)
            # Default sampling
            sample_strategy=("3" "25%" "50%" "75%")
            ;;
    esac
    
    for sample_time in "${sample_strategy[@]}"; do
        # Use more sensitive detection for different content types
        local sensitivity="24:16:0"
        [[ "$content_type" == "screencast" ]] && sensitivity="12:8:0"
        [[ "$content_type" == "animation" ]] && sensitivity="32:24:0"
        
        local crop_line
        crop_line=$(ffmpeg -v error -ss "$sample_time" -i "$file" -t 1 -vf "cropdetect=$sensitivity" -f null - 2>&1 | grep -o "crop=[0-9]*:[0-9]*:[0-9]*:[0-9]*" | tail -1)
        [[ -n "$crop_line" ]] && crop_samples+=("$crop_line")
    done
    
    # Smart crop selection based on consistency and area preservation
    declare -A crop_frequency
    local best_crop="none"
    local max_frequency=0
    
    # Count frequency of similar crops
    for crop in "${crop_samples[@]}"; do
        ((crop_frequency["$crop"]++))
        if [[ ${crop_frequency["$crop"]} -gt $max_frequency ]]; then
            # Validate crop preserves enough content
            local cw=$(echo "$crop" | cut -d'=' -f2 | cut -d: -f1)
            local ch=$(echo "$crop" | cut -d'=' -f2 | cut -d: -f2)
            local area=$((cw * ch))
            local original_area=$((width * height))
            local area_ratio=$((area * 100 / original_area))
            
            # Accept crop if it preserves at least 75% of original area
            if [[ $area_ratio -ge 75 ]]; then
                max_frequency=${crop_frequency["$crop"]}
                best_crop="$crop"
            fi
        fi
    done
    
    echo "$best_crop"
}

# âš™ï¸ Enhanced AI-based Optimizations with Advanced Features
apply_ai_optimizations() {
    local content_type="$1" motion_level="$2" complexity_score="$3" duration="$4" width="$5" height="$6"
    
    echo -e "    ðŸ¤– ${MAGENTA}Applying advanced AI optimizations for $content_type content${NC}"
    
    # Stage 1: Advanced scene analysis
    local scene_data=$(ai_scene_detection "$1" "$duration")
    
    # Stage 2: Smart frame rate optimization
    local optimal_fps=$(ai_smart_framerate_adjustment "$1" "$duration" "$motion_level" "$scene_data")
    FRAMERATE="$optimal_fps"
    
    # Stage 3: Intelligent quality scaling
    local quality_data=$(ai_intelligent_quality_scaling "$1" "$width" "$height" "$complexity_score" "$content_type")
    local suggested_colors="${quality_data%%|*}"
    local suggested_scaling="${quality_data##*|}"
    MAX_COLORS="$suggested_colors"
    SCALING_ALGO="$suggested_scaling"
    
    # Stage 4: Enhanced crop detection
    local enhanced_crop=$(ai_enhanced_crop_detection "$1" "$width" "$height" "$content_type")
    if [[ "$enhanced_crop" != "none" ]]; then
        CROP_FILTER="$enhanced_crop"
        AI_CONTENT_CACHE+=" enhanced_crop=applied"
    fi
    
    # Content-specific optimizations
    case "$content_type" in
        "animation")
            # Animations benefit from higher color count and specific dithering
            MAX_COLORS="192"
            DITHER_MODE="floyd"
            [[ "$motion_level" == "high" ]] && FRAMERATE="16" || FRAMERATE="12"
            ;;
        "screencast")
            # Screencasts need crisp text, lower FPS OK
            MAX_COLORS="128"
            DITHER_MODE="none"
            FRAMERATE="8"
            SCALING_ALGO="neighbor"  # Preserve pixel-perfect scaling
            ;;
        "movie")
            # Movies benefit from motion-adaptive settings
            case "$motion_level" in
                "high") FRAMERATE="18"; DITHER_MODE="floyd"; MAX_COLORS="256" ;;
                "medium") FRAMERATE="15"; DITHER_MODE="bayer"; MAX_COLORS="192" ;;
                "low") FRAMERATE="12"; DITHER_MODE="bayer"; MAX_COLORS="128" ;;
                "static") FRAMERATE="8"; DITHER_MODE="none"; MAX_COLORS="96" ;;
            esac
            ;;
        "clip")
            # Short clips can afford higher quality
            MAX_COLORS="256"
            FRAMERATE="20"
            DITHER_MODE="floyd"
            ;;
        *)
            # General content - balanced approach
            case "$motion_level" in
                "high") FRAMERATE="15"; DITHER_MODE="floyd"; MAX_COLORS="192" ;;
                "medium") FRAMERATE="12"; DITHER_MODE="bayer"; MAX_COLORS="128" ;;
                "low") FRAMERATE="10"; DITHER_MODE="bayer"; MAX_COLORS="96" ;;
                "static") FRAMERATE="8"; DITHER_MODE="none"; MAX_COLORS="64" ;;
            esac
            ;;
    esac
    
    # Resolution-based adjustments
    if [[ $width -ge 3840 || $height -ge 2160 ]]; then
        # 4K content - aggressive size reduction
        RESOLUTION="1280:720"
        MAX_COLORS=$((MAX_COLORS * 75 / 100))
    elif [[ $width -ge 1920 || $height -ge 1080 ]]; then
        # 1080p content - moderate reduction
        RESOLUTION="1280:720"
    elif [[ $width -le 854 && $height -le 480 ]]; then
        # Low resolution - preserve or slightly upscale
        RESOLUTION="854:480"
    fi
    
    # Complexity-based adjustments
    if [[ $complexity_score -gt 80 ]]; then
        # Very complex - need more colors
        MAX_COLORS=$((MAX_COLORS + 32))
        [[ $MAX_COLORS -gt 256 ]] && MAX_COLORS=256
    elif [[ $complexity_score -lt 20 ]]; then
        # Simple content - can use fewer colors
        MAX_COLORS=$((MAX_COLORS - 32))
        [[ $MAX_COLORS -lt 32 ]] && MAX_COLORS=32
    fi
    
    # Duration-based adjustments
    if [[ $duration -gt 300 ]]; then
        # Very long content - prioritize size
        FRAMERATE=$((FRAMERATE - 2))
        [[ $FRAMERATE -lt 6 ]] && FRAMERATE=6
        MAX_COLORS=$((MAX_COLORS * 90 / 100))
    elif [[ $duration -lt 5 ]]; then
        # Very short - can afford quality
        FRAMERATE=$((FRAMERATE + 4))
        [[ $FRAMERATE -gt 30 ]] && FRAMERATE=30
    fi
}

# ðŸŽ¨ Content-focused Analysis Mode
ai_content_analysis() {
    local file="$1" duration="$2" width="$3" height="$4"
    
    echo -e "    ðŸŽ¨ ${BLUE}Content Analysis Mode${NC}"
    
    local content_type=$(detect_content_type "$file" "$duration" "$width" "$height")
    AI_CONTENT_CACHE="focused_content_analysis=$content_type"
    
    # Apply content-specific optimizations only
    apply_ai_optimizations "$content_type" "medium" "50" "$duration" "$width" "$height"
}

# ðŸ’¨ Motion-focused Analysis Mode  
ai_motion_analysis() {
    local file="$1" duration="$2"
    
    echo -e "    ðŸ’¨ ${BLUE}Motion Analysis Mode${NC}"
    
    local motion_level=$(analyze_motion_complexity "$file" "$duration")
    AI_CONTENT_CACHE="focused_motion_analysis=$motion_level"
    
    # Apply motion-specific optimizations
    case "$motion_level" in
        "high") FRAMERATE="20"; DITHER_MODE="floyd"; MAX_COLORS="256" ;;
        "medium") FRAMERATE="15"; DITHER_MODE="bayer"; MAX_COLORS="192" ;;
        "low") FRAMERATE="12"; DITHER_MODE="bayer"; MAX_COLORS="128" ;;
        "static") FRAMERATE="8"; DITHER_MODE="none"; MAX_COLORS="96" ;;
    esac
}

# ðŸŽ¨ Enhanced AI-Powered Quality Selection with Intelligent Optimization
ai_quality_selection() {
    echo -e "${CYAN}${BOLD}ðŸŽ¯ AI-DRIVEN QUALITY SELECTION${NC}\n"
    echo -e "${YELLOW}ðŸ§  AI will analyze your videos and suggest the optimal quality level!${NC}\n"
    
    # Pre-analyze first video to provide intelligent recommendations
    local video_files=()
    shopt -s nullglob
    for ext in mp4 avi mov mkv webm; do
        video_files+=(*."$ext")
    done
    shopt -u nullglob
    
    local ai_recommendation="high"  # default fallback
    local recommendation_reason=""
    
    # ðŸ–¥ï¸ Detect system capabilities for intelligent recommendations
    echo -e "${BLUE}ðŸ–¥ï¸  Analyzing system capabilities...${NC}"
    
    local system_score=0
    local system_factors=()
    
    # Progress tracking
    local detection_steps=6  # Updated to match actual steps
    local current_step=0
    
    # Helper function to show detection progress
    show_detection_progress() {
        local step_name="$1"
        ((current_step++))
        local progress=$((current_step * 100 / detection_steps))
        local filled=$((progress * 20 / 100))
        local empty=$((20 - filled))
        
        # Hide cursor at start of first progress update
        if [[ $current_step -eq 1 ]]; then
            tput civis 2>/dev/null || printf "\033[?25l"
        fi
        
        # Get terminal width and calculate available space for text
        local term_width=$(tput cols 2>/dev/null || echo "80")
        # Actual visible characters: "  [" (3) + bar (20) + "] " (2) + "100% " (5) = 30 chars
        # Reserve extra space to prevent wrapping (safety margin)
        local available_width=$((term_width - 35))
        # Ensure reasonable bounds
        [[ $available_width -lt 15 ]] && available_width=15
        [[ $available_width -gt 40 ]] && available_width=40
        
        # Truncate step name if too long
        local display_name="$step_name"
        if [[ ${#step_name} -gt $available_width ]]; then
            display_name="${step_name:0:$((available_width-3))}..."
        fi
        
        # Clear the entire line first to prevent text artifacts
        printf "\r\033[K"
        
        # Print progress bar with dynamic-width text
        printf "  ${CYAN}["
        for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((i=0; i<empty; i++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}%s${NC}" "$progress" "$display_name"
        
        # Show cursor and move to new line when complete
        if [[ "$step_name" == "Complete!" ]]; then
            tput cnorm 2>/dev/null || printf "\033[?25h"
        else
            # Brief pause to make progress visible
            sleep 0.1
        fi
    }
    
    # ðŸŽ¯ Try inxi first - comprehensive hardware detection tool
    local use_inxi=false
    local inxi_cpu_info=""
    local inxi_memory_info=""
    local inxi_gpu_info=""
    local inxi_disk_info=""
    
    if command -v inxi >/dev/null 2>&1; then
        use_inxi=true
        show_detection_progress "Detecting hardware with inxi..."
        
        # Intelligent inxi flag selection based on what we need:
        # -C = CPU (cores, model, speed, cache)
        # -m = Memory (size, type, speed)
        # -G = Graphics (GPU model, driver)
        # -D = Drives (type, model, size)
        # -b = Basic output (faster, less verbose)
        # -c 0 = No color codes (cleaner parsing)
        
        # Get CPU info: cores, model, frequency, cache
        inxi_cpu_info=$(inxi -C -c 0 2>/dev/null)
        
        # Get Memory info: total RAM, type, speed
        inxi_memory_info=$(inxi -m -c 0 2>/dev/null)
        
        # Get GPU info: model, driver
        inxi_gpu_info=$(inxi -G -c 0 2>/dev/null)
        
        # Get Disk info: SSD/HDD detection
        inxi_disk_info=$(inxi -D -c 0 2>/dev/null)
    else
        show_detection_progress "Detecting hardware (standard tools)..."
    fi
    
    # Enhanced CPU detection with frequency and model info
    show_detection_progress "Analyzing CPU..."
    local cpu_model=""
    local cpu_freq_mhz=0
    local cpu_cores_detected=0
    
    # Parse inxi CPU info if available
    if [[ "$use_inxi" == "true" && -n "$inxi_cpu_info" ]]; then
        # Extract CPU model from inxi output
        # Example: "CPU: 16-core AMD Ryzen 9 5950X (32-thread) @ 3.4GHz"
        cpu_model=$(echo "$inxi_cpu_info" | grep -oP 'CPU:.*?(?=\(|@|$)' | sed 's/CPU:[[:space:]]*//g' | sed 's/[0-9]*-core[[:space:]]*//g' | sed 's/[[:space:]]*$//')
        
        # Extract core count from inxi
        cpu_cores_detected=$(echo "$inxi_cpu_info" | grep -oP '[0-9]+-core' | grep -oP '[0-9]+' | head -1)
        [[ -n "$cpu_cores_detected" ]] && CPU_CORES=$cpu_cores_detected
        
        # Extract frequency (convert GHz to MHz)
        local cpu_freq_ghz=$(echo "$inxi_cpu_info" | grep -oP '@[[:space:]]*[0-9.]+\s*GHz' | grep -oP '[0-9.]+' | head -1)
        if [[ -n "$cpu_freq_ghz" ]]; then
            cpu_freq_mhz=$(echo "$cpu_freq_ghz * 1000" | bc 2>/dev/null | cut -d. -f1)
        fi
    fi
    
    # Fallback: Try to get CPU model from lscpu (no sudo needed)
    if [[ -z "$cpu_model" ]] && command -v lscpu >/dev/null 2>&1; then
        cpu_model=$(lscpu | grep "Model name:" | sed 's/Model name:[[:space:]]*//g' | head -1)
        [[ -z "$cpu_freq_mhz" || "$cpu_freq_mhz" == "0" ]] && cpu_freq_mhz=$(lscpu | grep "CPU max MHz:" | awk '{print $NF}' | cut -d. -f1)
        # Fallback to current MHz if max not available
        [[ -z "$cpu_freq_mhz" || "$cpu_freq_mhz" == "0" ]] && cpu_freq_mhz=$(lscpu | grep "CPU MHz:" | awk '{print $NF}' | cut -d. -f1)
    fi
    
    # Alternative: read from /proc/cpuinfo
    if [[ -z "$cpu_model" && -r /proc/cpuinfo ]]; then
        cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | sed 's/^[[:space:]]*//g')
    fi
    
    # Score based on CPU cores and frequency
    if [[ $CPU_CORES -ge 16 ]]; then
        system_score=$((system_score + 35))
        system_factors+=("${CPU_CORES}-core CPU")
    elif [[ $CPU_CORES -ge 12 ]]; then
        system_score=$((system_score + 30))
        system_factors+=("${CPU_CORES}-core CPU")
    elif [[ $CPU_CORES -ge 8 ]]; then
        system_score=$((system_score + 20))
        system_factors+=("${CPU_CORES}-core CPU")
    elif [[ $CPU_CORES -ge 4 ]]; then
        system_score=$((system_score + 10))
    fi
    
    # Bonus for high-frequency CPUs (3.5GHz+)
    if [[ $cpu_freq_mhz -ge 3500 ]]; then
        system_score=$((system_score + 10))
    elif [[ $cpu_freq_mhz -ge 3000 ]]; then
        system_score=$((system_score + 5))
    fi
    
    # Detect high-performance CPU brands/models
    if [[ -n "$cpu_model" ]]; then
        if echo "$cpu_model" | grep -qiE "(ryzen 9|ryzen 7|i9|i7|threadripper|xeon|epyc)"; then
            system_score=$((system_score + 15))
            # Extract short CPU name for display
            local cpu_short=$(echo "$cpu_model" | sed -E 's/.*(Ryzen [0-9]|Core i[0-9]|Threadripper|Xeon|EPYC).*/\1/I' | head -c 20)
            [[ -n "$cpu_short" && "$cpu_short" != "$cpu_model" ]] && system_factors+=("$cpu_short")
        fi
    fi
    
    # Enhanced RAM detection with speed info
    show_detection_progress "Analyzing memory..."
    local total_ram_mb=0
    local ram_speed_mhz=0
    
    # Parse inxi memory info if available
    if [[ "$use_inxi" == "true" && -n "$inxi_memory_info" ]]; then
        # Extract total RAM from inxi output
        # Example: "RAM: 32 GiB (2 x 16 GiB) DDR4 3200 MHz"
        local ram_size_str=$(echo "$inxi_memory_info" | grep -oP 'RAM:[[:space:]]*[0-9.]+\s*(GiB|GB|MiB|MB)' | grep -oP '[0-9.]+\s*(GiB|GB|MiB|MB)')
        
        if [[ -n "$ram_size_str" ]]; then
            local ram_value=$(echo "$ram_size_str" | grep -oP '[0-9.]+')
            local ram_unit=$(echo "$ram_size_str" | grep -oP '(GiB|GB|MiB|MB)')
            
            # Convert to MB
            case "$ram_unit" in
                "GiB"|"GB")
                    total_ram_mb=$(echo "$ram_value * 1024" | bc 2>/dev/null | cut -d. -f1)
                    ;;
                "MiB"|"MB")
                    total_ram_mb=$(echo "$ram_value" | cut -d. -f1)
                    ;;
            esac
        fi
        
        # Extract RAM speed from inxi
        ram_speed_mhz=$(echo "$inxi_memory_info" | grep -oP 'DDR[0-9][[:space:]]*[0-9]+' | grep -oP '[0-9]+$' | head -1)
    fi
    
    # Fallback: Use free command
    if [[ $total_ram_mb -eq 0 ]] && command -v free >/dev/null 2>&1; then
        total_ram_mb=$(free -m | awk '/^Mem:/ {print $2}')
    fi
    
    # Fallback: Try to get RAM speed from dmidecode without sudo (may work on some systems)
    if [[ $ram_speed_mhz -eq 0 ]] && command -v dmidecode >/dev/null 2>&1; then
        ram_speed_mhz=$(dmidecode -t memory 2>/dev/null | grep "Speed:" | grep -oE '[0-9]+' | head -1 || echo "0")
    fi
    
    # Score based on total RAM
    if [[ $total_ram_mb -ge 65536 ]]; then  # 64GB+
        system_score=$((system_score + 40))
        system_factors+=("${total_ram_mb}MB RAM")
    elif [[ $total_ram_mb -ge 32768 ]]; then  # 32GB+
        system_score=$((system_score + 30))
        system_factors+=("${total_ram_mb}MB RAM")
    elif [[ $total_ram_mb -ge 16384 ]]; then  # 16GB+
        system_score=$((system_score + 20))
        system_factors+=("${total_ram_mb}MB RAM")
    elif [[ $total_ram_mb -ge 8192 ]]; then  # 8GB+
        system_score=$((system_score + 10))
    fi
    
    # Bonus for fast RAM (3200MHz+)
    if [[ $ram_speed_mhz -ge 3200 ]]; then
        system_score=$((system_score + 5))
    fi
    
    # Enhanced GPU detection with model info
    show_detection_progress "Analyzing GPU..."
    local has_gpu=false
    local gpu_model=""
    local gpu_detected=false
    
    # Parse inxi GPU info if available
    if [[ "$use_inxi" == "true" && -n "$inxi_gpu_info" ]]; then
        # Extract GPU model from inxi output
        # Example: "Graphics: Device-1: NVIDIA GeForce RTX 3080 driver: nvidia v: 525.125.06"
        gpu_model=$(echo "$inxi_gpu_info" | grep -oP 'Device-[0-9]+:[[:space:]]*[^:]+' | sed 's/Device-[0-9]*:[[:space:]]*//g' | head -1)
        
        if [[ -n "$gpu_model" ]]; then
            has_gpu=true
            gpu_detected=true
            
            # Intelligent GPU tier detection from inxi output
            if echo "$gpu_model" | grep -qiE "NVIDIA"; then
                # NVIDIA tier detection
                if echo "$gpu_model" | grep -qiE "(RTX 40|RTX 309|RTX 308|A[0-9]{3,4}|H100|A100|Quadro RTX)"; then
                    system_score=$((system_score + 30))
                    system_factors+=("High-end NVIDIA GPU")
                elif echo "$gpu_model" | grep -qiE "(RTX 30|RTX 20|GTX 16)"; then
                    system_score=$((system_score + 20))
                    system_factors+=("NVIDIA GPU")
                else
                    system_score=$((system_score + 15))
                    system_factors+=("NVIDIA GPU")
                fi
            elif echo "$gpu_model" | grep -qiE "AMD|Radeon"; then
                # AMD tier detection
                if echo "$gpu_model" | grep -qiE "(RX 7[0-9]{3}|RX 6[89][0-9]{2}|Radeon VII)"; then
                    system_score=$((system_score + 20))
                    system_factors+=("High-end AMD GPU")
                else
                    system_score=$((system_score + 15))
                    system_factors+=("AMD GPU")
                fi
            elif echo "$gpu_model" | grep -qiE "Intel.*Arc|Intel.*Xe"; then
                # Intel Arc detection
                system_score=$((system_score + 15))
                system_factors+=("Intel Arc GPU")
            elif echo "$gpu_model" | grep -qiE "Intel"; then
                # Intel integrated
                system_score=$((system_score + 5))
            fi
        fi
    fi
    
    # Fallback: NVIDIA GPU detection with nvidia-smi
    if [[ "$gpu_detected" == "false" ]] && command -v nvidia-smi >/dev/null 2>&1 && nvidia-smi >/dev/null 2>&1; then
        has_gpu=true
        gpu_model=$(nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | head -1)
        
        # Score based on GPU tier (RTX 40/30 series, high-end Quadro, etc.)
        if echo "$gpu_model" | grep -qiE "(RTX 40|RTX 309|RTX 308|A[0-9]{3,4}|H100|A100)"; then
            system_score=$((system_score + 30))
            system_factors+=("High-end NVIDIA GPU")
        elif echo "$gpu_model" | grep -qiE "(RTX 30|RTX 20|GTX 16)"; then
            system_score=$((system_score + 20))
            system_factors+=("NVIDIA GPU")
        else
            system_score=$((system_score + 15))
            system_factors+=("NVIDIA GPU")
        fi
    # Fallback: AMD GPU detection
    elif [[ "$gpu_detected" == "false" ]] && command -v rocm-smi >/dev/null 2>&1 && rocm-smi >/dev/null 2>&1; then
        has_gpu=true
        system_score=$((system_score + 20))
        system_factors+=("AMD GPU (ROCm)")
    elif [[ "$gpu_detected" == "false" ]] && lspci 2>/dev/null | grep -qi 'vga.*amd'; then
        has_gpu=true
        gpu_model=$(lspci 2>/dev/null | grep -i 'vga.*amd' | sed 's/.*: //g' | head -1)
        # Check for high-end AMD cards
        if echo "$gpu_model" | grep -qiE "(RX 7[0-9]{3}|RX 6[89][0-9]{2}|Radeon VII)"; then
            system_score=$((system_score + 20))
            system_factors+=("High-end AMD GPU")
        else
            system_score=$((system_score + 15))
            system_factors+=("AMD GPU")
        fi
    # Fallback: Intel GPU detection
    elif [[ "$gpu_detected" == "false" ]] && lspci 2>/dev/null | grep -qi 'vga.*intel'; then
        gpu_model=$(lspci 2>/dev/null | grep -i 'vga.*intel' | sed 's/.*: //g' | head -1)
        # Check for Intel Arc discrete GPUs
        if echo "$gpu_model" | grep -qiE "(Arc A[0-9]{3}|Xe)"; then
            system_score=$((system_score + 15))
            system_factors+=("Intel Arc GPU")
        else
            system_score=$((system_score + 5))
        fi
    fi
    
    # Check available disk space in current directory (in GB)
    show_detection_progress "Analyzing storage..."
    local free_space_gb=0
    local total_space_gb=0
    
    if command -v df >/dev/null 2>&1; then
        free_space_gb=$(df -BG . 2>/dev/null | awk 'NR==2 {print $4}' | tr -d 'G')
        total_space_gb=$(df -BG . 2>/dev/null | awk 'NR==2 {print $2}' | tr -d 'G')
        
        if [[ $free_space_gb -ge 500 ]]; then
            system_score=$((system_score + 25))
            system_factors+=("${free_space_gb}GB free")
        elif [[ $free_space_gb -ge 100 ]]; then
            system_score=$((system_score + 20))
            system_factors+=("${free_space_gb}GB free")
        elif [[ $free_space_gb -ge 50 ]]; then
            system_score=$((system_score + 10))
        elif [[ $free_space_gb -lt 10 ]]; then
            system_score=$((system_score - 15))  # Penalize low disk space
        fi
    fi
    
    # Check for SSD vs HDD (SSDs are much faster for video processing)
    local is_ssd=false
    
    # Parse inxi disk info if available
    if [[ "$use_inxi" == "true" && -n "$inxi_disk_info" ]]; then
        # Look for SSD indicators in inxi output
        # Example: "Local Storage: 1 TiB (2 drives) SSD"
        if echo "$inxi_disk_info" | grep -qiE "SSD|NVMe|M\.2"; then
            is_ssd=true
            system_score=$((system_score + 10))
            system_factors+=("SSD storage")
            
            # Extra bonus for NVMe (much faster than SATA SSD)
            if echo "$inxi_disk_info" | grep -qiE "NVMe"; then
                system_score=$((system_score + 5))
            fi
        fi
    fi
    
    # Fallback: Check /sys/block for rotational flag
    if [[ "$is_ssd" == "false" ]]; then
        # Check multiple common disk devices
        for disk in sda nvme0n1 sdb sdc; do
            if [[ -r /sys/block/$disk/queue/rotational ]]; then
                local rotational=$(cat /sys/block/$disk/queue/rotational 2>/dev/null || echo "1")
                if [[ "$rotational" == "0" ]]; then
                    is_ssd=true
                    system_score=$((system_score + 10))
                    system_factors+=("SSD storage")
                    break
                fi
            fi
        done
    fi
    
    # Complete the progress bar
    show_detection_progress "Complete!"
    printf "\n"  # Move to next line after progress bar
    
    # Display system analysis
    if [[ ${#system_factors[@]} -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ Detected: ${system_factors[*]}${NC}"
    fi
    
    # Determine system tier based on score (updated thresholds for better detection)
    local system_tier="standard"
    if [[ $system_score -ge 100 ]]; then
        system_tier="high-end"
        echo -e "  ${CYAN}ðŸš€ ${BOLD}Workstation/Enthusiast-class system detected!${NC} ${CYAN}Maximum quality recommended${NC}"
        echo -e "  ${GRAY}System Score: ${BOLD}$system_score${NC} ${GRAY}(High-Performance Tier)${NC}"
    elif [[ $system_score -ge 70 ]]; then
        system_tier="high-end"
        echo -e "  ${CYAN}ðŸ’ª ${BOLD}High-end system detected!${NC} ${CYAN}Recommending premium quality settings${NC}"
        echo -e "  ${GRAY}System Score: ${BOLD}$system_score${NC} ${GRAY}(High-End Tier)${NC}"
    elif [[ $system_score -ge 40 ]]; then
        system_tier="mid-range"
        echo -e "  ${CYAN}âš¡ ${BOLD}Mid-range system detected${NC} ${CYAN}- balanced quality recommended${NC}"
        echo -e "  ${GRAY}System Score: ${BOLD}$system_score${NC} ${GRAY}(Mid-Range Tier)${NC}"
    else
        system_tier="standard"
        echo -e "  ${CYAN}ðŸ“Š ${BOLD}Standard system detected${NC} ${CYAN}- optimized for efficiency${NC}"
        echo -e "  ${GRAY}System Score: ${BOLD}$system_score${NC} ${GRAY}(Standard Tier)${NC}"
    fi
    echo ""
    
    if [[ ${#video_files[@]} -gt 0 ]]; then
        echo -e "${BLUE}ðŸ” AI is analyzing your videos to provide smart recommendations...${NC}"
        local sample_file="${video_files[0]}"
        
        # Quick analysis for recommendation
        local duration=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$sample_file" 2>/dev/null | cut -d. -f1 || echo "0")
        local width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$sample_file" 2>/dev/null || echo "0")
        local height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$sample_file" 2>/dev/null || echo "0")
        local bitrate=$(ffprobe -v error -show_entries format=bit_rate -of csv=p=0 "$sample_file" 2>/dev/null || echo "0")
        local file_size=$(stat -c%s -- "$sample_file" 2>/dev/null || echo "0")
        
        # AI-based recommendation logic
        local total_pixels=$((width * height))
        local file_size_mb=$((file_size / 1024 / 1024))
        
        # Base recommendations on video characteristics
        if [[ $total_pixels -ge 8294400 && $file_size_mb -gt 100 ]]; then
            # 4K+ high-quality source
            ai_recommendation="max"
            recommendation_reason="4K source with high bitrate"
        elif [[ $total_pixels -ge 2073600 && $bitrate -gt 5000000 ]]; then
            # 1080p+ good quality
            ai_recommendation="high"
            recommendation_reason="High-resolution source with good bitrate"
        elif [[ $duration -gt 300 && $file_size_mb -gt 200 ]]; then
            # Long, high-quality movie
            ai_recommendation="medium"
            recommendation_reason="Long-form content - balanced approach"
        elif [[ $duration -lt 10 && $total_pixels -ge 1382400 ]]; then
            # Short high-res clip
            ai_recommendation="high"
            recommendation_reason="Short high-resolution clip - quality preservation"
        elif [[ $width -ge 1280 && $height -ge 720 && $duration -lt 60 ]]; then
            # Screencast-like content
            ai_recommendation="medium"
            recommendation_reason="Screencast-type content detected"
        elif [[ $total_pixels -lt 921600 || $file_size_mb -lt 10 ]]; then
            # Lower resolution or small file
            ai_recommendation="low"
            recommendation_reason="Lower resolution or compressed source"
        fi
        
        # ðŸš€ Upgrade recommendation based on system capabilities
        # High-end systems should prioritize quality - system capabilities matter more than source quality
        case "$system_tier" in
            "high-end")
                # Workstation/Enthusiast systems (score 100+) - ALWAYS recommend MAX quality
                if [[ $system_score -ge 100 ]]; then
                    # Top-tier systems: Your hardware can handle MAX, so use it!
                    if [[ "$ai_recommendation" != "max" ]]; then
                        ai_recommendation="max"
                        recommendation_reason="Workstation-class PC (Score: $system_score) - maximum quality recommended"
                    fi
                # High-end systems (score 70-99) - aggressive upgrades
                else
                    if [[ "$ai_recommendation" == "low" ]]; then
                        ai_recommendation="medium"
                        recommendation_reason="$recommendation_reason (upgraded for high-end PC)"
                    elif [[ "$ai_recommendation" == "medium" ]]; then
                        ai_recommendation="high"
                        recommendation_reason="$recommendation_reason (upgraded for high-end PC)"
                    elif [[ "$ai_recommendation" == "high" && $total_pixels -ge 2073600 ]]; then
                        ai_recommendation="max"
                        recommendation_reason="$recommendation_reason (upgraded for high-end PC)"
                    fi
                fi
                ;;
            "mid-range")
                # Mid-range systems get modest upgrades
                if [[ "$ai_recommendation" == "low" && $total_pixels -ge 921600 ]]; then
                    ai_recommendation="medium"
                    recommendation_reason="$recommendation_reason (upgraded for capable PC)"
                fi
                ;;
            "standard")
                # Standard systems: lower recommendations if disk space is limited
                if [[ $free_space_gb -lt 10 ]]; then
                    if [[ "$ai_recommendation" == "max" ]]; then
                        ai_recommendation="high"
                        recommendation_reason="$recommendation_reason (adjusted for disk space)"
                    elif [[ "$ai_recommendation" == "high" ]]; then
                        ai_recommendation="medium"
                        recommendation_reason="$recommendation_reason (adjusted for disk space)"
                    fi
                fi
                ;;
        esac
        
        echo -e "  ${GREEN}âœ“ Video analysis complete!${NC}"
        echo ""
    fi
    
    local quality_options=(
        "ðŸ”¹ Low Quality - Optimized for size (best for previews & social media)"
        "âš–ï¸  Medium Quality - Balanced approach (recommended for most content)"
        "ðŸ’Ž High Quality - Detailed output (best for important content)"
        "ðŸ† Max Quality - Premium quality (for professional use)"
        "ðŸ¤– Let AI Decide - Use AI recommendation based on video analysis"
    )
    
    local quality_values=("low" "medium" "high" "max" "ai_auto")
    local quality_descriptions=(
        "Up to 720p, 8-12fps, 64-128 colors, optimized compression"
        "Up to 1080p, 10-15fps, 128-192 colors, balanced settings"
        "Up to 1440p, 12-18fps, 192-256 colors, quality-focused"
        "Up to 4K, 15-24fps, 256 colors, maximum detail preservation"
        "AI automatically selects optimal settings per video"
    )
    
    # Show AI recommendation prominently
    if [[ -n "$recommendation_reason" ]]; then
        echo -e "${YELLOW}${BOLD}ðŸ’¡ AI RECOMMENDATION:${NC}"
        echo -e "  ${GREEN}âœ“ Suggested: ${BOLD}${ai_recommendation^^}${NC} ${GREEN}quality${NC}"
        echo -e "  ${CYAN}ðŸ”Ž Reason: $recommendation_reason${NC}"
        echo ""
    fi
    
    for i in "${!quality_options[@]}"; do
        local num=$((i + 1))
        
        # Don't show "(Current)" in quick mode - user is making a fresh selection
        # Only show current if this is a settings/advanced mode, not quick selection
        local is_current=""
        
        # Check if this option matches the AI recommendation
        local is_recommended=""
        if [[ "${quality_values[$i]}" == "$ai_recommendation" ]]; then
            is_recommended=" ðŸ’¡ (AI Recommended)"
        fi
        
        # Special handling for AI auto option - always show as smart choice
        if [[ "${quality_values[$i]}" == "ai_auto" ]]; then
            is_recommended=" ðŸŽ† (Smart Choice!)"
            # Don't show as current for ai_auto since it's a special mode
            if [[ "$QUALITY" == "ai_auto" ]]; then
                is_current=""
            fi
        fi
        
        # Optional debug output (enable by setting DEBUG_AI_SELECTION=true)
        if [[ "$DEBUG_AI_SELECTION" == "true" ]]; then
            echo "DEBUG: Option $((i+1)): value='${quality_values[$i]}' current_QUALITY='$QUALITY' ai_rec='$ai_recommendation'" >&2
        fi
        
        echo -e "  ${GREEN}[$num]${NC} ${quality_options[$i]}${is_current}${is_recommended}"
        echo -e "      ${GRAY}â†’ ${quality_descriptions[$i]}${NC}"
        echo ""
    done
    
    # Capitalize quality name for display
    local ai_recommendation_display="${ai_recommendation^}"  # Capitalize first letter
    
    echo -ne "${MAGENTA}Enter your choice [1-5] or press Enter for AI recommendation ($ai_recommendation_display):${NC} "
    read -r quality_choice
    
    if [[ -n "$quality_choice" && "$quality_choice" =~ ^[1-5]$ ]]; then
        local index=$((quality_choice - 1))
        local selected_quality="${quality_values[$index]}"
        
        if [[ "$selected_quality" == "ai_auto" ]]; then
            echo -e "${GREEN}ðŸ¤– AI Auto Mode Selected!${NC}"
            echo -e "${CYAN}AI will automatically determine optimal quality for each video${NC}"
            AI_AUTO_QUALITY=true
            QUALITY="$ai_recommendation"  # Set initial quality based on recommendation
        else
            apply_preset "$selected_quality"
            AI_AUTO_QUALITY=false
            # Capitalize quality name for display
            local quality_display="${QUALITY^}"
            echo -e "${GREEN}âœ“ Selected: ${BOLD}$quality_display${NC} ${GREEN}quality${NC}"
        fi
        
        # Save the selected quality choice to settings
        if [[ -n "$SETTINGS_FILE" ]]; then
            save_settings --silent
        fi
    else
        # Use AI recommendation as default
        apply_preset "$ai_recommendation"
        AI_AUTO_QUALITY=false
        # Capitalize quality name for display
        local quality_display="${QUALITY^}"
        echo -e "${GREEN}âœ“ Using AI recommendation: ${BOLD}$quality_display${NC} ${GREEN}quality${NC}"
        
        # Save the AI recommendation to settings
        if [[ -n "$SETTINGS_FILE" ]]; then
            save_settings --silent
        fi
    fi
    
    echo -e "${CYAN}${BOLD}ðŸ§  AI will now analyze and optimize all other settings based on each video's content!${NC}"
}

# ðŸ¤– AI-Powered Video Discovery System
ai_discover_videos() {
    # Check if AI discovery is enabled
    if [[ "$AI_DISCOVERY_ENABLED" != "true" ]]; then
        echo -e "  ${YELLOW}ðŸ™… AI video discovery is disabled${NC}"
        echo -e "  ${CYAN}Enable it with: ${BOLD}AI_DISCOVERY_ENABLED=true${NC}"
        return 1
    fi
    
    echo -e "  ${CYAN}ðŸ” AI is scanning common video locations...${NC}"
    
    # Define intelligent search paths
    local search_paths=()
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    # Add script directory and common video locations
    search_paths+=("$script_dir")
    search_paths+=("$HOME/Videos")
    search_paths+=("$HOME/Downloads")
    search_paths+=("$HOME/Desktop")
    search_paths+=("$HOME/Documents")
    search_paths+=("$HOME/Pictures")
    search_paths+=("$(pwd)")
    
    # Add any mounted drives or common media locations
    if [[ -d "/media/$USER" ]]; then
        for media_dir in /media/$USER/*; do
            [[ -d "$media_dir" ]] && search_paths+=("$media_dir")
        done
    fi
    
    # Remove duplicates and non-existent paths
    local unique_paths=()
    for path in "${search_paths[@]}"; do
        if [[ -d "$path" ]] && ! printf '%s\n' "${unique_paths[@]}" | grep -Fxq "$path"; then
            unique_paths+=("$path")
        fi
    done
    
    # Search for videos with progress indication
    local total_paths=${#unique_paths[@]}
    local current_path=0
    local found_videos=()
    
    for search_dir in "${unique_paths[@]}"; do
        ((current_path++))
        local progress=$((current_path * 100 / total_paths))
        
        printf "\r  ${BLUE}Scanning [${NC}"
        local filled=$((progress * 20 / 100))
        for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((i=filled; i<20; i++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${BLUE}] ${BOLD}%3d%%${NC} ${CYAN}%s${NC}" "$progress" "$(basename -- "$search_dir")"
        
        # Search for video files (non-recursive for performance)
        shopt -s nullglob
        for ext in mp4 avi mov mkv webm MP4 AVI MOV MKV WEBM; do
            for video in "$search_dir"/*."$ext"; do
                if [[ -f "$video" ]]; then
                    # Get file info for intelligent sorting
                    local size=$(stat -c%s -- "$video" 2>/dev/null || echo "0")
                    local modified=$(stat -c%Y -- "$video" 2>/dev/null || echo "0")
                    found_videos+=("$video|$size|$modified")
                fi
            done
        done
        shopt -u nullglob
    done
    
    printf "\r  ${GREEN}âœ“ Search complete! Found ${BOLD}${#found_videos[@]}${NC} ${GREEN}video files${NC}\n\n"
    
    if [[ ${#found_videos[@]} -eq 0 ]]; then
        echo -e "  ${YELLOW}ðŸš¨ No video files found in common locations${NC}"
        echo -e "  ${GRAY}Searched in: $(printf '%s, ' "${unique_paths[@]%,}" | sed 's/, $//')${NC}"
        return 1
    fi
    
    # Sort videos by modification time (newest first) and size
    local sorted_videos=()
    while IFS= read -r line; do
        sorted_videos+=("$line")
    done < <(printf '%s\n' "${found_videos[@]}" | sort -t'|' -k3,3nr -k2,2nr)
    
    # Display found videos with intelligent categorization
    echo -e "  ${GREEN}${BOLD}ðŸŽ¬ Found Videos - AI Analysis & Recommendations:${NC}\n"
    
    # Categorize videos
    local recent_videos=()
    local large_videos=()
    local other_videos=()
    local current_time=$(date +%s)
    
    for video_info in "${sorted_videos[@]}"; do
        local video_path="${video_info%%|*}"
        local size="${video_info#*|}"; size="${size%|*}"
        local modified="${video_info##*|}"
        
        local age_days=$(( (current_time - modified) / 86400 ))
        local size_mb=$((size / 1024 / 1024))
        
        if [[ $age_days -le 7 ]]; then
            recent_videos+=("$video_info")
        elif [[ $size_mb -gt 50 ]]; then
            large_videos+=("$video_info")
        else
            other_videos+=("$video_info")
        fi
    done
    
    # Display categories with AI insights
    local display_count=0
    local max_display=15
    
    if [[ ${#recent_videos[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}${BOLD}ðŸ”¥ Recent Videos (Modified within 7 days):${NC}"
        for video_info in "${recent_videos[@]}"; do
            [[ $display_count -ge $max_display ]] && break
            display_video_option "$video_info" $((++display_count))
        done
        echo ""
    fi
    
    if [[ ${#large_videos[@]} -gt 0 && $display_count -lt $max_display ]]; then
        echo -e "  ${BLUE}${BOLD}ðŸ’¾ Large Videos (>50MB):${NC}"
        for video_info in "${large_videos[@]}"; do
            [[ $display_count -ge $max_display ]] && break
            display_video_option "$video_info" $((++display_count))
        done
        echo ""
    fi
    
    if [[ ${#other_videos[@]} -gt 0 && $display_count -lt $max_display ]]; then
        echo -e "  ${CYAN}${BOLD}ðŸ“ Other Videos:${NC}"
        for video_info in "${other_videos[@]}"; do
            [[ $display_count -ge $max_display ]] && break
            display_video_option "$video_info" $((++display_count))
        done
        echo ""
    fi
    
    if [[ ${#sorted_videos[@]} -gt $max_display ]]; then
        echo -e "  ${GRAY}... and $((${#sorted_videos[@]} - max_display)) more videos${NC}\n"
    fi
    
    # Check for auto-selection based on user preferences
    if [[ "$AI_DISCOVERY_AUTO_SELECT" != "ask" ]]; then
        echo -e "  ${BLUE}ðŸ¤– ${BOLD}AI Auto-Selection Mode: $AI_DISCOVERY_AUTO_SELECT${NC}"
        
        case "$AI_DISCOVERY_AUTO_SELECT" in
            "recent")
                if [[ ${#recent_videos[@]} -gt 0 ]]; then
                    echo -e "  ${GREEN}âœ“ Auto-selecting ${#recent_videos[@]} recent videos!${NC}"
                    copy_videos_to_current "${recent_videos[@]}"
                    return 0
                else
                    echo -e "  ${YELLOW}No recent videos found, showing manual options...${NC}"
                fi
                ;;
            "all")
                echo -e "  ${GREEN}âœ“ Auto-selecting all displayed videos!${NC}"
                copy_videos_to_current "${sorted_videos[@]:0:$display_count}"
                return 0
                ;;
            "disabled")
                echo -e "  ${YELLOW}AI auto-selection disabled, showing manual options...${NC}"
                ;;
        esac
        echo ""
    fi
    
    # User selection options with clear explanation
    echo -e "  ${MAGENTA}${BOLD}ðŸŽ¯ Selection Options:${NC}"
    echo -e "  ${YELLOW}ðŸ“ Important: Selected videos will be ${BOLD}copied${NC} ${YELLOW}to current directory for conversion${NC}"
    echo -e "  ${CYAN}ðŸ’¾ GIF outputs will be saved in: ${BOLD}$(pwd)${NC}\n"
    echo -e "    ${GREEN}[a]${NC} Copy all displayed videos here and convert"
    echo -e "    ${GREEN}[r]${NC} Copy recent videos only (${#recent_videos[@]} files) and convert"
    echo -e "    ${GREEN}[1-$display_count]${NC} Copy specific video by number and convert"
    echo -e "    ${GREEN}[c]${NC} Copy custom selection (ranges like 1,3,5 or 1-5)"
    echo -e "    ${GREEN}[w]${NC} Change working directory first"
    echo -e "    ${GREEN}[s]${NC} Save preference and set auto-selection mode"
    echo -e "    ${GREEN}[n]${NC} No thanks, I'll add videos manually\n"
    
    echo -ne "${MAGENTA}Your choice: ${NC}"
    read -r choice
    
    case "$choice" in
        "a"|"A")
            echo -e "\n${GREEN}âœ“ Selected all displayed videos!${NC}"
            # Remember this choice if enabled
            if [[ "$AI_DISCOVERY_REMEMBER_CHOICE" == "true" ]]; then
                AI_DISCOVERY_AUTO_SELECT="all"
                save_settings --silent
                echo -e "  ${CYAN}ðŸ’¾ Remembered: Will auto-select all videos next time${NC}"
            fi
            copy_videos_to_current "${sorted_videos[@]:0:$display_count}"
            return 0
            ;;
        "r"|"R")
            if [[ ${#recent_videos[@]} -gt 0 ]]; then
                echo -e "\n${GREEN}âœ“ Selected ${#recent_videos[@]} recent videos!${NC}"
                # Remember this choice if enabled
                if [[ "$AI_DISCOVERY_REMEMBER_CHOICE" == "true" ]]; then
                    AI_DISCOVERY_AUTO_SELECT="recent"
                    save_settings --silent
                    echo -e "  ${CYAN}ðŸ’¾ Remembered: Will auto-select recent videos next time${NC}"
                fi
                copy_videos_to_current "${recent_videos[@]}"
                return 0
            else
                echo -e "\n${YELLOW}No recent videos found${NC}"
                return 1
            fi
            ;;
        [1-9]|[1-9][0-9])
            if [[ $choice -le $display_count ]]; then
                local selected_video="${sorted_videos[$((choice-1))]}"
                echo -e "\n${GREEN}âœ“ Selected video #$choice!${NC}"
                copy_videos_to_current "$selected_video"
                return 0
            else
                echo -e "\n${RED}Invalid selection${NC}"
                return 1
            fi
            ;;
        "c"|"C")
            echo -ne "\n${CYAN}Enter video numbers to copy (e.g., 1,3,5 or 1-5): ${NC}"
            read -r range_input
            copy_videos_by_range "$range_input" "${sorted_videos[@]:0:$display_count}"
            return $?
            ;;
        "w"|"W")
            echo -e "\n${BLUE}${BOLD}ðŸ“‚ Change Working Directory${NC}"
            echo -e "${CYAN}Current: ${BOLD}$(pwd)${NC}"
            echo -ne "${YELLOW}Enter new directory path (or press Enter to browse): ${NC}"
            read -r new_dir
            
            if [[ -z "$new_dir" ]]; then
                # Show some common directory options
                echo -e "\n${CYAN}Common directories:${NC}"
                echo -e "  ${GREEN}[1]${NC} $HOME/Desktop"
                echo -e "  ${GREEN}[2]${NC} $HOME/Downloads"
                echo -e "  ${GREEN}[3]${NC} $HOME/Documents"
                echo -e "  ${GREEN}[4]${NC} $HOME/Videos"
                echo -e "  ${GREEN}[c]${NC} Custom path\n"
                
                read -r dir_choice
                case "$dir_choice" in
                    "1") new_dir="$HOME/Desktop" ;;
                    "2") new_dir="$HOME/Downloads" ;;
                    "3") new_dir="$HOME/Documents" ;;
                    "4") new_dir="$HOME/Videos" ;;
                    "c"|"C")
                        echo -ne "${YELLOW}Enter full directory path: ${NC}"
                        read -r new_dir
                        ;;
                    *) 
                        echo -e "${RED}Invalid choice${NC}"
                        return 1
                        ;;
                esac
            fi
            
            if [[ -d "$new_dir" ]]; then
                cd "$new_dir" 2>/dev/null
                echo -e "${GREEN}âœ“ Changed to: ${BOLD}$(pwd)${NC}"
                echo -e "${CYAN}Restarting AI discovery in new location...${NC}\n"
                ai_discover_videos
                return $?
            else
                echo -e "${RED}âŒ Directory does not exist: $new_dir${NC}"
                return 1
            fi
            ;;
        "s"|"S")
            echo -e "\n${BLUE}${BOLD}ðŸ’¾ AI Discovery Preferences${NC}"
            echo -e "${CYAN}Configure how AI should handle video discovery:${NC}\n"
            
            echo -e "  ${GREEN}[1]${NC} Ask me each time (current: $([ "$AI_DISCOVERY_AUTO_SELECT" = "ask" ] && echo "âœ“" || echo " "))"
            echo -e "  ${GREEN}[2]${NC} Always auto-select recent videos (current: $([ "$AI_DISCOVERY_AUTO_SELECT" = "recent" ] && echo "âœ“" || echo " "))"
            echo -e "  ${GREEN}[3]${NC} Always auto-select all videos (current: $([ "$AI_DISCOVERY_AUTO_SELECT" = "all" ] && echo "âœ“" || echo " "))"
            echo -e "  ${GREEN}[4]${NC} Disable auto-selection (current: $([ "$AI_DISCOVERY_AUTO_SELECT" = "disabled" ] && echo "âœ“" || echo " "))\n"
            
            echo -e "  ${YELLOW}Remember choices: $(get_status_icon "$AI_DISCOVERY_REMEMBER_CHOICE")${NC}"
            echo -e "  ${GREEN}[r]${NC} Toggle remember choices\n"
            
            read -r pref_choice
            case "$pref_choice" in
                "1") 
                    AI_DISCOVERY_AUTO_SELECT="ask"
                    echo -e "${GREEN}âœ“ Will ask for selection each time${NC}"
                    ;;
                "2") 
                    AI_DISCOVERY_AUTO_SELECT="recent"
                    echo -e "${GREEN}âœ“ Will auto-select recent videos${NC}"
                    ;;
                "3") 
                    AI_DISCOVERY_AUTO_SELECT="all"
                    echo -e "${GREEN}âœ“ Will auto-select all videos${NC}"
                    ;;
                "4") 
                    AI_DISCOVERY_AUTO_SELECT="disabled"
                    echo -e "${GREEN}âœ“ Auto-selection disabled${NC}"
                    ;;
                "r"|"R")
                    AI_DISCOVERY_REMEMBER_CHOICE=$([[ "$AI_DISCOVERY_REMEMBER_CHOICE" == "true" ]] && echo "false" || echo "true")
                    echo -e "${GREEN}âœ“ Remember choices: $(get_status_text "$AI_DISCOVERY_REMEMBER_CHOICE")${NC}"
                    ;;
                *)
                    echo -e "${YELLOW}No changes made${NC}"
                    return 0
                    ;;
            esac
            
            save_settings --silent
            echo -e "${CYAN}ðŸ’¾ Preferences saved!${NC}"
            echo -e "${YELLOW}Restarting discovery with new settings...${NC}\n"
            ai_discover_videos
            return $?
            ;;
        "n"|"N"|"")
            echo -e "\n${YELLOW}AI discovery cancelled${NC}"
            return 1
            ;;
        *)
            echo -e "\n${RED}Invalid choice${NC}"
            return 1
            ;;
    esac
}

# Helper function to display video options with AI analysis
display_video_option() {
    local video_info="$1"
    local number="$2"
    
    local video_path="${video_info%%|*}"
    local size="${video_info#*|}"; size="${size%|*}"
    local modified="${video_info##*|}"
    
    local filename=$(basename -- "$video_path")
    local dirname=$(dirname "$video_path")
    local size_human=$(numfmt --to=iec $size 2>/dev/null || echo "${size}B")
    local mod_date=$(date -d @$modified '+%Y-%m-%d %H:%M' 2>/dev/null || echo "unknown")
    
    # AI content prediction based on filename and size
    local content_hint="ðŸŽ¬"
    if [[ $filename == *"screen"* ]] || [[ $filename == *"record"* ]] || [[ $filename == *"capture"* ]]; then
        content_hint="ðŸ–¥ï¸"
    elif [[ $size -lt 10485760 ]]; then  # < 10MB
        content_hint="ðŸŽ¥"  # likely a clip
    elif [[ $size -gt 104857600 ]]; then  # > 100MB
        content_hint="ðŸŽ¦"  # likely a movie
    fi
    
    printf "    ${GREEN}[%2d]${NC} %s ${BOLD}%s${NC}\n" "$number" "$content_hint" "$filename"
    printf "         ${GRAY}%s ${CYAN}%s${NC} ${YELLOW}%s${NC}\n" "$(basename -- "$dirname")" "$size_human" "$mod_date"
}

# Copy selected videos to current directory
copy_videos_to_current() {
    local selected_videos=("$@")
    local copy_count=0
    local current_dir="$(pwd)"
    
    echo -e "\n  ${BLUE}ðŸ“Ž Copying videos to conversion directory...${NC}"
    echo -e "  ${CYAN}ðŸ’¾ Destination: ${BOLD}$current_dir${NC}"
    echo -e "  ${YELLOW}â„¹ï¸  Note: Both videos AND generated GIFs will be in this location${NC}\n"
    
    for video_info in "${selected_videos[@]}"; do
        local video_path="${video_info%%|*}"
        local filename=$(basename -- "$video_path")
        
        # Skip if already in current directory
        if [[ "$(dirname "$video_path")" == "$current_dir" ]]; then
            echo -e "    ${YELLOW}âš ï¸  Skipping $filename (already in current directory)${NC}"
            continue
        fi
        
        # Check if file already exists
        if [[ -f "$current_dir/$filename" ]]; then
            echo -e "    ${YELLOW}âš ï¸  Skipping $filename (already exists)${NC}"
            continue
        fi
        
        # Copy the file
        if cp "$video_path" "$current_dir/" 2>/dev/null; then
            echo -e "    ${GREEN}âœ“ Copied: $filename${NC}"
            ((copy_count++))
        else
            echo -e "    ${RED}âŒ Failed: $filename${NC}"
        fi
    done
    
    if [[ $copy_count -gt 0 ]]; then
        echo -e "\n  ${GREEN}${BOLD}âœ¨ Successfully copied $copy_count video(s) to conversion directory!${NC}"
        echo -e "  ${BLUE}ðŸ“ Files are now in: ${BOLD}$current_dir${NC}"
        echo -e "  ${CYAN}ðŸš€ Ready to convert! GIFs will be generated in the same location.${NC}"
        return 0
    else
        echo -e "\n  ${YELLOW}No videos were copied${NC}"
        return 1
    fi
}

# Copy videos by range selection
copy_videos_by_range() {
    local range_input="$1"
    shift
    local all_videos=("$@")
    local selected_videos=()
    
    # Parse range input (e.g., "1,3,5" or "1-5")
    IFS=',' read -ra ranges <<< "$range_input"
    
    for range in "${ranges[@]}"; do
        if [[ $range == *"-"* ]]; then
            # Handle range (e.g., "1-5")
            local start="${range%-*}"
            local end="${range#*-}"
            for ((i=start; i<=end; i++)); do
                if [[ $i -gt 0 && $i -le ${#all_videos[@]} ]]; then
                    selected_videos+=("${all_videos[$((i-1))]}")
                fi
            done
        else
            # Handle single number
            if [[ $range -gt 0 && $range -le ${#all_videos[@]} ]]; then
                selected_videos+=("${all_videos[$((range-1))]}")
            fi
        fi
    done
    
    if [[ ${#selected_videos[@]} -gt 0 ]]; then
        echo -e "\n${GREEN}âœ“ Selected ${#selected_videos[@]} video(s)!${NC}"
        copy_videos_to_current "${selected_videos[@]}"
        return $?
    else
        echo -e "\n${RED}No valid selections${NC}"
        return 1
    fi
}

# ðŸ” AI Preview Analysis (non-intrusive)
ai_preview_analysis() {
    local file="$1"
    
    echo -e "  ${YELLOW}ðŸ”¬ AI Preview Analysis in progress...${NC}"
    
    # Show analysis progress
    local steps=("Extracting metadata" "Analyzing resolution" "Detecting content type" "Generating recommendations")
    for i in "${!steps[@]}"; do
        local step=$((i + 1))
        local progress=$((step * 25))
        local filled=$((progress * 20 / 100))
        local empty=$((20 - filled))
        
        printf "\r  ${CYAN}Preview [${NC}"
        for ((j=0; j<filled; j++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((j=0; j<empty; j++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}%s...${NC}" "$progress" "${steps[i]}"
        
        sleep 0.3  # Small delay for visual effect
    done
    
    # Quick video info extraction for preview
    local duration=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$file" 2>/dev/null | cut -d. -f1)
    local width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$file" 2>/dev/null)
    local height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$file" 2>/dev/null)
    
    # Simple content classification for preview
    local content_hint="general"
    if [[ $width -ge 1920 && $height -ge 1080 && $duration -lt 30 ]]; then
        content_hint="screencast"
    elif [[ $duration -gt 300 ]]; then
        content_hint="movie"
    elif [[ $duration -lt 10 ]]; then
        content_hint="clip"
    fi
    
    # Clear progress line and show results
    printf "\r  ${GREEN}âœ“ Preview analysis complete!${NC}\n"
    echo -e "  ${BLUE}ðŸ“Š Input:${NC} ${width}x${height}, ${duration}s"
    echo -e "  ${BLUE}ðŸ” Predicted:${NC} $content_hint content"
    echo -e "  ${BLUE}ðŸŽ¯ AI will:${NC} Analyze motion, optimize colors, adjust framerate"
    echo -e "  ${GRAY}  â†’ Full analysis will run during conversion${NC}"
}

# ðŸ“Š Show AI Summary after conversion
show_ai_summary() {
    echo -e "\n${CYAN}${BOLD}ðŸ¤– AI CONVERSION SUMMARY${NC}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    if [[ -f "$ERROR_LOG" ]]; then
        local ai_entries=$(grep "AI-ANALYSIS\|AI-DETECTED" "$ERROR_LOG" 2>/dev/null | tail -10)
        
        if [[ -n "$ai_entries" ]]; then
            local videos_analyzed=0
            local content_types=()
            local motion_types=()
            
            # Parse and count AI analysis results
            echo "$ai_entries" | while read -r line; do
                if [[ $line == *"AI-DETECTED:"* ]]; then
                    ((videos_analyzed++))
                    
                    # Extract content type
                    if [[ $line == *"content_type=clip"* ]]; then
                        content_types+=("Short Clip")
                    elif [[ $line == *"content_type=animation"* ]]; then
                        content_types+=("Animation")
                    elif [[ $line == *"content_type=screencast"* ]]; then
                        content_types+=("Screencast")
                    elif [[ $line == *"content_type=movie"* ]]; then
                        content_types+=("Movie/Long Video")
                    fi
                    
                    # Extract motion type
                    if [[ $line == *"motion=static"* ]]; then
                        motion_types+=("minimal motion")
                    elif [[ $line == *"motion=low"* ]]; then
                        motion_types+=("low motion")
                    elif [[ $line == *"motion=medium"* ]]; then
                        motion_types+=("moderate motion")
                    elif [[ $line == *"motion=high"* ]]; then
                        motion_types+=("high motion")
                    fi
                fi
            done
            
            # Show user-friendly summary
            echo -e "${YELLOW}ðŸ“Š What AI Detected:${NC}"
            
            # Count unique content types
            if [[ ${#content_types[@]} -gt 0 ]]; then
                echo -e "  ${BLUE}Content:${NC} Analyzed ${videos_analyzed} video(s)"
                echo -e "  ${BLUE}Type:${NC} ${content_types[0]}"
            fi
            
            # Show motion analysis
            if [[ ${#motion_types[@]} -gt 0 ]]; then
                echo -e "  ${BLUE}Motion:${NC} Detected ${motion_types[0]}"
            fi
            
            echo -e "\n${YELLOW}âš™ï¸ AI Optimizations Applied:${NC}"
            echo -e "  ${GREEN}âœ“${NC} Frame rate adjusted for motion level"
            echo -e "  ${GREEN}âœ“${NC} Color palette optimized for content type"
            echo -e "  ${GREEN}âœ“${NC} Smart cropping applied where beneficial"
            echo -e "  ${GREEN}âœ“${NC} File size optimized while preserving quality"
        fi
    fi
    
    echo -e "\n${GREEN}âœ… Conversion complete! AI optimized each video automatically.${NC}"
    echo -e "${CYAN}ðŸ’¡ Tip: AI decisions are logged in: $(make_clickable_path "$ERROR_LOG" "errors.log")${NC}"
}

# ðŸŽ† Quality-focused Analysis Mode
ai_quality_analysis() {
    local file="$1" width="$2" height="$3" bitrate="$4"
    
    echo -e "    ðŸŽ† ${BLUE}Quality Analysis Mode${NC}"
    
    local quality_score=$(analyze_source_quality "$file" "$width" "$height" "$bitrate")
    AI_CONTENT_CACHE="focused_quality_analysis=$quality_score"
    
    # Adjust settings based on source quality
    if [[ $quality_score -gt 80 ]]; then
        # High quality source - preserve detail
        MAX_COLORS="256"
        DITHER_MODE="floyd"
        SCALING_ALGO="lanczos"
    elif [[ $quality_score -gt 60 ]]; then
        # Good quality source
        MAX_COLORS="192"
        DITHER_MODE="bayer"
        SCALING_ALGO="bicubic"
    else
        # Lower quality source - don't overprocess
        MAX_COLORS="128"
        DITHER_MODE="bayer"
        SCALING_ALGO="bilinear"
    fi
}

# ðŸ“Š Analyze source quality
analyze_source_quality() {
    local file="$1" width="$2" height="$3" bitrate="$4"
    
    # Calculate quality score based on resolution, bitrate, and compression artifacts
    local resolution_score=0
    local bitrate_score=0
    
    # Resolution scoring
    local pixel_count=$((width * height))
    if [[ $pixel_count -ge 8294400 ]]; then  # 4K
        resolution_score=100
    elif [[ $pixel_count -ge 2073600 ]]; then  # 1080p
        resolution_score=80
    elif [[ $pixel_count -ge 921600 ]]; then   # 720p
        resolution_score=60
    elif [[ $pixel_count -ge 307200 ]]; then   # 480p
        resolution_score=40
    else
        resolution_score=20
    fi
    
    # Bitrate scoring (if available)
    if [[ $bitrate -gt 0 ]]; then
        local bitrate_per_pixel=$((bitrate / pixel_count))
        if [[ $bitrate_per_pixel -gt 100 ]]; then
            bitrate_score=100
        elif [[ $bitrate_per_pixel -gt 50 ]]; then
            bitrate_score=80
        elif [[ $bitrate_per_pixel -gt 25 ]]; then
            bitrate_score=60
        else
            bitrate_score=40
        fi
    else
        bitrate_score=50  # Unknown, assume medium
    fi
    
    # Combined score
    local quality_score=$(((resolution_score + bitrate_score) / 2))
    echo "$quality_score"
}

# ðŸ§­ Decode exit codes and signals into human-readable form
explain_exit_code() {
    local code="${1:-0}"
    if [[ "$code" -ge 128 ]]; then
        local sig=$((code - 128))
        local name="SIG$sig"
        case "$sig" in
            1) name="SIGHUP";;
            2) name="SIGINT";;
            3) name="SIGQUIT";;
            9) name="SIGKILL";;
            13) name="SIGPIPE";;
            14) name="SIGALRM";;
            15) name="SIGTERM";;
            19) name="SIGSTOP";;
            20) name="SIGTSTP";;
            21) name="SIGTTIN (background process tried to read from terminal)";;
            22) name="SIGTTOU (background process tried to write to terminal)";;
        esac
        echo "Process terminated by signal $sig (${name})"
        return 0
    fi
    case "$code" in
        0) echo "Success";;
        1) echo "General error (invalid arguments or processing failure)";;
        2) echo "Misuse of shell builtins / usage error";;
        *) echo "Exited with code $code";;
    esac
}

# Global array to store problematic filenames found during scan
declare -a PROBLEMATIC_FILENAMES_FOUND=()

# ðŸ“ Fix problematic filenames (starting with - or other symbols)
fix_problematic_filenames() {
    local -n files_array=$1
    local problematic_files=()
    local renamed_count=0
    local scan_mode=false
    
    # If files_array is empty or named "dummy_array", we're in scan-only mode
    if [[ ${#files_array[@]} -eq 0 ]] || [[ "$1" == "dummy_array" ]]; then
        scan_mode=true
    fi
    local cache_file="$LOG_DIR/filename_scan_cache.db"
    local cache_version="1.0"
    local scan_start_time=$(date +%s%3N)
    
    # Create cache directory if needed
    mkdir -p "$LOG_DIR" 2>/dev/null
    
    # Ask user if they want to scan for problematic filenames
    if [[ -z "${FILENAME_SCAN_CONFIRMED:-}" ]]; then
        echo ""
        echo -e "${YELLOW}${BOLD}âš ï¸  PROBLEMATIC FILENAME DETECTION${NC}"
        echo ""
        echo -e "${CYAN}ðŸ“Š What is Problematic Filename Detection?${NC}"
        echo -e "  Scan for files with names that start with '-' or special characters."
        echo -e "  This helps you:"
        echo -e "    ${GREEN}âœ“${NC} Avoid ffmpeg processing errors"
        echo -e "    ${GREEN}âœ“${NC} Fix files that cause 'command not found' issues"
        echo -e "    ${GREEN}âœ“${NC} Keep your file collection clean and compatible"
        echo ""
        echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
        echo -e "  â€¢ First run: ~10-30 seconds (builds cache)"
        echo -e "  â€¢ Subsequent runs: ~1-5 seconds (uses cached data)"
        echo -e "  â€¢ Scans current directory + output directory recursively"
        echo ""
        echo -e "${CYAN}ðŸŽ¯ When to run:${NC}"
        echo -e "  ${GREEN}âœ“${NC} Files downloaded with timestamps (like -1761587022680.mp4)"
        echo -e "  ${GREEN}âœ“${NC} Files with special characters at the start"
        echo -e "  ${GREEN}âœ“${NC} You've seen 'file not found' errors during conversion"
        echo ""
        echo -e "${CYAN}âš¡ When to skip:${NC}"
        echo -e "  ${YELLOW}â†’${NC} All your files have clean alphanumeric names"
        echo -e "  ${YELLOW}â†’${NC} You want to convert immediately"
        echo ""
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${GREEN}ðŸ’¡ Press 'Y' to start the scan now${NC} ${GRAY}(or 'N' to skip)${NC}"
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -ne "${BOLD}${GREEN}â–¶${NC}  Scan for problematic filenames? ${BOLD}(y/N):${NC} "
        read -r filename_scan_response
        
        if [[ "$filename_scan_response" =~ ^[Yy]$ ]]; then
            FILENAME_SCAN_CONFIRMED="yes"
            echo ""
            echo -e "${GREEN}${BOLD}âœ“ Starting filename scan...${NC}"
            echo ""
        else
            FILENAME_SCAN_CONFIRMED="no"
            echo -e "${YELLOW}â© Skipping filename scan${NC}"
            echo ""
            return 0
        fi
    fi
    
    # If user skipped, return
    if [[ "${FILENAME_SCAN_CONFIRMED}" == "no" ]]; then
        return 0
    fi
    
    # If not in scan mode and we already have problematic files, skip scanning and go straight to rename
    if [[ "$scan_mode" == false && ${#PROBLEMATIC_FILENAMES_FOUND[@]} -gt 0 ]]; then
        problematic_files=("${PROBLEMATIC_FILENAMES_FOUND[@]}")
        # Jump directly to rename prompt (skip all the scanning)
        # Set dummy values for statistics
        local checked=${#PROBLEMATIC_FILENAMES_FOUND[@]}
        local cache_hits=0
        local cache_misses=0
        local scan_start_time=$(date +%s%3N)
        local scan_end_time=$scan_start_time
        local scan_duration_ms=0
        local scan_duration_sec=0
        
        # Skip to rename section
        # (We'll use a goto-like approach by jumping to after the scan)
        goto_rename=true
    else
        goto_rename=false
    fi
    
    if [[ "$goto_rename" == false ]]; then
    echo -e "${BLUE}ðŸ” Scanning for problematic filenames...${NC}"
    
    # Collect all directories to scan (current + output)
    local scan_dirs=()
    scan_dirs+=("$(pwd)")
    
    # Add output directory if it's different and exists
    if [[ -n "$OUTPUT_DIRECTORY" && -d "$OUTPUT_DIRECTORY" ]]; then
        local output_abs=$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd)
        local current_abs=$(pwd)
        if [[ "$output_abs" != "$current_abs" ]]; then
            scan_dirs+=("$OUTPUT_DIRECTORY")
        fi
    fi
    
    # Load cache
    declare -A file_cache
    if [[ -f "$cache_file" ]]; then
        local cache_ver=$(head -1 "$cache_file" 2>/dev/null)
        if [[ "$cache_ver" == "VERSION=$cache_version" ]]; then
            while IFS='|' read -r filepath mtime status; do
                file_cache["$filepath"]="$mtime|$status"
            done < <(tail -n +2 "$cache_file")
        fi
    fi
    
    # Find all video and GIF files recursively
    local all_files=()
    local total_found=0
    
    echo -e "${CYAN}ðŸ“‚ Discovering files in directories...${NC}"
    local dir_word="directories"
    [[ ${#scan_dirs[@]} -eq 1 ]] && dir_word="directory"
    echo -e "  ${GRAY}Found ${BOLD}${#scan_dirs[@]}${NC}${GRAY} $dir_word to scan${NC}"
    echo ""
    for dir in "${scan_dirs[@]}"; do
        local dir_display="$(basename "$dir")"
        [[ "$dir" == "." || "$dir" == "$(pwd)" ]] && dir_display="current directory"
        echo -e "  ${GREEN}â–¶${NC} ${BOLD}$dir_display${NC}"
        echo -e "    ${GRAY}$dir${NC}"
        
        # Use find for fast recursive search
        while IFS= read -r -d '' file; do
            all_files+=("$file")
            ((total_found++))
        done < <(find "$dir" -type f \( -name '*.mp4' -o -name '*.avi' -o -name '*.mov' -o -name '*.mkv' -o -name '*.webm' -o -name '*.gif' \) -print0 2>/dev/null)
    done
    
    if [[ $total_found -eq 0 ]]; then
        echo -e "${YELLOW}No video or GIF files found${NC}"
        return 0
    fi
    
    echo -e "${GREEN}âœ“ Found $total_found files to check${NC}"
    echo -e ""
    
    # Scan files with progress bar
    local checked=0
    local cache_hits=0
    local cache_misses=0
    local interrupted=false
    
    # Enable Ctrl+C handling
    trap 'interrupted=true' INT
    
    for file in "${all_files[@]}"; do
        # Check for interruption
        if [[ "$interrupted" == "true" ]]; then
            echo -e "\n  ${YELLOW}â¸ï¸  Scan interrupted by user${NC}"
            break
        fi
        
        ((checked++))
        
        local basename=$(basename -- "$file")
        local file_mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
        
        # Check cache first
        local cached_data="${file_cache[$file]:-}"
        local use_cache=false
        
        if [[ -n "$cached_data" ]]; then
            local cached_mtime="${cached_data%%|*}"
            local cached_status="${cached_data##*|}"
            
            if [[ "$cached_mtime" == "$file_mtime" ]]; then
                use_cache=true
                ((cache_hits++))
                
                # Use cached result (check for both old format "problematic" and new "problematic:type")
                if [[ "$cached_status" =~ ^problematic ]]; then
                    problematic_files+=("$file")
                fi
            fi
        fi
        
        # If not in cache or outdated, check the file
        if [[ "$use_cache" == false ]]; then
            ((cache_misses++))
            
            # ðŸ” MULTI-LAYER DETECTION (Bulletproof Concept)
            local is_problematic=false
            local issue_type=""
            local detection_level=0
            
            # Remove extension for analysis
            local name_no_ext="${basename%.*}"
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # LAYER 1: Pattern-Based Detection (Fast, heuristic)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            # RULE 1.1: Starts with dash (most common issue)
            # FALSE POSITIVE CHECK: Ignore if it's a common pattern like "file-name" with text before dash
            if [[ "$basename" =~ ^- ]]; then
                # Check if it's JUST a dash followed by numbers/timestamp (problematic)
                # OR if it's a dash with special chars (problematic)
                if [[ "$name_no_ext" =~ ^-[0-9]+$ ]] || [[ "$name_no_ext" =~ ^--+ ]]; then
                    is_problematic=true
                    issue_type="dash-prefix"
                    detection_level=1
                    
                    # FILES STARTING WITH -- ARE ALWAYS PROBLEMATIC (no need for Layer 2)
                    # They work with ffprobe in quotes but break shell commands
                    if [[ "$basename" =~ ^-- ]]; then
                        detection_level=2  # Skip to confirmed level
                        issue_type="double-dash-prefix"
                    fi
                fi
            fi
            
            # RULE 1.2: Starts with other option-like patterns that break ffmpeg
            if [[ "$basename" =~ ^\+[0-9] ]]; then
                is_problematic=true
                issue_type="plus-prefix"
                detection_level=1
            fi
            
            # RULE 1.3: Starts with equals (rare but breaks some tools)
            if [[ "$basename" =~ ^= ]]; then
                is_problematic=true
                issue_type="equals-prefix"
                detection_level=1
            fi
            
            # RULE 1.4: Contains only special characters before first alphanumeric
            # This catches weird edge cases like "---file.mp4" or "_.mp4"
            if [[ "$name_no_ext" =~ ^[^a-zA-Z0-9]+$ ]] && [[ ${#name_no_ext} -lt 5 ]]; then
                is_problematic=true
                issue_type="special-only"
                detection_level=1
            fi
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # LAYER 2: FFmpeg Verification (Definitive proof)
            # Only run on files flagged by Layer 1 to confirm (skip if already confirmed)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if [[ "$is_problematic" == true && "$detection_level" -lt 2 ]]; then
                # Test if ffprobe can actually read the file with its current name
                # If it fails due to name, it's confirmed problematic
                if ffprobe -v quiet -show_entries format=duration "$file" 2>/dev/null >/dev/null; then
                    # FFprobe succeeded - file is actually OK despite pattern match
                    # This is a FALSE POSITIVE from Layer 1
                    is_problematic=false
                    issue_type="false-positive-layer1"
                    detection_level=0
                else
                    # Check if failure is due to filename vs file corruption
                    # Try with -- separator (proper way to handle special names)
                    if ffprobe -v quiet -show_entries format=duration -- "$file" 2>/dev/null >/dev/null; then
                        # Works with -- but not without = name is the problem
                        # CONFIRMED PROBLEMATIC by Layer 2
                        detection_level=2
                        issue_type="${issue_type}-verified"
                    else
                        # Doesn't work even with -- = file might be corrupted, not name issue
                        is_problematic=false
                        issue_type="corrupted-not-name-issue"
                        detection_level=0
                    fi
                fi
            fi
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # LAYER 3: Cross-Tool Verification (Extra paranoid)
            # Verify with both ffprobe AND ffmpeg to be absolutely certain
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if [[ "$is_problematic" == true && "$detection_level" -eq 2 ]]; then
                # Try a null conversion test with ffmpeg (no output, just parse)
                if ! ffmpeg -v quiet -i "$file" -f null - 2>/dev/null; then
                    # Also fails with ffmpeg without --
                    if ffmpeg -v quiet -i -- "$file" -f null - 2>/dev/null; then
                        # Works with --, confirmed by both tools
                        detection_level=3
                        issue_type="${issue_type%-verified}-triple-verified"
                    fi
                fi
            fi
            
            # Add to problematic list only if confirmed
            if [[ "$is_problematic" == true && "$detection_level" -ge 2 ]]; then
                problematic_files+=("$file")
            fi
            
            # Update cache with detection level
            local status="ok"
            if [[ "$is_problematic" == true && "$detection_level" -ge 2 ]]; then
                status="problematic:$issue_type:L$detection_level"
            elif [[ "$detection_level" -eq 1 ]]; then
                # Cache as "suspected" if Layer 1 only (for statistics)
                status="ok:suspected-false-positive"
            fi
            file_cache["$file"]="$file_mtime|$status"
        fi
        
        # Show progress bar
        local percent=$((checked * 100 / total_found))
        local filled=$((checked * 50 / total_found))
        local empty=$((50 - filled))
        
        # Build progress bar
        local bar=""
        for ((i=0; i<filled; i++)); do bar+="â–ˆ"; done
        for ((i=0; i<empty; i++)); do bar+="â–‘"; done
        
        # Truncate filename if too long
        local display_name="$basename"
        if [[ ${#display_name} -gt 35 ]]; then
            display_name="${display_name:0:32}..."
        fi
        
        # Show cache status
        local cache_indicator=""
        if [[ "$use_cache" == true ]]; then
            cache_indicator="${GREEN}âš¡${NC}"
        else
            cache_indicator="${YELLOW}ðŸ”${NC}"
        fi
        
        printf "\r\033[K${BLUE}[${GREEN}%s${GRAY}%s${BLUE}] ${YELLOW}%3d%%${NC} ${GRAY}(%d/%d)${NC} %b ${GRAY}%s${NC}" "${bar:0:filled}" "${bar:filled:empty}" "$percent" "$checked" "$total_found" "$cache_indicator" "$display_name"
    done
    
    # Clear progress bar and add newline
    printf "\r\033[K"
    echo ""  # Ensure newline after progress bar
    
    # Restore INT trap
    trap - INT
    
    # Save cache
    {
        echo "VERSION=$cache_version"
        for filepath in "${!file_cache[@]}"; do
            echo "$filepath|${file_cache[$filepath]}"
        done
    } > "$cache_file" 2>/dev/null
    
    # Calculate scan time
    local scan_end_time=$(date +%s%3N)
    local scan_duration_ms=$((scan_end_time - scan_start_time))
    local scan_duration_sec=$((scan_duration_ms / 1000))
    
    # Show detailed statistics
    echo -e "${CYAN}${BOLD}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "${CYAN}${BOLD}  ðŸ“Š FILENAME SCAN SUMMARY${NC}"
    echo -e "${CYAN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
    echo -e ""
    echo -e "  ${BLUE}${BOLD}ðŸ” Scan Statistics:${NC}"
    echo -e "    ${CYAN}â€¢ Total files scanned:     ${BOLD}$checked${NC} ${GRAY}(videos + GIFs)${NC}"
    echo -e "    ${CYAN}â€¢ Problematic files found: ${BOLD}${#problematic_files[@]}${NC}"
    echo -e "    ${CYAN}â€¢ Scan duration:           ${BOLD}${scan_duration_sec}s${NC}"
    echo -e ""
    echo -e "  ${MAGENTA}${BOLD}âš¡ Performance:${NC}"
    echo -e "    ${CYAN}â€¢ Cache hits:              ${BOLD}$cache_hits${NC} ${GREEN}(fast)${NC}"
    echo -e "    ${CYAN}â€¢ Cache misses:            ${BOLD}$cache_misses${NC} ${YELLOW}(analyzed)${NC}"
    if [[ $cache_hits -gt 0 ]]; then
        local cache_efficiency=$((cache_hits * 100 / (cache_hits + cache_misses)))
        echo -e "    ${CYAN}â€¢ Cache efficiency:        ${BOLD}${cache_efficiency}%${NC}"
    fi
    echo -e ""
    
    # If no problematic files, return
    if [[ ${#problematic_files[@]} -eq 0 ]]; then
        echo -e "  ${GREEN}${BOLD}âœ“ Result: No problematic filenames found${NC}"
        echo -e "  ${GRAY}All files have clean, compatible names${NC}"
        echo -e ""
        echo -e "${CYAN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
        return 0
    fi
    
    # Show list of problematic files
    echo -e "  ${YELLOW}${BOLD}âš ï¸  Problematic Files Found:${NC}"
    echo -e ""
    
    # Group and display files clearly
    local dash_count=0
    local dash_files=()
    
    for file in "${problematic_files[@]}"; do
        local bn=$(basename -- "$file")
        if [[ "$bn" =~ ^- ]]; then
            ((dash_count++))
            dash_files+=("$file")
        fi
    done
    
    # Show files starting with dash
    if [[ $dash_count -gt 0 ]]; then
        echo -e "  ${RED}${BOLD}ðŸ”´ Files starting with '-' (${dash_count} files):${NC}"
        if [[ $dash_count -eq ${#problematic_files[@]} ]]; then
            echo -e "     ${GRAY}â†’ These likely have timestamp prefixes${NC}"
        fi
        echo -e ""
        
        # Show up to 10 files, then summarize
        local show_count=$dash_count
        [[ $show_count -gt 10 ]] && show_count=10
        
        for ((i=0; i<show_count; i++)); do
            local file="${dash_files[$i]}"
            local bn=$(basename -- "$file")
            local dir=$(dirname -- "$file")
            local dir_display="$(basename "$dir")"
            [[ "$dir" == "." ]] && dir_display="current dir"
            
            echo -e "     ${YELLOW}â€¢${NC} ${BOLD}$bn${NC} ${GRAY}($dir_display)${NC}"
        done
        
        if [[ $dash_count -gt 10 ]]; then
            echo -e "     ${GRAY}... and $((dash_count - 10)) more files${NC}"
        fi
    fi
    echo -e ""
    echo -e "${CYAN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
    echo ""
    
    # Store found problematic files globally
    PROBLEMATIC_FILENAMES_FOUND=("${problematic_files[@]}")
    
    fi  # End of "if goto_rename == false" block
    
    # RENAME MODE: Show warning and offer to rename
    echo -e "${YELLOW}âš ï¸  Warning: Found ${#problematic_files[@]} file(s) with problematic names${NC}"
    echo -e "${YELLOW}Files starting with '-' can cause issues with ffmpeg${NC}"
    echo -e ""
    
    # Show list of problematic files with rename preview
    echo -e "${RED}Problematic files and proposed renames:${NC}"
    echo -e ""
    for file in "${problematic_files[@]}"; do
        local bn=$(basename -- "$file")
        
        # Calculate what the new name would be (same logic as actual rename)
        local new_basename="$bn"
        if [[ "$bn" =~ ^[-] ]]; then
            new_basename="${bn#[-]}"
            while [[ "$new_basename" =~ ^[^a-zA-Z0-9_] ]] && [[ -n "$new_basename" ]]; do
                new_basename="${new_basename:1}"
            done
            if [[ -z "$new_basename" ]]; then
                new_basename="video_TIMESTAMP.${bn##*.}"
            fi
        fi
        
        echo -e "  ${RED}ðŸ”´${NC} ${BOLD}$bn${NC}"
        echo -e "     ${GREEN}â†’${NC} ${GREEN}$new_basename${NC}"
        echo -e ""
    done
    
    # Ask user if they want to rename
    echo -ne "${CYAN}${BOLD}Do you want to rename these files as shown above?${NC} ${CYAN}[Y/n]:${NC} "
    read -r response
    
    if [[ "$response" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Skipping rename. Files will be processed with '--' workaround.${NC}"
        echo -e ""
        return 0
    fi
    
    echo -e "${GREEN}Renaming files...${NC}"
    echo ""
    
    # Rename each problematic file directly
    for file in "${problematic_files[@]}"; do
        local basename=$(basename -- "$file")
        local dirname=$(dirname -- "$file")
        
        if [[ "$basename" =~ ^[-] ]]; then
            # Remove leading dash and any other leading special chars
            local new_basename="${basename#[-]}"
            
            # Keep removing until first character is alphanumeric or underscore
            while [[ "$new_basename" =~ ^[^a-zA-Z0-9_] ]] && [[ -n "$new_basename" ]]; do
                new_basename="${new_basename:1}"
            done
            
            # If we removed everything, use a default name
            if [[ -z "$new_basename" ]]; then
                local timestamp=$(date +%s)
                new_basename="video_${timestamp}.${basename##*.}"
            fi
            
            local new_file="$dirname/$new_basename"
            
            # Make sure new name doesn't already exist
            local counter=1
            local base_no_ext="${new_basename%.*}"
            local extension="${new_basename##*.}"
            while [[ -e "$new_file" ]]; do
                new_basename="${base_no_ext}_${counter}.$extension"
                new_file="$dirname/$new_basename"
                ((counter++))
            done
            
            # Perform the rename
            if mv -- "$file" "$new_file" 2>/dev/null; then
                echo -e "  ${GREEN}âœ“ Renamed:${NC} $basename â†’ $new_basename"
                ((renamed_count++))
            else
                echo -e "  ${RED}âœ— Failed to rename:${NC} $basename"
            fi
        fi
    done
    
    if [[ $renamed_count -gt 0 ]]; then
        echo -e "${GREEN}âœ“ Successfully renamed $renamed_count file(s)${NC}"
    fi
    echo -e ""
}

# ðŸ“ Compute percentage (output vs source) with one decimal; returns 'n/a' if invalid
compute_ratio_percent() {
    local out_bytes="$1"
    local src_bytes="$2"
    if ! [[ "$out_bytes" =~ ^[0-9]+$ ]] || ! [[ "$src_bytes" =~ ^[0-9]+$ ]]; then
        echo "n/a"; return
    fi
    if [[ "$src_bytes" -eq 0 ]]; then
        echo "n/a"; return
    fi
    
    # Calculate percentage difference
    if [[ "$out_bytes" -gt "$src_bytes" ]]; then
        # GIF is larger than original
        local percent_increase=$(awk "BEGIN { printf \"%.1f\", (($out_bytes-$src_bytes)*100.0)/$src_bytes }")
        echo "â†‘ ${percent_increase}% larger"
    elif [[ "$out_bytes" -lt "$src_bytes" ]]; then
        # GIF is smaller than original
        local percent_decrease=$(awk "BEGIN { printf \"%.1f\", (($src_bytes-$out_bytes)*100.0)/$src_bytes }")
        echo "â†“ ${percent_decrease}% smaller"
    else
        # Same size
        echo "same size"
    fi
}

# ðŸ©º Summarize ffmpeg stderr into a concise diagnosis
summarize_ffmpeg_error() {
    local err_file="$1"
    local default_msg="Unknown FFmpeg error"
    [[ ! -s "$err_file" ]] && { echo "$default_msg"; return; }

    # Extract non-banner lines and filter out benign warnings
    local body=$(grep -v -E "^ffmpeg version|^\s*libav|^\s*configuration:|^Input #|^Output #|^Stream mapping:|^Press \[q\]|^\s*$|Duped color|deprecated pixel format" "$err_file" 2>/dev/null)

    # Look for common fatal patterns
    local patterns=(
        "No such file or directory"
        "Invalid argument"
        "Unrecognized option"
        "Option .* not found"
        "Filter .* not found"
        "Error while opening encoder"
        "Decoder .* not found"
        "Cannot allocate memory"
        "Permission denied"
        "Operation not permitted"
        "Device not found"
        "Protocol not found"
        "Unable to find a suitable output format"
        "Output file #0 does not contain any stream"
        "At least one output file must be specified"
        "[Ee]xperimental .* use -strict"
        "could not find tag for codec"
        "height not divisible|width not divisible"
    )

    for p in "${patterns[@]}"; do
        if echo "$body" | grep -Eiq "$p"; then
            echo "$(echo "$body" | grep -E "$p" -m1 -i)"
            return
        fi
    done

    # If body empty or only banner, report that explicitly
    if [[ -z "$body" ]]; then
        echo "Only FFmpeg banner captured; likely interrupted by a signal, timing issue, or loglevel too high"
        return
    fi

    # Fallback: show last meaningful line
    echo "$(echo "$body" | tail -1 | sed 's/^\s*//')"
}

# ðŸš€ Robust ffmpeg runner with timeout, clean env and safe flags
run_ffmpeg_safely() {
    local cmd="$1"         # full ffmpeg command string (without timeout)
    local err_file="$2"     # path to capture stderr/stdout
    local timeout_secs="${3:-0}" # 0 = no timeout

    # Always enforce safe flags; set FFREPORT correctly (colon-separated)
    local wrapped_cmd="$cmd -nostdin -hide_banner -y"
    local ffreport_var="FFREPORT=file=$LOG_DIR/ffreport.log:level=32"

    local exit_code=0
    if [[ "$timeout_secs" -gt 0 ]]; then
        # Run with timeout in background to track PID
        bash -lc "$ffreport_var timeout ${timeout_secs}s $wrapped_cmd" > "$err_file" 2>&1 &
        local ffmpeg_pid=$!
        SCRIPT_FFMPEG_PIDS+=("$ffmpeg_pid")
        
        wait $ffmpeg_pid || exit_code=$?
        
        # Remove from tracking
        local new_pids=()
        for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
            if [[ "$pid" != "$ffmpeg_pid" ]]; then
                new_pids+=("$pid")
            fi
        done
        SCRIPT_FFMPEG_PIDS=("${new_pids[@]}")
    else
        # Run in background to track PID
        bash -lc "$ffreport_var $wrapped_cmd" > "$err_file" 2>&1 &
        local ffmpeg_pid=$!
        SCRIPT_FFMPEG_PIDS+=("$ffmpeg_pid")
        
        wait $ffmpeg_pid || exit_code=$?
        
        # Remove from tracking
        local new_pids=()
        for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
            if [[ "$pid" != "$ffmpeg_pid" ]]; then
                new_pids+=("$pid")
            fi
        done
        SCRIPT_FFMPEG_PIDS=("${new_pids[@]}")
    fi
    echo "$exit_code"
}

# â³ Per-file progress using -progress pipe:1
render_inline_progress() {
    local percent_str="$1"
    local filled=$(awk -v p="${percent_str}" 'BEGIN { printf("%d", (p*30/100)+0.5) }')
    if [[ "$filled" -gt 30 ]]; then filled=30; fi
    local empty=$((30 - filled))
    local ch_done="#"; local ch_rem="."
    if locale 2>/dev/null | grep -qi UTF; then ch_done="â–ˆ"; ch_rem="â–‘"; fi
    printf "\r    ${CYAN}Progress:${NC} ${BLUE}["; for ((i=0;i<filled;i++)); do printf "%s" "$ch_done"; done; for ((i=0;i<empty;i++)); do printf "%s" "$ch_rem"; done; printf "${BLUE}]${NC} ${MAGENTA}${percent_str}%%%s" "$NC"
}

convert_with_progress() {
    local file="$1"
    local palette_file="$2"
    local out_file="$3"
    local filter="$4"
    local err_file="$5"

    # Duration in seconds for progress calculation
    local dur=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$file" 2>/dev/null | awk '{printf("%.0f", $1)}')
    [[ -z "$dur" || "$dur" -le 0 ]] && dur=1

    # GPU acceleration is disabled for GIF conversion due to filter compatibility issues
    local accel_flags=""
    echo -e "  ${CYAN}Converting to GIF (CPU optimized for filter compatibility)...${NC}"
    
    # Run ffmpeg and capture PID for interruption handling (redirect stdin to prevent terminal conflicts)
    # Resolve AI_THREADS_OPTIMAL: if set to "auto", use FFMPEG_THREADS; otherwise use it directly
    local optimal_threads="$FFMPEG_THREADS"
    if [[ "$AI_THREADS_OPTIMAL" != "auto" && -n "$AI_THREADS_OPTIMAL" ]]; then
        optimal_threads="$AI_THREADS_OPTIMAL"
    fi
    # Resolve AI_MEMORY_OPT: if set to "auto" or empty, don't use it; otherwise use it directly
    local memory_opts=""
    if [[ "$AI_MEMORY_OPT" != "auto" && -n "$AI_MEMORY_OPT" ]]; then
        memory_opts="$AI_MEMORY_OPT"
    fi
    local cmd="env -i PATH=\"$PATH\" HOME=\"$HOME\" ffmpeg $accel_flags $FFMPEG_INPUT_OPTS -i \"$file\" -i \"$palette_file\" -lavfi \"$filter\" -threads $optimal_threads $memory_opts -nostats -nostdin -loglevel warning -y \"$out_file\""
    
    # Run with progress dots
    (
        local dot_count=0
        while kill -0 $$ 2>/dev/null; do
            printf "\r  ${CYAN}Converting to GIF"
            for ((i=0; i<=dot_count%4; i++)); do printf "."; done
            printf "     ${NC}"
            ((dot_count++))
            sleep 1
        done
    ) &
    local dots_pid=$!
    
    # Add progress animation PID to tracking
    SCRIPT_FFMPEG_PIDS+=("$dots_pid")
    
    # Properly redirect all streams to avoid terminal conflicts
    FFREPORT="file=$LOG_DIR/ffreport.log:level=32" bash -lc "$cmd" </dev/null 2> "$err_file" &
    local ffmpeg_pid=$!
    CURRENT_FFMPEG_PID="$ffmpeg_pid"
    
    # Add FFmpeg PID to tracking array
    SCRIPT_FFMPEG_PIDS+=("$ffmpeg_pid")
    
    # Wait for ffmpeg to complete
    wait $ffmpeg_pid
    local ec=$?
    CURRENT_FFMPEG_PID=""
    
    # Stop progress dots immediately
    kill $dots_pid 2>/dev/null || true
    wait $dots_pid 2>/dev/null || true
    
    # Remove completed processes from tracking array
    local new_pids=()
    for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
        if [[ "$pid" != "$ffmpeg_pid" && "$pid" != "$dots_pid" ]]; then
            new_pids+=("$pid")
        fi
    done
    SCRIPT_FFMPEG_PIDS=("${new_pids[@]}")
    
    # Clear progress line
    printf "\r  ${GREEN}âœ“ Conversion completed     ${NC}\n"
    
    return $ec
}

convert_with_progress_oneshot() {
    local file="$1"
    local out_file="$2"
    local filter_complex="$3"
    local err_file="$4"

    # GPU acceleration is disabled for GIF conversion due to filter compatibility issues
    local accel_flags=""
    echo -e "  ${CYAN}Converting to GIF (one-shot, CPU optimized)...${NC}"
    
    # Run ffmpeg and capture PID for interruption handling (redirect stdin to prevent terminal conflicts)
    # Resolve AI_THREADS_OPTIMAL: if set to "auto", use FFMPEG_THREADS; otherwise use it directly
    local optimal_threads="$FFMPEG_THREADS"
    if [[ "$AI_THREADS_OPTIMAL" != "auto" && -n "$AI_THREADS_OPTIMAL" ]]; then
        optimal_threads="$AI_THREADS_OPTIMAL"
    fi
    # Resolve AI_MEMORY_OPT: if set to "auto" or empty, don't use it; otherwise use it directly
    local memory_opts=""
    if [[ "$AI_MEMORY_OPT" != "auto" && -n "$AI_MEMORY_OPT" ]]; then
        memory_opts="$AI_MEMORY_OPT"
    fi
    local cmd="env -i PATH=\"$PATH\" HOME=\"$HOME\" ffmpeg $accel_flags $FFMPEG_INPUT_OPTS -i \"$file\" -filter_complex \"$filter_complex\" -threads $optimal_threads $memory_opts -nostats -nostdin -loglevel warning -y \"$out_file\""
    
    # Run with progress dots
    (
        local dot_count=0
        while kill -0 $$ 2>/dev/null; do
            printf "\r  ${CYAN}Converting to GIF (one-shot)"
            for ((i=0; i<=dot_count%4; i++)); do printf "."; done
            printf "     ${NC}"
            ((dot_count++))
            sleep 1
        done
    ) &
    local dots_pid=$!
    
    # Add progress animation PID to tracking
    SCRIPT_FFMPEG_PIDS+=("$dots_pid")
    
    # Properly redirect all streams to avoid terminal conflicts
    FFREPORT="file=$LOG_DIR/ffreport.log:level=32" bash -lc "$cmd" </dev/null 2> "$err_file" &
    local ffmpeg_pid=$!
    CURRENT_FFMPEG_PID="$ffmpeg_pid"
    
    # Add FFmpeg PID to tracking array
    SCRIPT_FFMPEG_PIDS+=("$ffmpeg_pid")
    
    # Wait for ffmpeg to complete
    wait $ffmpeg_pid
    local ec=$?
    CURRENT_FFMPEG_PID=""
    
    # Stop progress dots immediately
    kill $dots_pid 2>/dev/null || true
    wait $dots_pid 2>/dev/null || true
    
    # Remove completed processes from tracking array
    local new_pids=()
    for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
        if [[ "$pid" != "$ffmpeg_pid" && "$pid" != "$dots_pid" ]]; then
            new_pids+=("$pid")
        fi
    done
    SCRIPT_FFMPEG_PIDS=("${new_pids[@]}")
    
    # Clear progress line
    printf "\r  ${GREEN}âœ“ One-shot conversion completed     ${NC}\n"
    
    return $ec
}

# âš ï¸  Safe execution wrapper
safe_execute() {
    local command="$1"
    local error_msg="$2"
    local file="$3"
    
    echo -e "${BLUE}ðŸ”„ Executing: $command${NC}" >&2
    
    if ! eval "$command" 2>&1; then
        log_error "$error_msg" "$file" "Command failed: $command" "${BASH_LINENO[0]}" "${FUNCNAME[1]}"
        return 1
    fi
    return 0
}

# ðŸ“ Log successful conversions
log_conversion() {
    local status="$1"
    local source_file="$2"
    local output_file="$3"
    local size_info="$4"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] $status: $(basename -- "$source_file") -> $(basename -- "$output_file") $size_info" >> "$CONVERSION_LOG"
    
    # Autosave progress after each file
    if [[ "$AUTOSAVE_ENABLED" == "true" ]]; then
        autosave_progress "$source_file" "$status"
    fi
}

# ðŸ’¾ Autosave conversion progress
autosave_progress() {
    local file="$1"
    local status="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Create progress file if it doesn't exist
    if [[ ! -f "$PROGRESS_FILE" ]]; then
        echo "# Smart GIF Converter Progress Save - $(date)" > "$PROGRESS_FILE"
        echo "# Format: [TIMESTAMP] STATUS:FILENAME" >> "$PROGRESS_FILE"
        echo "" >> "$PROGRESS_FILE"
    fi
    
    # Log the file status
    echo "[$timestamp] $status:$(basename -- "$file")" >> "$PROGRESS_FILE"
    
    # Keep only the last 1000 entries to prevent huge files
    if [[ $(wc -l < "$PROGRESS_FILE") -gt 1000 ]]; then
        tail -800 "$PROGRESS_FILE" > "${PROGRESS_FILE}.tmp" && mv "${PROGRESS_FILE}.tmp" "$PROGRESS_FILE"
    fi
}

# ðŸ“‚ Load previous progress and get list of unprocessed files
load_progress() {
    local -n processed_files_ref=$1
    
    if [[ ! -f "$PROGRESS_FILE" ]]; then
        echo -e "${YELLOW}â„¹ï¸ No previous progress found - starting fresh${NC}"
        return 1
    fi
    
    # Extract successfully processed files
    local completed_count=0
    while IFS= read -r line; do
        if [[ $line =~ ^\[.*\]\s+(SUCCESS|SKIPPED):(.*)$ ]]; then
            local status="${BASH_REMATCH[1]}"
            local filename="${BASH_REMATCH[2]}"
            processed_files_ref["$filename"]=1
            ((completed_count++))
        fi
    done < "$PROGRESS_FILE"
    
    if [[ $completed_count -gt 0 ]]; then
        echo -e "${GREEN}â„¹ï¸ Loaded progress: $completed_count files already processed${NC}"
        return 0
    fi
    
    return 1
}

# ðŸ—‘ï¸ Clear progress file (for fresh start)
clear_progress() {
    if [[ -f "$PROGRESS_FILE" ]]; then
        rm -f "$PROGRESS_FILE"
        echo -e "${GREEN}âœ“ Progress file cleared - starting fresh${NC}"
    fi
}

# ðŸ” Show recent errors from log
show_recent_errors() {
    local count=${1:-5}
    
    if [[ -f "$ERROR_LOG" ]] && [[ -s "$ERROR_LOG" ]]; then
        echo -e "${RED}${BOLD}ðŸš¨ RECENT ERRORS (Last $count):${NC}\n"
        
        # Get the last few error entries
        local errors=$(grep -A 2 "ERROR:" "$ERROR_LOG" | tail -$((count * 3)))
        
        if [[ -n "$errors" ]]; then
            echo "$errors" | while IFS= read -r line; do
                if [[ $line == *"ERROR:"* ]]; then
                    echo -e "  ${RED}âŒ $(echo "$line" | cut -d']' -f2-)${NC}"
                elif [[ $line == *"FILE:"* ]]; then
                    echo -e "  ${YELLOW}ðŸ“ $(echo "$line" | cut -d']' -f2-)${NC}"
                elif [[ $line == *"DETAILS:"* ]]; then
                    echo -e "  ${BLUE}ðŸ” $(echo "$line" | cut -d']' -f2-)${NC}"
                fi
            done
        else
            echo -e "  ${GREEN}No recent errors found${NC}"
        fi
        
        echo -e "\n${YELLOW}ðŸ“‹ Full error log: $ERROR_LOG${NC}"
        echo -e "${YELLOW}ðŸ“ˆ View with: tail -50 \"$ERROR_LOG\"${NC}"
    else
        echo -e "${GREEN}âœ… No error log found or log is empty${NC}"
    fi
}

# ðŸ§  Enhanced cleanup with temp directory support
cleanup_temp_files() {
    local file_prefix="$1"
    trace_function "cleanup_temp_files"
    
    if [[ -n "$file_prefix" ]]; then
        local base_name=$(basename -- "$file_prefix")
        
        # Clean temp files in work directory
        if [[ -n "$TEMP_WORK_DIR" && -d "$TEMP_WORK_DIR" ]]; then
            rm -f "${TEMP_WORK_DIR}/${base_name}"* 2>/dev/null || true
        fi
        
        # Clean legacy temp files in current directory (backward compatibility)
        rm -f "${file_prefix}_palette.png" "${file_prefix}_temp.gif" 2>/dev/null || true
        rm -f "${file_prefix}"*.error 2>/dev/null || true
        
        # Clean validation temp files
        rm -f /tmp/*_validation_*_*.log 2>/dev/null || true
    fi
    
    # Clean orphaned temp files
    find /tmp -name "ffprobe_error_$$_*.log" -type f -delete 2>/dev/null || true
    find /tmp -name "gif_validation_$$_*.log" -type f -delete 2>/dev/null || true
    
    # Clean FIFO files from progress functions
    rm -f /tmp/ffprog_$$_*.fifo 2>/dev/null || true
}

# ðŸ—‘ï¸ Clean entire temp work directory
cleanup_work_directory() {
    if [[ -n "$TEMP_WORK_DIR" && -d "$TEMP_WORK_DIR" ]]; then
        echo -e "${BLUE}ðŸ§½ Cleaning work directory...${NC}"
        rm -rf "$TEMP_WORK_DIR" 2>/dev/null || true
    fi
}

# ðŸ”§ Handle corrupt file detection and recovery
handle_corrupt_file() {
    local corrupt_file="$1"
    local source_file="$2"
    local corruption_type="$3"
    trace_function "handle_corrupt_file"
    
    echo -e "${RED}${BOLD}ðŸš¨ CORRUPT FILE DETECTED${NC}"
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${RED}ðŸ“ File: $(basename -- "$corrupt_file")${NC}"
    echo -e "${RED}ðŸ“„ Source: $(basename -- "$source_file")${NC}"
    echo -e "${RED}ðŸ” Type: $corruption_type${NC}"
    
    # Move corrupt file to quarantine directory
    local quarantine_dir="$LOG_DIR/corrupt_files"
    local quarantine_file="$quarantine_dir/$(basename -- "$corrupt_file").$(date +%s).corrupt"
    
    if mkdir -p "$quarantine_dir" 2>/dev/null; then
        if mv "$corrupt_file" "$quarantine_file" 2>/dev/null; then
            echo -e "${YELLOW}ðŸ“¦ Corrupt file quarantined: $quarantine_file${NC}"
            log_error "Corrupt file quarantined" "$corrupt_file" "Moved to: $quarantine_file | Type: $corruption_type" "${BASH_LINENO[0]}" "handle_corrupt_file"
        else
            echo -e "${RED}âŒ Failed to quarantine corrupt file, deleting it${NC}"
            rm -f "$corrupt_file" 2>/dev/null
            log_error "Corrupt file deleted (quarantine failed)" "$corrupt_file" "Type: $corruption_type" "${BASH_LINENO[0]}" "handle_corrupt_file"
        fi
    else
        echo -e "${RED}âŒ Cannot create quarantine directory, deleting corrupt file${NC}"
        rm -f "$corrupt_file" 2>/dev/null
        log_error "Corrupt file deleted (no quarantine)" "$corrupt_file" "Type: $corruption_type" "${BASH_LINENO[0]}" "handle_corrupt_file"
    fi
    
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
}

# ðŸ” Array to track ffmpeg PIDs started by this script
declare -a SCRIPT_FFMPEG_PIDS=()

# ðŸ“ Add ffmpeg PID to tracking (legacy - now using foreground execution)
track_ffmpeg_pid() {
    local pid="$1"
    # No longer needed since we run ffmpeg in foreground
    # Keeping function for compatibility with cleanup functions
    return 0
}

# ðŸ”ª Kill ffmpeg processes started by this script
kill_script_ffmpeg_processes() {
    local script_pid=$$
    
    # Method 1: Kill tracked PIDs
    if [[ ${#SCRIPT_FFMPEG_PIDS[@]} -gt 0 ]]; then
        echo -e "${YELLOW}ðŸ”„ Stopping ${#SCRIPT_FFMPEG_PIDS[@]} tracked ffmpeg process(es)...${NC}"
        for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                if kill -TERM "$pid" 2>/dev/null; then
                    echo -e "  ${GREEN}âœ“ Stopped tracked ffmpeg PID $pid${NC}"
                fi
            fi
        done
        
        # Wait for graceful shutdown
        sleep 2
        
        # Force kill any remaining tracked processes
        for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                kill -KILL "$pid" 2>/dev/null
                echo -e "  ${YELLOW}âš¡ Force killed stubborn tracked ffmpeg PID $pid${NC}"
            fi
        done
        
        # Clear the tracking array
        SCRIPT_FFMPEG_PIDS=()
    fi
    
    # Method 2: Kill child processes of this script (backup method)
    local child_ffmpeg_pids=($(pgrep -P $script_pid ffmpeg 2>/dev/null || true))
    if [[ ${#child_ffmpeg_pids[@]} -gt 0 ]]; then
        echo -e "${YELLOW}ðŸ”„ Found ${#child_ffmpeg_pids[@]} additional child ffmpeg process(es)...${NC}"
        for pid in "${child_ffmpeg_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                kill -TERM "$pid" 2>/dev/null
                echo -e "  ${GREEN}âœ“ Stopped child ffmpeg PID $pid${NC}"
            fi
        done
        
        sleep 1
        
        # Force kill remaining child processes
        for pid in "${child_ffmpeg_pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                kill -KILL "$pid" 2>/dev/null
                echo -e "  ${YELLOW}âš¡ Force killed child ffmpeg PID $pid${NC}"
            fi
        done
    fi
}

# ðŸ”« Comprehensive process group termination
kill_entire_process_group() {
    local signal="${1:-TERM}"
    
    # Kill the entire process group (all children and grandchildren)
    if [[ -n "$SCRIPT_PGID" ]]; then
        # Kill entire process group
        pkill -$signal -g "$SCRIPT_PGID" 2>/dev/null || true
        
        # Kill all processes with our parent process ID
        pkill -$signal -P "$SCRIPT_PID" 2>/dev/null || true
    fi
    
    # Kill any remaining ffmpeg processes
    pkill -$signal ffmpeg 2>/dev/null || true
}

# Track current conversion state for graceful interruption
CURRENT_FFMPEG_PID=""
CURRENT_FILE=""
INTERRUPT_REQUESTED=false

# ðŸ”¥ Graceful signal handler that allows current conversion to finish
handle_interrupt() {
    INTERRUPT_REQUESTED=true
    echo -e "\n${YELLOW}ðŸ‘‹ Quitting... Stopping after current file completes...${NC}"
    echo -e "${CYAN}ðŸ’¡ Press Ctrl+C again to force immediate exit${NC}"
    
    # Set a trap for the second interrupt to force exit
    trap 'force_cleanup_on_exit 130' INT
}

# ðŸ”¥ Force cleanup for immediate exit (double Ctrl+C)
force_cleanup_on_exit() {
    # Prevent recursive calls
    if [[ "$CLEANUP_IN_PROGRESS" == "true" ]]; then
        return
    fi
    export CLEANUP_IN_PROGRESS=true
    
    local exit_code=${1:-130}
    echo -e "\n${RED}ðŸš« Force exit requested! Terminating immediately...${NC}"
    
    # Disable all signal handlers to prevent loops
    trap '' INT TERM HUP PIPE ERR
    
    # Kill current ffmpeg if running
    if [[ -n "$CURRENT_FFMPEG_PID" ]] && kill -0 "$CURRENT_FFMPEG_PID" 2>/dev/null; then
        echo -e "${YELLOW}ðŸ”„ Stopping current ffmpeg process (PID $CURRENT_FFMPEG_PID)...${NC}"
        kill -TERM "$CURRENT_FFMPEG_PID" 2>/dev/null || true
        sleep 1
        if kill -0 "$CURRENT_FFMPEG_PID" 2>/dev/null; then
            kill -KILL "$CURRENT_FFMPEG_PID" 2>/dev/null || true
            echo -e "  ${RED}âš¡ Force killed ffmpeg${NC}"
        fi
    fi
    
    # Kill entire process group immediately
    kill_entire_process_group TERM 2>/dev/null || true
    sleep 0.5
    kill_entire_process_group KILL 2>/dev/null || true
    
    # Clean up temp files for current conversion only (don't delete whole folder)
    if [[ -n "$CURRENT_FILE" ]]; then
        cleanup_temp_files "${CURRENT_FILE%.*}" 2>/dev/null || true
        
        # Delete incomplete output GIF if it exists
        local incomplete_gif="${CURRENT_FILE%.*}.${OUTPUT_FORMAT}"
        if [[ -f "$incomplete_gif" ]]; then
            local output_size=$(stat -c%s -- "$incomplete_gif" 2>/dev/null || echo "0")
            # If GIF is suspiciously small or incomplete, delete it
            if [[ $output_size -lt 1000 ]]; then
                rm -f "$incomplete_gif" 2>/dev/null || true
                echo -e "${YELLOW}ðŸ§¹ Cleaned up incomplete conversion: $(basename -- "$incomplete_gif")${NC}"
            fi
        fi
    fi
    
    # Clean work directory and RAM disk on exit
    cleanup_work_directory 2>/dev/null || true
    cleanup_ram_disk 2>/dev/null || true
    
    # Save current settings before exiting
    if [[ -n "$SETTINGS_FILE" && "$AUTOSAVE_ENABLED" == "true" ]]; then
        save_settings --silent 2>/dev/null || true
        echo -e "${BLUE}ðŸ’¾ Progress and settings saved${NC}"
    fi
    
    # Show interrupted statistics if they exist
    if [[ "$total_files" -gt 0 ]] 2>/dev/null; then
        echo -e "\n${YELLOW}ðŸ“Š Conversion interrupted:${NC}"
        show_statistics 2>/dev/null || true
        echo -e "${CYAN}ðŸ”„ Run the script again to resume where you left off${NC}"
    fi
    
    echo -e "${RED}âŒ Script terminated by user${NC}"
    exit $exit_code
}

# ðŸ”¥ Enhanced signal handler with complete process group cleanup (for TERM/HUP)
cleanup_on_exit() {
    force_cleanup_on_exit ${1:-143}
}

# ðŸ“‚ Terminal disconnection handler
handle_terminal_disconnect() {
    echo -e "\n${RED}ðŸ“º Terminal disconnected - terminating all processes${NC}"
    kill_entire_process_group KILL
    exit 129
}

# ðŸ†˜ Emergency exit for stuck cleanup
emergency_exit() {
    echo -e "\n${RED}ðŸ†˜ EMERGENCY EXIT - Force killing all processes${NC}"
    pkill -KILL -g $$ 2>/dev/null || true
    pkill -KILL ffmpeg 2>/dev/null || true
    exit 1
}

# ðŸ”— Execute process bound to our terminal session
execute_bound_process() {
    local command="$1"
    local description="$2"
    
    if [[ "$TERMINAL_BOUND" == "true" ]]; then
        # Execute in a way that binds to our process group
        bash -c "$command" &
        local pid=$!
        
        # Make sure the process is in our group
        # Note: The process should inherit our process group automatically
        echo -e "\033[2mðŸ”— Started $description as PID $pid (bound to terminal)\033[0m"
        return $pid
    else
        # Fallback for non-terminal execution
        bash -c "$command" &
        local pid=$!
        echo -e "\033[2mâš ï¸ Started $description as PID $pid (no terminal binding)\033[0m"
        return $pid
    fi
}

# ðŸ Clean completion handler
finish_script() {
    # Clean up any remaining background jobs from shell
    jobs -p 2>/dev/null | while read pid; do
        kill -TERM "$pid" 2>/dev/null || true
        wait "$pid" 2>/dev/null || true
        disown "$pid" 2>/dev/null || true
    done
    
    # Only show cleanup message if there were actually processes to clean
    local script_pid=$$
    local has_processes=false
    local tracked_count=${#SCRIPT_FFMPEG_PIDS[@]}
    
    # Check if we have tracked processes
    if [[ $tracked_count -gt 0 ]]; then
        has_processes=true
    fi
    
    # Check for child processes
    local child_ffmpeg_pids=($(pgrep -P $script_pid ffmpeg 2>/dev/null || true))
    local child_count=${#child_ffmpeg_pids[@]}
    if [[ $child_count -gt 0 ]]; then
        has_processes=true
    fi
    
    if [[ "$has_processes" == "true" ]]; then
        echo -e "\n${BLUE}ðŸ Script completed, cleaning up processes...${NC}"
        echo -e "  ${CYAN}Tracked processes: $tracked_count${NC}"
        echo -e "  ${CYAN}Child processes: $child_count${NC}"
        
        kill_script_ffmpeg_processes
        
        # Double-check cleanup was successful
        local remaining_tracked=0
        for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                ((remaining_tracked++))
            fi
        done
        
        local remaining_children=($(pgrep -P $script_pid ffmpeg 2>/dev/null || true))
        local remaining_child_count=${#remaining_children[@]}
        
        if [[ $remaining_tracked -eq 0 && $remaining_child_count -eq 0 ]]; then
            echo -e "  ${GREEN}âœ… All processes cleaned up successfully${NC}"
        else
            echo -e "  ${YELLOW}âš ï¸ Some processes may still be running: $remaining_tracked tracked, $remaining_child_count children${NC}"
        fi
    fi
    
    # Final cleanup of temp files and work directory
    cleanup_temp_files "*" >/dev/null 2>&1
    cleanup_work_directory >/dev/null 2>&1
    cleanup_ram_disk >/dev/null 2>&1
}

# ðŸŽ¨ Advanced Perceptual Hash (dHash) - Frame Visual Structure
# Calculates difference hash for a single frame to detect visual structure
ai_calculate_dhash() {
    local frame_file="$1"
    local hash_size=${2:-8}  # Default 8x8 = 64 bits
    
    if [[ ! -f "$frame_file" ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Check if ImageMagick is available
    if ! command -v convert >/dev/null 2>&1; then
        echo "NO_IMAGEMAGICK"
        return 1
    fi
    
    # dHash (Difference Hash) algorithm:
    # 1. Resize to (hash_size+1) x hash_size (9x8 for default)
    # 2. Convert to grayscale
    # 3. Compare each pixel to its right neighbor
    # 4. Generate hash based on pixel > neighbor comparisons
    
    local temp_pixels="$(mktemp)"
    
    # Extract grayscale pixel values in a grid
    convert "$frame_file" -resize "$((hash_size + 1))x${hash_size}!" -colorspace Gray \
        -depth 8 txt:- 2>/dev/null | grep -oP '\(\K[0-9]+' > "$temp_pixels" 2>/dev/null
    
    if [[ ! -s "$temp_pixels" ]]; then
        rm -f "$temp_pixels"
        echo "ERROR"
        return 1
    fi
    
    # Read pixels into array
    local pixels=()
    while read -r pixel; do
        pixels+=("$pixel")
    done < "$temp_pixels"
    rm -f "$temp_pixels"
    
    # Calculate dHash by comparing adjacent pixels
    local hash_binary=""
    local row_width=$((hash_size + 1))
    
    for ((row=0; row<hash_size; row++)); do
        for ((col=0; col<hash_size; col++)); do
            local idx=$((row * row_width + col))
            local idx_next=$((idx + 1))
            
            local current="${pixels[$idx]:-0}"
            local next="${pixels[$idx_next]:-0}"
            
            # Compare: if current > next, bit is 1, else 0
            if [[ $current -gt $next ]]; then
                hash_binary+="1"
            else
                hash_binary+="0"
            fi
        done
    done
    
    # Convert binary to hexadecimal for compact storage
    local hash_hex=""
    for ((i=0; i<${#hash_binary}; i+=4)); do
        local nibble="${hash_binary:$i:4}"
        local hex_digit=$((2#$nibble))
        hash_hex+=$(printf '%x' "$hex_digit")
    done
    
    echo "$hash_hex"
    return 0
}

# ðŸŽ¨ Calculate Hamming Distance between two hashes
ai_hamming_distance() {
    local hash1="$1"
    local hash2="$2"
    
    if [[ -z "$hash1" || -z "$hash2" || "$hash1" == "ERROR" || "$hash2" == "ERROR" ]]; then
        echo "999"  # Return large distance for errors
        return 1
    fi
    
    # Convert hex to binary
    local binary1=""
    local binary2=""
    
    for ((i=0; i<${#hash1}; i++)); do
        local hex_char="${hash1:$i:1}"
        binary1+=$(printf '%04d' $(echo "obase=2; ibase=16; ${hex_char^^}" | bc 2>/dev/null || echo "0"))
    done
    
    for ((i=0; i<${#hash2}; i++)); do
        local hex_char="${hash2:$i:1}"
        binary2+=$(printf '%04d' $(echo "obase=2; ibase=16; ${hex_char^^}" | bc 2>/dev/null || echo "0"))
    done
    
    # Count differing bits
    local distance=0
    local max_len=${#binary1}
    [[ ${#binary2} -gt $max_len ]] && max_len=${#binary2}
    
    for ((i=0; i<max_len; i++)); do
        local bit1="${binary1:$i:1}"
        local bit2="${binary2:$i:1}"
        
        if [[ "$bit1" != "$bit2" ]]; then
            ((distance++))
        fi
    done
    
    echo "$distance"
    return 0
}

# ðŸŒˆ Color Histogram Analysis - Frame Color Profile
ai_calculate_color_histogram() {
    local frame_file="$1"
    local bins=${2:-16}  # Number of bins per channel (16 = 4096 total colors)
    
    if [[ ! -f "$frame_file" ]]; then
        echo "ERROR"
        return 1
    fi
    
    if ! command -v convert >/dev/null 2>&1; then
        echo "NO_IMAGEMAGICK"
        return 1
    fi
    
    # Create histogram using ImageMagick
    # Format: reduce colors to bins, then get color distribution
    local temp_hist="$(mktemp)"
    
    # Quantize to desired bins and extract histogram
    convert "$frame_file" -colors $((bins * bins * bins)) -format "%c" histogram:info:- 2>/dev/null | \
        grep -oP '\(\K[0-9,]+' | head -20 > "$temp_hist" 2>/dev/null
    
    if [[ ! -s "$temp_hist" ]]; then
        rm -f "$temp_hist"
        echo "ERROR"
        return 1
    fi
    
    # Create compact histogram signature (top dominant colors)
    local histogram_sig=""
    while IFS=, read -r r g b; do
        # Normalize to bin ranges
        local r_bin=$((r * bins / 256))
        local g_bin=$((g * bins / 256))
        local b_bin=$((b * bins / 256))
        histogram_sig+="${r_bin},${g_bin},${b_bin};"
    done < "$temp_hist"
    
    rm -f "$temp_hist"
    echo "${histogram_sig%;}"
    return 0
}

# ðŸ“Š Compare Color Histograms using Correlation
ai_compare_histograms() {
    local hist1="$1"
    local hist2="$2"
    
    if [[ -z "$hist1" || -z "$hist2" || "$hist1" == "ERROR" || "$hist2" == "ERROR" ]]; then
        echo "0"  # No correlation
        return 1
    fi
    
    # Parse histograms into arrays
    IFS=';' read -ra colors1 <<< "$hist1"
    IFS=';' read -ra colors2 <<< "$hist2"
    
    # Calculate intersection (common colors)
    local matches=0
    local total=$((${#colors1[@]} + ${#colors2[@]}))
    
    for color1 in "${colors1[@]}"; do
        for color2 in "${colors2[@]}"; do
            # Calculate color distance
            IFS=',' read -r r1 g1 b1 <<< "$color1"
            IFS=',' read -r r2 g2 b2 <<< "$color2"
            
            local r_diff=$((r1 - r2))
            local g_diff=$((g1 - g2))
            local b_diff=$((b1 - b2))
            
            # Euclidean distance (squared for speed)
            local distance=$((r_diff * r_diff + g_diff * g_diff + b_diff * b_diff))
            
            # If colors are very close, count as match
            if [[ $distance -lt 5 ]]; then
                ((matches++))
                break
            fi
        done
    done
    
    # Calculate correlation percentage
    local correlation=0
    if [[ $total -gt 0 ]]; then
        correlation=$((matches * 200 / total))  # Scale to 0-100
    fi
    
    echo "$correlation"
    return 0
}

# ðŸŽ¬ Extract Multiple Frames for Analysis
ai_extract_sample_frames() {
    local gif_file="$1"
    local num_frames=${2:-2}  # Sample 2 frames by default (OPTIMIZED: was 5)
    local output_dir="$3"
    
    if [[ ! -f "$gif_file" ]]; then
        return 1
    fi
    
    mkdir -p "$output_dir" 2>/dev/null || return 1
    
    # Get total frame count
    local total_frames=$(ffprobe -v error -select_streams v:0 -count_packets \
        -show_entries stream=nb_read_packets -of csv=p=0 "$gif_file" 2>/dev/null)
    
    if [[ -z "$total_frames" || $total_frames -eq 0 ]]; then
        return 1
    fi
    
    # Extract evenly distributed frames
    local frame_indices=()
    for ((i=0; i<num_frames; i++)); do
        local frame_idx=$((total_frames * i / num_frames))
        frame_indices+=("$frame_idx")
    done
    
    # Extract frames using FFmpeg
    local success=0
    for idx in "${frame_indices[@]}"; do
        local output_frame="$output_dir/frame_${idx}.png"
        if timeout 3 ffmpeg -i "$gif_file" -vf "select=eq(n\\,$idx)" \
            -vframes 1 -y "$output_frame" >/dev/null 2>&1; then
            ((success++))
        fi
    done
    
    echo "$success"
    return 0
}

# ðŸ§  AI-Driven Dynamic GIF Frame Sampling
# 100% AI decides optimal sampling strategy based on GIF characteristics
ai_dynamic_gif_sampling() {
    local gif1="$1"
    local gif2="$2"
    
    # Get GIF properties for AI analysis
    local frames1=$(ffprobe -v quiet -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 "$gif1" 2>/dev/null)
    local frames2=$(ffprobe -v quiet -select_streams v:0 -count_packets -show_entries stream=nb_read_packets -of csv=p=0 "$gif2" 2>/dev/null)
    local dur1=$(ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$gif1" 2>/dev/null | cut -d. -f1)
    local dur2=$(ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$gif2" 2>/dev/null | cut -d. -f1)
    local size1=$(stat -c%s "$gif1" 2>/dev/null || echo "0")
    local size2=$(stat -c%s "$gif2" 2>/dev/null || echo "0")
    
    # Default safe values
    [[ -z "$frames1" || $frames1 -lt 1 ]] && frames1=10
    [[ -z "$frames2" || $frames2 -lt 1 ]] && frames2=10
    [[ -z "$dur1" || $dur1 -lt 1 ]] && dur1=5
    [[ -z "$dur2" || $dur2 -lt 1 ]] && dur2=5
    
    # AI Factor 1: Frame Count - more frames = more samples needed
    local avg_frames=$(( (frames1 + frames2) / 2 ))
    local num_samples=3  # Base: 3 samples
    
    if [[ $avg_frames -gt 500 ]]; then
        num_samples=8  # Very long GIFs: 8 samples
    elif [[ $avg_frames -gt 200 ]]; then
        num_samples=6  # Long GIFs: 6 samples
    elif [[ $avg_frames -gt 50 ]]; then
        num_samples=5  # Medium GIFs: 5 samples
    elif [[ $avg_frames -gt 20 ]]; then
        num_samples=3  # Short GIFs: 3 samples
    else
        num_samples=2  # Very short GIFs: 2 samples
    fi
    
    # AI Factor 2: Duration
    local avg_duration=$(( (dur1 + dur2) / 2 ))
    if [[ $avg_duration -gt 30 ]]; then
        num_samples=$((num_samples + 2))  # Long duration: more samples
    elif [[ $avg_duration -gt 10 ]]; then
        num_samples=$((num_samples + 1))
    fi
    
    # AI Factor 3: File Size Similarity
    local size_ratio=$(( size1 * 100 / size2 ))
    [[ $size_ratio -gt 100 ]] && size_ratio=$(( 100 * 100 / size_ratio ))
    
    if [[ $size_ratio -gt 95 ]]; then
        num_samples=$((num_samples - 1))  # Very similar: reduce sampling
    elif [[ $size_ratio -lt 50 ]]; then
        num_samples=$((num_samples + 2))  # Very different: increase sampling
    fi
    
    # Ensure bounds: minimum 2, maximum 10
    [[ $num_samples -lt 2 ]] && num_samples=2
    [[ $num_samples -gt 10 ]] && num_samples=10
    
    echo "$num_samples"
}

# ðŸ”¬ Level 6: Bulletproof Multi-Layer Frame Analysis for GIFs
ai_advanced_frame_comparison() {
    local gif1="$1"
    local gif2="$2"
    local temp_dir="$3"
    local fast_mode="${4:-false}"  # Optional: Skip some layers for speed
    
    # ðŸ§  AI DECIDES: Get optimal sampling strategy
    local num_samples=$(ai_dynamic_gif_sampling "$gif1" "$gif2")
    
    # Create separate directories for each GIF's frames
    local frames_dir1="$temp_dir/frames_$(basename "$gif1" .gif)_$$"
    local frames_dir2="$temp_dir/frames_$(basename "$gif2" .gif)_$$"
    mkdir -p "$frames_dir1" "$frames_dir2" 2>/dev/null || return 1
    
    # Extract sample frames from both GIFs using AI-determined count
    printf " ${GREEN}âœ“${NC}\n" >&2
    echo -ne "  ${CYAN}ðŸ§  AI Decision: Extracting ${BOLD}$num_samples frames${NC}${CYAN} from each GIF...${NC}" >&2
    local num_frames1=$(ai_extract_sample_frames "$gif1" "$num_samples" "$frames_dir1")
    local num_frames2=$(ai_extract_sample_frames "$gif2" "$num_samples" "$frames_dir2")
    printf " ${GREEN}âœ“${NC}\n" >&2
    
    if [[ $num_frames1 -eq 0 || $num_frames2 -eq 0 ]]; then
        rm -rf "$frames_dir1" "$frames_dir2" 2>/dev/null
        echo "0:0"  # No match
        return 1
    fi
    
    # ðŸ›¡ï¸ BULLETPROOF MULTI-LAYER ANALYSIS FOR GIFs
    echo -e "  ${MAGENTA}ðŸ›¡ï¸ Multi-layer verification: dHash + PHASH + Color + Binary${NC}" >&2
    
    shopt -s nullglob
    local frames1=("$frames_dir1"/*.png)
    local frames2=("$frames_dir2"/*.png)
    shopt -u nullglob
    
    local max_frames=${#frames1[@]}
    [[ ${#frames2[@]} -lt $max_frames ]] && max_frames=${#frames2[@]}
    
    echo -e "  ${CYAN}Comparing $max_frames frame pairs...${NC}" >&2
    
    local visual_matches=0
    local color_matches=0
    local structural_matches=0
    local binary_matches=0
    local total_comparisons=0
    local confidence_score=0
    
    for ((i=0; i<max_frames; i++)); do
        local frame1="${frames1[$i]}"
        local frame2="${frames2[$i]}"
        
        [[ ! -f "$frame1" || ! -f "$frame2" ]] && continue
        
        local frame_confidence=0
        local frame_num=$((i + 1))
        printf "\r  ${CYAN}Frame %d/%d${NC}" "$frame_num" "$max_frames"
        
        # =================================================================
        # LAYER 1: dHash (Difference Hash) - Fast perceptual hash
        # =================================================================
        local dhash1=$(ai_calculate_dhash "$frame1" 6)
        local dhash2=$(ai_calculate_dhash "$frame2" 6)
        
        if [[ "$dhash1" != "ERROR" && "$dhash2" != "ERROR" && "$dhash1" != "NO_IMAGEMAGICK" ]]; then
            local hamming_dist=$(ai_hamming_distance "$dhash1" "$dhash2")
            
            if [[ $hamming_dist -lt 3 ]]; then
                ((visual_matches++))
                frame_confidence=$((frame_confidence + 35))  # Very high confidence
            elif [[ $hamming_dist -lt 5 ]]; then
                ((visual_matches++))
                frame_confidence=$((frame_confidence + 25))  # High confidence
            elif [[ $hamming_dist -lt 10 ]]; then
                frame_confidence=$((frame_confidence + 10))  # Medium confidence
            fi
        fi
        
        # =================================================================
        # LAYER 2: Color Histogram Correlation
        # =================================================================
        if [[ "$fast_mode" != "true" ]]; then
            local hist1=$(ai_calculate_color_histogram "$frame1" 12)
            local hist2=$(ai_calculate_color_histogram "$frame2" 12)
            
            if [[ "$hist1" != "ERROR" && "$hist2" != "ERROR" ]]; then
                local color_correlation=$(ai_compare_histograms "$hist1" "$hist2")
                
                if [[ $color_correlation -gt 90 ]]; then
                    ((color_matches++))
                    frame_confidence=$((frame_confidence + 30))
                elif [[ $color_correlation -gt 80 ]]; then
                    ((color_matches++))
                    frame_confidence=$((frame_confidence + 20))
                elif [[ $color_correlation -gt 70 ]]; then
                    frame_confidence=$((frame_confidence + 10))
                fi
            fi
        fi
        
        # =================================================================
        # LAYER 3: PHASH Structural Similarity (if ImageMagick available)
        # =================================================================
        if command -v convert >/dev/null 2>&1 && [[ $frame_confidence -lt 70 ]]; then
            local phash_dist=$(convert "$frame1" "$frame2" -metric PHASH -compare -format "%[distortion]" info: 2>/dev/null | cut -d'.' -f1)
            
            if [[ -n "$phash_dist" && "$phash_dist" =~ ^[0-9]+$ ]]; then
                if [[ $phash_dist -lt 500 ]]; then
                    ((structural_matches++))
                    frame_confidence=$((frame_confidence + 25))
                elif [[ $phash_dist -lt 1000 ]]; then
                    ((structural_matches++))
                    frame_confidence=$((frame_confidence + 15))
                fi
            fi
        fi
        
        # =================================================================
        # LAYER 4: Binary Comparison (Bulletproof for exact matches)
        # =================================================================
        if cmp -s "$frame1" "$frame2" 2>/dev/null; then
            ((binary_matches++))
            frame_confidence=100  # Perfect match!
        fi
        
        # =================================================================
        # LAYER 5: File Size Similarity Check
        # =================================================================
        local size1=$(stat -c%s "$frame1" 2>/dev/null || echo "0")
        local size2=$(stat -c%s "$frame2" 2>/dev/null || echo "0")
        
        if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
            local size_ratio=$(( size1 * 100 / size2 ))
            [[ $size_ratio -gt 100 ]] && size_ratio=$(( 10000 / size_ratio ))
            
            if [[ $size_ratio -ge 98 ]]; then
                frame_confidence=$((frame_confidence + 10))
            fi
        fi
        
        # Aggregate confidence
        confidence_score=$((confidence_score + frame_confidence))
        ((total_comparisons++))
    done
    
    printf "\r\033[K"
    
    # Cleanup
    rm -rf "$frames_dir1" "$frames_dir2" 2>/dev/null
    
    # =================================================================
    # ðŸ§  AI-POWERED BULLETPROOF SCORING FOR GIFs
    # =================================================================
    
    local visual_match_pct=0
    local color_match_pct=0
    local overall_confidence=0
    
    if [[ $total_comparisons -gt 0 ]]; then
        visual_match_pct=$((visual_matches * 100 / total_comparisons))
        color_match_pct=$((color_matches * 100 / total_comparisons))
        local structural_pct=$((structural_matches * 100 / total_comparisons))
        local binary_pct=$((binary_matches * 100 / total_comparisons))
        local avg_confidence=$((confidence_score / total_comparisons))
        
        # ðŸ›¡ï¸ BULLETPROOF LOGIC
        if [[ $binary_matches -gt 0 ]]; then
            overall_confidence=100
        elif [[ $structural_pct -ge 75 && $visual_match_pct -ge 75 && $color_match_pct -ge 75 ]]; then
            overall_confidence=95
        elif [[ $avg_confidence -ge 70 ]]; then
            overall_confidence=90
        elif [[ $avg_confidence -ge 50 ]]; then
            overall_confidence=75
        else
            overall_confidence=$avg_confidence
        fi
        
        # Show detailed results
        echo -e "  ${CYAN}ðŸ“Š Multi-Layer Results:${NC}" >&2
        echo -e "    ${GRAY}â€¢ dHash: ${BOLD}$visual_match_pct%${NC}" >&2
        echo -e "    ${GRAY}â€¢ Color: ${BOLD}$color_match_pct%${NC}" >&2
        echo -e "    ${GRAY}â€¢ PHASH: ${BOLD}$structural_pct%${NC}" >&2
        [[ $binary_matches -gt 0 ]] && echo -e "    ${GREEN}â€¢ Binary: ${BOLD}$binary_pct%${NC} (Perfect!)" >&2
        echo -e "    ${MAGENTA}â€¢ Overall: ${BOLD}$overall_confidence%${NC}" >&2
    fi
    
    echo "" >&2
    
    # Return results as "visual:overall_confidence"
    echo "${visual_match_pct}:${overall_confidence}"
    return 0
}

# ðŸ§  AI-Driven Dynamic Video Frame Analysis
# 100% AI decides optimal sampling strategy based on video characteristics
ai_dynamic_frame_sampling() {
    local video1="$1"
    local video2="$2"
    
    # Get video properties for AI analysis
    local dur1=$(ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video1" 2>/dev/null | cut -d. -f1)
    local dur2=$(ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video2" 2>/dev/null | cut -d. -f1)
    local fps1=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 "$video1" 2>/dev/null | bc -l 2>/dev/null | cut -d. -f1)
    local fps2=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 "$video2" 2>/dev/null | bc -l 2>/dev/null | cut -d. -f1)
    local size1=$(stat -c%s "$video1" 2>/dev/null || echo "0")
    local size2=$(stat -c%s "$video2" 2>/dev/null || echo "0")
    
    # Default safe values if probing fails
    [[ -z "$dur1" || $dur1 -lt 1 ]] && dur1=30
    [[ -z "$dur2" || $dur2 -lt 1 ]] && dur2=30
    [[ -z "$fps1" || $fps1 -lt 1 ]] && fps1=24
    [[ -z "$fps2" || $fps2 -lt 1 ]] && fps2=24
    
    # AI Factor 1: Video Duration - longer videos need more samples
    local avg_duration=$(( (dur1 + dur2) / 2 ))
    local num_frames=3  # Base: 3 frames
    
    if [[ $avg_duration -gt 300 ]]; then
        num_frames=8  # 5+ min videos: 8 frames
    elif [[ $avg_duration -gt 120 ]]; then
        num_frames=6  # 2-5 min videos: 6 frames
    elif [[ $avg_duration -gt 30 ]]; then
        num_frames=5  # 30s-2min videos: 5 frames
    elif [[ $avg_duration -gt 10 ]]; then
        num_frames=3  # 10-30s videos: 3 frames
    else
        num_frames=2  # <10s videos: 2 frames
    fi
    
    # AI Factor 2: Frame Rate - high FPS = more motion = need more samples
    local avg_fps=$(( (fps1 + fps2) / 2 ))
    if [[ $avg_fps -gt 50 ]]; then
        num_frames=$((num_frames + 2))  # High FPS (60fps): +2 frames
    elif [[ $avg_fps -gt 30 ]]; then
        num_frames=$((num_frames + 1))  # Med-High FPS (50fps): +1 frame
    fi
    
    # AI Factor 3: File Size - similar sizes suggest similar content
    local size_ratio=$(( size1 * 100 / size2 ))
    [[ $size_ratio -gt 100 ]] && size_ratio=$(( 100 * 100 / size_ratio ))
    
    if [[ $size_ratio -gt 95 ]]; then
        num_frames=$((num_frames - 1))  # Very similar size: reduce sampling
    elif [[ $size_ratio -lt 50 ]]; then
        num_frames=$((num_frames + 2))  # Very different size: increase sampling
    fi
    
    # Ensure bounds: minimum 2 frames, maximum 10 frames
    [[ $num_frames -lt 2 ]] && num_frames=2
    [[ $num_frames -gt 10 ]] && num_frames=10
    
    # AI Factor 4: Sampling Strategy - evenly distribute across video length
    local sample_interval=$((avg_duration / (num_frames + 1)))
    local sample_times=()
    
    for ((i=1; i<=num_frames; i++)); do
        local time_point=$((i * sample_interval))
        sample_times+=($time_point)
    done
    
    # Return: num_frames and sample_times array as space-separated string
    echo "$num_frames ${sample_times[*]}"
}

# ðŸŽ¬ Compare video frames for deep duplicate analysis (AI-Enhanced)
compare_video_frames() {
    local video1="$1"
    local video2="$2"
    local temp_dir="$3"
    
    # Check if videos exist
    [[ ! -f "$video1" || ! -f "$video2" ]] && return 1
    
    # ðŸ§  AI DECIDES: Get optimal sampling strategy dynamically
    local ai_decision=$(ai_dynamic_frame_sampling "$video1" "$video2")
    local num_frames=$(echo "$ai_decision" | awk '{print $1}')
    local sample_times=($(echo "$ai_decision" | cut -d' ' -f2-))
    
    # Show AI decision
    echo -e "  ${CYAN}ðŸ§  AI Decision: Analyzing ${BOLD}$num_frames frames${NC}${CYAN} at optimal intervals${NC}" >&2
    
    local frames_dir1="$temp_dir/frames1_${RANDOM}"
    local frames_dir2="$temp_dir/frames2_${RANDOM}"
    mkdir -p "$frames_dir1" "$frames_dir2" 2>/dev/null || return 1
    
    local frame_num=0
    
    for time in "${sample_times[@]}"; do
        ((frame_num++))
        
        # Extract from video 1 (with shorter timeout)
        timeout 3 ffmpeg -ss $time -i "$video1" -vframes 1 -f image2 \
            "$frames_dir1/frame_${frame_num}.png" >/dev/null 2>&1 &
        local pid1=$!
        
        # Extract from video 2
        timeout 3 ffmpeg -ss $time -i "$video2" -vframes 1 -f image2 \
            "$frames_dir2/frame_${frame_num}.png" >/dev/null 2>&1 &
        local pid2=$!
        
        # Wait for both (parallel extraction)
        wait $pid1 2>/dev/null
        wait $pid2 2>/dev/null
    done
    
    # Count extracted frames
    shopt -s nullglob
    local frames1=("$frames_dir1"/*.png)
    local frames2=("$frames_dir2"/*.png)
    shopt -u nullglob
    
    local max_frames=${#frames1[@]}
    [[ ${#frames2[@]} -lt $max_frames ]] && max_frames=${#frames2[@]}
    
    [[ $max_frames -eq 0 ]] && { rm -rf "$frames_dir1" "$frames_dir2" 2>/dev/null; return 1; }
    
    # ðŸ›¡ï¸ BULLETPROOF MULTI-LAYER ANALYSIS
    # Uses multiple independent tools for verification
    echo -e "  ${MAGENTA}ðŸ›¡ï¸ Multi-layer verification: ImageMagick + FFmpeg + File comparison${NC}" >&2
    
    local visual_matches=0
    local color_matches=0
    local structural_matches=0
    local binary_matches=0
    local total_comparisons=0
    local confidence_score=0
    
    for ((i=0; i<max_frames; i++)); do
        local frame1="${frames1[$i]}"
        local frame2="${frames2[$i]}"
        
        [[ ! -f "$frame1" || ! -f "$frame2" ]] && continue
        
        local frame_confidence=0
        
        # =================================================================
        # LAYER 1: ImageMagick Perceptual Hash (most reliable)
        # =================================================================
        if command -v convert >/dev/null 2>&1; then
            # Method 1a: Average hash comparison (fast, reliable)
            local hash1=$(convert "$frame1" -resize 8x8! -colorspace gray -format "%[fx:mean]" info: 2>/dev/null | tr -d '.')
            local hash2=$(convert "$frame2" -resize 8x8! -colorspace gray -format "%[fx:mean]" info: 2>/dev/null | tr -d '.')
            
            if [[ -n "$hash1" && -n "$hash2" ]]; then
                local hash_diff=$(( hash1 > hash2 ? hash1 - hash2 : hash2 - hash1 ))
                
                if [[ $hash_diff -lt 50000 ]]; then
                    ((visual_matches++))
                    frame_confidence=$((frame_confidence + 30))  # High confidence
                elif [[ $hash_diff -lt 100000 ]]; then
                    frame_confidence=$((frame_confidence + 15))  # Medium confidence
                fi
            fi
            
            # Method 1b: RMSE color comparison (color profile)
            local color_diff=$(convert \( "$frame1" -resize 1x1! \) \( "$frame2" -resize 1x1! \) \
                -metric RMSE -format "%[distortion]" -compare info: 2>/dev/null | cut -d' ' -f1 | cut -d'.' -f1)
            
            if [[ -n "$color_diff" && "$color_diff" =~ ^[0-9]+$ ]]; then
                if [[ $color_diff -lt 5000 ]]; then
                    ((color_matches++))
                    frame_confidence=$((frame_confidence + 25))
                elif [[ $color_diff -lt 10000 ]]; then
                    frame_confidence=$((frame_confidence + 12))
                fi
            fi
            
            # Method 1c: Structural similarity (SSIM-like with ImageMagick)
            local structural_sim=$(convert "$frame1" "$frame2" -metric PHASH -compare -format "%[distortion]" info: 2>/dev/null | cut -d'.' -f1)
            
            if [[ -n "$structural_sim" && "$structural_sim" =~ ^[0-9]+$ && $structural_sim -lt 1000 ]]; then
                ((structural_matches++))
                frame_confidence=$((frame_confidence + 20))
            fi
        fi
        
        # =================================================================
        # LAYER 2: Direct Binary Comparison (fastest, bulletproof for exact matches)
        # =================================================================
        if cmp -s "$frame1" "$frame2" 2>/dev/null; then
            ((binary_matches++))
            frame_confidence=100  # Perfect match!
        fi
        
        # =================================================================
        # LAYER 3: FFmpeg SSIM (if available - most accurate)
        # =================================================================
        if command -v ffmpeg >/dev/null 2>&1 && [[ $frame_confidence -lt 80 ]]; then
            # Use FFmpeg's built-in SSIM filter for structural similarity
            local ssim_score=$(ffmpeg -i "$frame1" -i "$frame2" -lavfi ssim -f null - 2>&1 | \
                grep -oP 'SSIM.*All:\K[0-9.]+' | head -1 2>/dev/null)
            
            if [[ -n "$ssim_score" ]]; then
                # SSIM ranges from 0 to 1, where 1 is identical
                local ssim_pct=$(echo "$ssim_score * 100" | bc 2>/dev/null | cut -d'.' -f1)
                
                if [[ -n "$ssim_pct" && $ssim_pct -ge 95 ]]; then
                    frame_confidence=$((frame_confidence + 25))
                elif [[ -n "$ssim_pct" && $ssim_pct -ge 80 ]]; then
                    frame_confidence=$((frame_confidence + 15))
                fi
            fi
        fi
        
        # =================================================================
        # LAYER 4: File Size Similarity (quick sanity check)
        # =================================================================
        local size1=$(stat -c%s "$frame1" 2>/dev/null || echo "0")
        local size2=$(stat -c%s "$frame2" 2>/dev/null || echo "0")
        
        if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
            local size_ratio=$(( size1 * 100 / size2 ))
            [[ $size_ratio -gt 100 ]] && size_ratio=$(( 10000 / size_ratio ))
            
            if [[ $size_ratio -ge 95 ]]; then
                frame_confidence=$((frame_confidence + 10))
            fi
        fi
        
        # Aggregate confidence for this frame
        confidence_score=$((confidence_score + frame_confidence))
        
        ((total_comparisons++))
    done
    
    # Cleanup
    rm -rf "$frames_dir1" "$frames_dir2" 2>/dev/null
    
    # =================================================================
    # ðŸ§  AI-POWERED BULLETPROOF SCORING SYSTEM
    # Combines all layers for maximum accuracy
    # =================================================================
    
    local visual_match_pct=0
    local color_match_pct=0
    local overall_confidence=0
    
    if [[ $total_comparisons -gt 0 ]]; then
        # Calculate individual layer success rates
        visual_match_pct=$((visual_matches * 100 / total_comparisons))
        color_match_pct=$((color_matches * 100 / total_comparisons))
        local structural_pct=$((structural_matches * 100 / total_comparisons))
        local binary_pct=$((binary_matches * 100 / total_comparisons))
        
        # Calculate average confidence per frame
        local avg_confidence=$((confidence_score / total_comparisons))
        
        # ðŸ›¡ï¸ BULLETPROOF LOGIC: Multiple verification layers
        # If ANY binary matches exist, confidence is 100% for those frames
        if [[ $binary_matches -gt 0 ]]; then
            overall_confidence=100
        # If high structural + visual + color agreement, very high confidence
        elif [[ $structural_pct -ge 75 && $visual_match_pct -ge 75 && $color_match_pct -ge 75 ]]; then
            overall_confidence=95
        # If strong agreement across multiple layers
        elif [[ $avg_confidence -ge 70 ]]; then
            overall_confidence=90
        # If moderate multi-layer agreement
        elif [[ $avg_confidence -ge 50 ]]; then
            overall_confidence=75
        # Weak agreement
        else
            overall_confidence=$avg_confidence
        fi
        
        # Show detailed results
        echo -e "  ${CYAN}ðŸ“Š Multi-Layer Results:${NC}" >&2
        echo -e "    ${GRAY}â€¢ Visual Hash: ${BOLD}$visual_match_pct%${NC}" >&2
        echo -e "    ${GRAY}â€¢ Color Profile: ${BOLD}$color_match_pct%${NC}" >&2
        echo -e "    ${GRAY}â€¢ Structural: ${BOLD}$structural_pct%${NC}" >&2
        [[ $binary_matches -gt 0 ]] && echo -e "    ${GREEN}â€¢ Binary Match: ${BOLD}$binary_pct%${NC} (Perfect!)" >&2
        echo -e "    ${MAGENTA}â€¢ Overall Confidence: ${BOLD}$overall_confidence%${NC}" >&2
    fi
    
    # Return results as "visual:overall_confidence"
    # Using overall_confidence instead of color for more accurate detection
    echo "${visual_match_pct}:${overall_confidence}"
    return 0
}

# ðŸ“ Calculate filename similarity using Levenshtein-inspired algorithm
calculate_filename_similarity() {
    local str1="$1"
    local str2="$2"
    
    # Convert to lowercase for case-insensitive comparison
    str1="${str1,,}"
    str2="${str2,,}"
    
    # If identical, return 100%
    [[ "$str1" == "$str2" ]] && echo "100" && return 0
    
    local len1=${#str1}
    local len2=${#str2}
    
    # If one is empty, similarity is 0
    [[ $len1 -eq 0 || $len2 -eq 0 ]] && echo "0" && return 0
    
    # Simple character overlap method (faster than full Levenshtein)
    local matches=0
    local total_chars=$(( len1 > len2 ? len1 : len2 ))
    
    # Count matching characters in order
    local i=0
    local j=0
    while [[ $i -lt $len1 && $j -lt $len2 ]]; do
        if [[ "${str1:$i:1}" == "${str2:$j:1}" ]]; then
            ((matches++))
            ((i++))
            ((j++))
        elif [[ $i -lt $j ]]; then
            ((i++))
        else
            ((j++))
        fi
    done
    
    # Calculate similarity percentage
    local similarity=$(( matches * 100 / total_chars ))
    echo "$similarity"
}

# Worker function for parallel video comparison (uses file-based lookups)
# Must be defined at top level to allow export to background processes
video_compare_worker() {
    local worker_id=$1
    local queue=$2
    local results=$3
    local progress=$4
    local lockfile=$5
    local lookup_dir=$6
    local completed_state=$7
    local progress_state=$8
    local smart_cache=$9  # Multi-layer smart cache file
    
    # OPTIMIZATION 2: Load ALL lookup data into memory once (avoid repeated disk I/O)
    declare -A file_map checksum_map hash_map fingerprint_map size_map
    
    # Load file list
    while IFS='|' read -r idx filepath; do
        file_map["$idx"]="$filepath"
    done < "$lookup_dir/files.txt"
    
    # Load checksums
    while IFS='|' read -r filepath checksum; do
        checksum_map["$filepath"]="$checksum"
    done < "$lookup_dir/checksums.txt"
    
    # Load visual hashes
    while IFS='|' read -r filepath hash; do
        hash_map["$filepath"]="$hash"
    done < "$lookup_dir/visual_hashes.txt"
    
    # Load fingerprints
    while IFS='|' read -r filepath fp; do
        fingerprint_map["$filepath"]="$fp"
    done < "$lookup_dir/fingerprints.txt"
    
    # Load sizes
    while IFS='|' read -r filepath size; do
        size_map["$filepath"]="$size"
    done < "$lookup_dir/sizes.txt"
    
    # OPTIMIZATION 3: Batch results in memory
    local batch_results=()
    local batch_completed=()
    local batch_progress_state=()
    local batch_count=0
    local batch_size=100
    local comparisons_done=0
    
    while true; do
        # Atomic queue pop - use exec to avoid subshell
        local pair
        exec 200>"$lockfile"
        flock -x 200
        pair=$(head -n 1 "$queue" 2>/dev/null)
        if [[ -n "$pair" ]]; then
            sed -i '1d' "$queue"
        fi
        flock -u 200
        exec 200>&-
        
        [[ -z "$pair" ]] && break
        
        local i=$(echo "$pair" | cut -d'|' -f1)
        local j=$(echo "$pair" | cut -d'|' -f2)
        local pair_hash=$(echo "$pair" | cut -d'|' -f3)
        
        # Get files from in-memory map (OPTIMIZATION 2)
        local file1="${file_map[$i]}"
        local file2="${file_map[$j]}"
        
        [[ -z "$file1" || -z "$file2" ]] && continue
        
        # Get checksums from in-memory map (OPTIMIZATION 2)
        local checksum1="${checksum_map[$file1]}"
        local checksum2="${checksum_map[$file2]}"
        
        # Start timing for cache
        local start_time=$(date +%s%N)
        
        local duplicate_found=""
        local cache_result="NOT_DUPLICATE"
        
        # Level 1: Checksum match
        if [[ -n "$checksum1" && -n "$checksum2" && "$checksum1" == "$checksum2" ]]; then
            duplicate_found="LEVEL1|100|$file1|$file2|Exact binary match"
            cache_result="DUPLICATE_Level1"
        fi
        
        # Level 2: Visual hash (OPTIMIZATION 2: in-memory lookup)
        if [[ -z "$duplicate_found" ]]; then
            local hash1="${hash_map[$file1]}"
            local hash2="${hash_map[$file2]}"
            if [[ -n "$hash1" && -n "$hash2" && "$hash1" == "$hash2" ]]; then
                duplicate_found="LEVEL2|95|$file1|$file2|Identical visual fingerprint"
                cache_result="DUPLICATE_Level2"
            fi
        fi
        
        # Level 3: Content fingerprint (OPTIMIZATION 2: in-memory lookup)
        if [[ -z "$duplicate_found" ]]; then
            local fp1="${fingerprint_map[$file1]}"
            local fp2="${fingerprint_map[$file2]}"
            if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                local size1="${size_map[$file1]:-0}"
                local size2="${size_map[$file2]:-0}"
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_ratio=$(( (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                    if [[ $size_ratio -ge 95 ]]; then
                        duplicate_found="LEVEL3|90|$file1|$file2|Identical metadata + similar size"
                        cache_result="DUPLICATE_Level3"
                    fi
                fi
            fi
        fi
        
        # Calculate comparison duration
        local end_time=$(date +%s%N)
        local duration_ms=$(( (end_time - start_time) / 1000000 ))
        
        # OPTIMIZATION 3: Batch results in memory
        [[ -n "$duplicate_found" ]] && batch_results+=("$duplicate_found")
        batch_completed+=("$pair_hash")
        batch_progress_state+=("$pair_hash")
        ((batch_count++))
        ((comparisons_done++))
        
        # Update progress immediately for live progress bar (lightweight)
        exec 200>"$lockfile"
        flock -x 200
        local current=$(cat "$progress")
        echo $((current + 1)) > "$progress"
        flock -u 200
        exec 200>&-
        
        # Save to smart cache (still immediate for persistence)
        if [[ -n "$smart_cache" && -n "$checksum1" && -n "$checksum2" ]]; then
            save_comparison_to_cache "$smart_cache" "$pair_hash" "$checksum1" "$checksum2" "$cache_result" "$duration_ms"
        fi
        
        # Flush batch when full
            if [[ $batch_count -ge $batch_size ]]; then
            exec 200>"$lockfile"
            flock -x 200
            
            # Write all batched results
            for result in "${batch_results[@]}"; do
                echo "$result" >> "$results"
            done
            
            # Write all completed pairs
            for pair in "${batch_completed[@]}"; do
                echo "$pair" >> "$completed_state"
            done
            
            for pair in "${batch_progress_state[@]}"; do
                echo "$pair" >> "$progress_state"
            done
            
            flock -u 200
            exec 200>&-
            
            # Clear batches
            batch_results=()
            batch_completed=()
            batch_progress_state=()
            batch_count=0
        fi
    done
    
    # Flush remaining batch at end
    if [[ $batch_count -gt 0 ]]; then
        exec 200>"$lockfile"
        flock -x 200
        
        for result in "${batch_results[@]}"; do
            echo "$result" >> "$results"
        done
        
        for pair in "${batch_completed[@]}"; do
            echo "$pair" >> "$completed_state"
        done
        
        for pair in "${batch_progress_state[@]}"; do
            echo "$pair" >> "$progress_state"
        done
        
        flock -u 200
        exec 200>&-
    fi
}

# ðŸŽ¬ AI-Powered Video Duplicate Detection with Multi-Level Analysis
detect_duplicate_videos() {
    echo -e "${BLUE}${BOLD}ðŸŽ¬ AI-Enhanced Parallel Video Duplicate Detection${NC}"
    echo -e "${CYAN}ðŸ”¬ Multi-threaded analysis: Binary + Metadata + Visual + Filename + Frame comparison...${NC}"
    echo -e "${GREEN}âš¡ Using ${BOLD}$AI_DUPLICATE_THREADS${NC}${GREEN} CPU threads for maximum performance!${NC}"
    
    # Initialize all cache and AI systems
    init_hash_system  # Must be first - sets HASH_ALGORITHM
    init_video_cache
    init_ai_cache
    init_ai_training
    init_checksum_cache
    
    local video_cache_dir="${GIF_CONVERTER_DIR}/video_cache"
    local cache_stats=$(get_video_cache_stats)
    local ai_cache_stats=$(get_cache_stats)
    local training_stats=$(get_ai_training_stats)
    local checksum_cache_stats=$(get_checksum_cache_stats)
    
    echo -e "${BLUE}ðŸ—„ï¸ Video Cache: $cache_stats${NC}"
    echo -e "${BLUE}ðŸ—„ï¸ AI Cache: $ai_cache_stats${NC}"
    echo -e "${GREEN}ðŸ§  AI Training: $training_stats${NC}"
    echo -e "${CYAN}ðŸ” Checksum Cache: $checksum_cache_stats${NC}"
    
    # ðŸ’¾ Show Level 6 cache statistics (remembered comparisons)
    if [[ -f "$AI_CACHE_INDEX" ]]; then
        local l6_cached_count=$(grep -c '^L6_VIDEO_COMPARE:' "$AI_CACHE_INDEX" 2>/dev/null || echo "0")
        # Trim whitespace/newlines and validate
        l6_cached_count=$(echo "$l6_cached_count" | tr -d '\n\r' | grep -o '[0-9]*' || echo "0")
        [[ -z "$l6_cached_count" ]] && l6_cached_count="0"
        
        if [[ $l6_cached_count -gt 0 ]]; then
            echo -e "${MAGENTA}ðŸ’¾ Level 6 Cache: ${BOLD}$l6_cached_count${NC}${MAGENTA} video pair comparisons remembered${NC}"
            echo -e "  ${GRAY}â†’ These will load instantly without re-analysis${NC}"
        fi
    fi
    
    local total_videos=0
    local duplicate_count=0
    local duplicate_pairs=()
    declare -A video_checksums
    declare -A video_sizes
    declare -A video_fingerprints
    declare -A video_visual_hashes
    declare -A video_durations
    declare -A video_resolutions
    declare -A video_bitrates
    declare -A video_codecs
    declare -A video_fps_values
    declare -A video_formats
    
    # Create temporary directory for analysis in persistent location
    local temp_analysis_dir="${GIF_CONVERTER_DIR}/temp/video/analysis_$$"
    mkdir -p "$temp_analysis_dir"
    # Cleanup old temp directories (older than 1 day)
    find "${GIF_CONVERTER_DIR}/temp/video" -maxdepth 1 -name "analysis_*" -type d -mtime +1 -exec rm -rf {} \; 2>/dev/null || true
    # NOTE: Don't set EXIT trap here - cleanup happens after workers complete
    
    # Count total video files first for progress calculation
    local video_files_list=()
    declare -A seen_video_files  # Track files to avoid duplicates
    
    echo -e "  ${CYAN}ðŸ” Scanning video files...${NC}"
    
    shopt -s nullglob
    
    # Comprehensive video format support
    local all_videos=(*.mp4 *.MP4 *.avi *.AVI *.mov *.MOV *.mkv *.MKV *.webm *.WEBM \
                      *.m4v *.M4V *.flv *.FLV *.wmv *.WMV *.mpg *.MPG *.mpeg *.MPEG \
                      *.3gp *.3GP *.ogv *.OGV *.ts *.TS *.mts *.MTS *.m2ts *.M2TS)
    
    local total_to_scan=${#all_videos[@]}
    local scan_count=0
    
    # Detailed scanning with progress bar
    for video_file in "${all_videos[@]}"; do
        if [[ -f "$video_file" && -z "${seen_video_files["$video_file"]}" ]]; then
            video_files_list+=("$video_file")
            seen_video_files["$video_file"]=1
            ((scan_count++))
            
            # Show progress bar every few files
            if [[ $((scan_count % 5)) -eq 0 || $scan_count -eq $total_to_scan ]]; then
                local progress=$((scan_count * 100 / total_to_scan))
                local filled=$((progress * 20 / 100))
                local empty=$((20 - filled))
                
                # Truncate filename if too long
                local display_name="$(basename -- "$video_file")"
                if [[ ${#display_name} -gt 50 ]]; then
                    display_name="${display_name:0:47}..."
                fi
                
                printf "\r  ${CYAN}["
                for ((j=0; j<filled; j++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((j=0; j<empty; j++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}Found %d files${NC}" "$progress" "$scan_count"
                printf "\n  ${GRAY}ðŸ“„ %s${NC}" "$display_name"
                printf "\r\033[1A"  # Move cursor back up to progress bar line
            fi
        fi
    done
    shopt -u nullglob
    
    # Show final count
    printf "\r  ${GREEN}["
    for ((j=0; j<20; j++)); do printf "${GREEN}â–ˆ${NC}"; done
    printf "${GREEN}] ${BOLD}100%%${NC} ${BLUE}Found %d video files${NC}\n" "$scan_count"
    printf "\033[K\n"  # Clear the file name line
    
    # Remove any duplicates from the array
    local unique_files_list=()
    declare -A dedup_tracker
    for video_file in "${video_files_list[@]}"; do
        if [[ -z "${dedup_tracker["$video_file"]}" ]]; then
            unique_files_list+=("$video_file")
            dedup_tracker["$video_file"]=1
        fi
    done
    video_files_list=("${unique_files_list[@]}")
    
    local total_files=${#video_files_list[@]}
    if [[ $total_files -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No video files found${NC}"
        return 0
    fi
    
    # ðŸ§  DYNAMIC AI DECISION ENGINE
    # AI will intelligently evaluate EACH pair in real-time
    if [[ "${AI_AUTO_OPTIMIZE:-true}" == "true" ]]; then
        echo -e "  ${MAGENTA}${BOLD}ðŸ§  AI Dynamic Decision Engine: Active${NC}"
        echo -e "    ${CYAN}ðŸ“Š Collection: $total_files files ($(( total_files * (total_files - 1) / 2 )) comparisons)${NC}"
        echo -e "    ${CYAN}âš¡ Resources: $CPU_CORES cores, $(free -g 2>/dev/null | awk '/^Mem:/{print $2}' || echo '?')GB RAM${NC}"
        echo -e "    ${GREEN}âœ“ AI will evaluate each pair dynamically with real-time intelligence${NC}"
        echo -e "      ${GRAY}â†’ Level 6: Adaptive threshold based on collection size & pair similarity${NC}"
        echo ""
    fi
    
    # Calculate total size and estimate time
    local total_size=0
    for video_file in "${video_files_list[@]}"; do
        local file_size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
        total_size=$((total_size + file_size))
    done
    
    # Convert to human readable
    local total_size_mb=$((total_size / 1024 / 1024))
    local total_size_gb=$((total_size_mb / 1024))
    local estimated_time_sec=$((total_files * 3))  # Rough estimate: 3 seconds per video
    local estimated_time_min=$((estimated_time_sec / 60))
    
    # Display size with appropriate unit
    if [[ $total_size_gb -gt 0 ]]; then
        echo -e "  ${YELLOW}ðŸ“Š Processing ${BOLD}${total_files}${NC}${YELLOW} video files (${BOLD}${total_size_gb}GB${NC}${YELLOW} total)${NC}"
    else
        echo -e "  ${YELLOW}ðŸ“Š Processing ${BOLD}${total_files}${NC}${YELLOW} video files (${BOLD}${total_size_mb}MB${NC}${YELLOW} total)${NC}"
    fi
    echo -e "  ${CYAN}â±ï¸  Estimated time: ~${estimated_time_min} minutes (varies by file size & format)${NC}"
    echo -e "  ${GRAY}ðŸ’¡ Larger files and different formats take longer to analyze${NC}"
    
    # Show sample files after scanning complete (truncated for readability)
    local samples=""
    for ((i=0; i<3 && i<${#video_files_list[@]}; i++)); do
        local fname="$(basename -- "${video_files_list[$i]}")"
        # Truncate long filenames
        if [[ ${#fname} -gt 30 ]]; then
            fname="${fname:0:27}..."
        fi
        samples+="$fname, "
    done
    echo -e "  ${GRAY}ðŸ“‚ Sample: ${samples}...${NC}"
    
    # Pre-scan for cached files
    echo -e "  ${BLUE}${BOLD}ðŸ” Checking video cache...${NC}"
    local files_to_analyze=0
    local files_cached=0
    declare -a uncached_files_list
    
    # Load cache index
    local video_cache_index="$video_cache_dir/video_analysis.db"
    declare -A cache_lookup
    if [[ -f "$video_cache_index" ]]; then
        while IFS='|' read -r filename filesize filemtime timestamp analysis_data; do
            [[ "$filename" =~ ^# ]] && continue
            [[ -z "$filename" ]] && continue
            cache_lookup["$filename"]="${filesize}:${filemtime}|${analysis_data}"
        done < <(tail -n +4 "$video_cache_index" 2>/dev/null)
    fi
    
    # Initialize results file
    local results_file="$temp_analysis_dir/video_results.txt"
    : > "$results_file"
    
    # Check each file against cache
    for video_file in "${video_files_list[@]}"; do
        [[ -f "$video_file" ]] || continue
        local basename=$(basename -- "$video_file")
        local needs_analysis=true
        
        if [[ -n "${cache_lookup[$basename]}" ]]; then
            local cached_entry="${cache_lookup[$basename]}"
            local cached_fingerprint=$(echo "$cached_entry" | cut -d'|' -f1)
            local cached_data=$(echo "$cached_entry" | cut -d'|' -f2-)
            
            local current_filesize=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
            local current_filemtime=$(stat -c%Y -- "$video_file" 2>/dev/null || echo "0")
            local current_fingerprint="${current_filesize}:${current_filemtime}"
            
            if [[ "$cached_fingerprint" == "$current_fingerprint" ]]; then
                ((files_cached++))
                needs_analysis=false
                # Write cached data but replace first field with full path
                local cached_checksum=$(echo "$cached_data" | cut -d'|' -f2)
                local cached_rest=$(echo "$cached_data" | cut -d'|' -f3-)
                echo "$video_file|$cached_checksum|$cached_rest" >> "$results_file"
            fi
        fi
        
        if [[ "$needs_analysis" == "true" ]]; then
            uncached_files_list+=("$video_file")
            ((files_to_analyze++))
        fi
    done
    
    unset cache_lookup
    
    echo -e "  ${BLUE}${BOLD}ðŸ§  Stage 1: Video fingerprinting (${AI_DUPLICATE_THREADS} threads)...${NC}"
    if [[ $files_cached -gt 0 ]]; then
        echo -e "  ${GREEN}ðŸ’¾ Cached: ${BOLD}${files_cached}${NC}${GREEN} files (instant)${NC}"
        echo -e "  ${CYAN}âš¡ To analyze: ${BOLD}${files_to_analyze}${NC}${CYAN} files${NC}"
    fi
    
    # Parallel video analysis function with AI health detection
    analyze_video_parallel() {
        local video_file="$1"
        local temp_dir="$2"
        local result_file="$3"
        local current_index="$4"
        local total_files="$5"
        local timeout_seconds=90
        
        # Check if file exists and is readable
        if [[ ! -f "$video_file" ]]; then
            local error_msg="File not found: $video_file"
            log_error "$error_msg" "$video_file" "File missing during duplicate detection"
            echo "$video_file|ERROR|0|||0|0x0|unknown" >> "$result_file"
            return 1
        elif [[ ! -r "$video_file" ]]; then
            local error_msg="File not readable: $video_file (permissions issue)"
            log_error "$error_msg" "$video_file" "Permission denied during duplicate detection"
            echo "$video_file|ERROR|0|||0|0x0|unknown" >> "$result_file"
            return 1
        fi
        
        # Check cache first
        local cached_analysis=$(check_video_cache "$video_file" 2>/dev/null)
        if [[ $? -eq 0 && -n "$cached_analysis" ]]; then
            echo "$cached_analysis" >> "$result_file"
            if [[ -n "$current_index" && -n "$total_files" ]]; then
                update_file_progress "$current_index" "$total_files" "$(basename -- "$video_file") [cached]" "Analyzing videos" 30
            fi
            return 0
        fi
        
        # Display progress
        if [[ -n "$current_index" && -n "$total_files" ]]; then
            update_file_progress "$current_index" "$total_files" "$(basename -- "$video_file")" "Analyzing videos" 30
        fi
        
        # Stage 1: Fast MD5 checksum with intelligent caching
        local checksum
        local size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
        
        # Try to get cached checksum first
        checksum=$(get_cached_checksum "$video_file" 2>/dev/null)
        
        # If cache failed, calculate with timeout
        if [[ -z "$checksum" ]]; then
            # Use fast hash (xxhash/blake3/md5) - dramatically faster!
            if checksum=$(timeout 20 fast_hash "$video_file" 2>/dev/null); then
                [[ -z "$checksum" ]] && checksum="ERROR"
            else
                checksum="TIMEOUT_HASH"
                echo -e "  ${YELLOW}â° Hash timeout: $(basename -- "$video_file")${NC}" >&2
            fi
        fi
        
        # Check if hash calculation failed or timed out (likely corruption)
        if [[ "$checksum" == "ERROR" || "$checksum" == "TIMEOUT_HASH" ]]; then
            local failure_reason
            if [[ "$checksum" == "TIMEOUT_HASH" ]]; then
                failure_reason="Hash calculation timed out - likely severely corrupted or very large file"
                echo -e "  ${RED}ðŸš« Corrupted file (hash timeout): $(basename -- "$video_file")${NC}" >&2
            else
                failure_reason="Hash calculation failed - file may be corrupted"
            fi
            
            # Use AI to verify if this is truly corrupted or just a large file
            local ai_health_verdict="SKIP"
            if command -v ffprobe >/dev/null 2>&1; then
                # Quick ffprobe check
                if timeout 5 ffprobe -v error "$video_file" >/dev/null 2>&1; then
                    ai_health_verdict="LARGE_FILE"
                else
                    ai_health_verdict="CORRUPTED"
                fi
            fi
            
            if [[ "$ai_health_verdict" == "LARGE_FILE" ]]; then
                # File is OK, just large - continue without MD5
                checksum="LARGE_FILE_NO_MD5"
                echo -e "  ${YELLOW}ðŸ“¦ Large file, skipping MD5: $(basename -- "$video_file")${NC}" >&2
            else
                local error_msg="Cannot calculate MD5 hash: $video_file ($failure_reason)"
                log_error "$error_msg" "$video_file" "$failure_reason"
                echo "$video_file|CORRUPTED|$size|unknown||0|0x0|unknown" >> "$result_file"
                return 1
            fi
        fi
        
        # Stage 2: Enhanced metadata extraction with FFprobe
        local duration="0"
        local resolution="unknown"
        local bitrate="0"
        local codec="unknown"
        local fps="0"
        local width="0"
        local height="0"
        local format="unknown"
        local perceptual_hash=""
        
        # Detect format from file extension
        local file_ext="${video_file##*.}"
        format="${file_ext,,}"  # Lowercase
        
        if command -v ffprobe >/dev/null 2>&1; then
            # Comprehensive metadata extraction - timeout after 8 seconds
            local ffprobe_output=$(timeout 8 ffprobe -v error -select_streams v:0 \
                -show_entries stream=duration,width,height,bit_rate,codec_name,r_frame_rate,pix_fmt \
                -show_entries format=format_name,size \
                -of csv=p=0 "$video_file" 2>/dev/null)
            
            if [[ -n "$ffprobe_output" ]]; then
                # Parse output carefully
                duration=$(echo "$ffprobe_output" | head -1 | cut -d',' -f1 | cut -d'.' -f1)
                width=$(echo "$ffprobe_output" | head -1 | cut -d',' -f2)
                height=$(echo "$ffprobe_output" | head -1 | cut -d',' -f3)
                bitrate=$(echo "$ffprobe_output" | head -1 | cut -d',' -f4)
                codec=$(echo "$ffprobe_output" | head -1 | cut -d',' -f5)
                local fps_frac=$(echo "$ffprobe_output" | head -1 | cut -d',' -f6)
                
                # Calculate FPS from fraction
                if [[ "$fps_frac" =~ ^[0-9]+/[0-9]+$ ]]; then
                    local num=$(echo "$fps_frac" | cut -d'/' -f1)
                    local den=$(echo "$fps_frac" | cut -d'/' -f2)
                    if [[ $den -gt 0 ]]; then
                        fps=$((num / den))
                    fi
                fi
                
                resolution="${width}x${height}"
                
                # Ensure we have valid numbers
                [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
                [[ ! "$bitrate" =~ ^[0-9]+$ ]] && bitrate="0"
                [[ ! "$fps" =~ ^[0-9]+$ ]] && fps="0"
                [[ ! "$width" =~ ^[0-9]+$ ]] && width="0"
                [[ ! "$height" =~ ^[0-9]+$ ]] && height="0"
            fi
        fi
        
        # AI-powered perceptual hash for visual similarity detection
        # Extract middle frame and create perceptual hash
        if [[ "$duration" -gt 0 ]] && command -v ffmpeg >/dev/null 2>&1; then
            local temp_frame="$temp_dir/vframe_${RANDOM}.png"
            local middle_time=$((duration / 2))
            
            # Extract frame from middle of video
            if timeout 8 ffmpeg -ss $middle_time -i "$video_file" -vframes 1 \
                -f image2 "$temp_frame" >/dev/null 2>&1; then
                
                if command -v convert >/dev/null 2>&1; then
                    # Create simple perceptual hash: average hash (aHash) algorithm
                    # Resize to 8x8, convert to grayscale, get average brightness
                    perceptual_hash=$(convert "$temp_frame" -resize 8x8! -colorspace gray \
                        -format "%[fx:mean]" info: 2>/dev/null | tr -d '.')
                    
                    # Validate hash
                    if [[ -z "$perceptual_hash" || ${#perceptual_hash} -lt 3 ]]; then
                        perceptual_hash=""
                    fi
                fi
                rm -f "$temp_frame" 2>/dev/null
            fi
        fi
        
        # Fallback to basic file validation if FFprobe unavailable or failed
        if [[ "$resolution" == "unknown" || "$duration" == "0" ]]; then
            local file_info=$(file "$video_file" 2>/dev/null || echo "unknown")
            if [[ "$file_info" =~ (video|Video|MPEG|MP4|AVI|MKV|WebM) ]]; then
                resolution="valid_video"
            elif [[ "$file_info" == *"data"* ]] && [[ $size -gt 10240 ]]; then
                resolution="possible_video"
            else
                resolution="invalid_format"
            fi
        fi
        
        # Create enhanced content fingerprint with codec and format data
        local content_fingerprint="${size}:${resolution}:${duration}:${bitrate}:${fps}:${codec}:${format}"
        
        # Format: filename|checksum|size|content_fingerprint|perceptual_hash|duration|resolution|codec|format
        local analysis_result="$video_file|$checksum|$size|$content_fingerprint|$perceptual_hash|$duration|$resolution|$codec|$format"
        
        # Write results atomically
        echo "$analysis_result" >> "$result_file"
        
        # Save to cache for future runs
        save_video_analysis_to_cache "$video_file" "$analysis_result"
        
        return 0
    }
    
    # Export function for parallel execution (if needed)
    export -f analyze_video_parallel 2>/dev/null || true
    
    # Optimized version that uses pre-calculated hash from parallel batch
    analyze_video_with_hash() {
        local video_file="$1"
        local checksum="$2"  # Pre-calculated hash!
        local temp_dir="$3"
        local result_file="$4"
        local current_index="$5"
        local total_files="$6"
        
        # Display progress
        if [[ -n "$current_index" && -n "$total_files" ]]; then
            update_file_progress "$current_index" "$total_files" "$(basename -- "$video_file")" "Analyzing metadata" 30
        fi
        
        local size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
        
        # Stage 2: Enhanced metadata extraction with FFprobe (hash already done!)
        local duration="0"
        local resolution="unknown"
        local bitrate="0"
        local codec="unknown"
        local fps="0"
        local width="0"
        local height="0"
        local format="unknown"
        local perceptual_hash=""
        
        # Detect format from file extension
        local file_ext="${video_file##*.}"
        format="${file_ext,,}"  # Lowercase
        
        if command -v ffprobe >/dev/null 2>&1; then
            local ffprobe_output=$(timeout 8 ffprobe -v error -select_streams v:0 \
                -show_entries stream=duration,width,height,bit_rate,codec_name,r_frame_rate \
                -show_entries format=format_name,size \
                -of csv=p=0 "$video_file" 2>/dev/null)
            
            if [[ -n "$ffprobe_output" ]]; then
                duration=$(echo "$ffprobe_output" | head -1 | cut -d',' -f1 | cut -d'.' -f1)
                width=$(echo "$ffprobe_output" | head -1 | cut -d',' -f2)
                height=$(echo "$ffprobe_output" | head -1 | cut -d',' -f3)
                bitrate=$(echo "$ffprobe_output" | head -1 | cut -d',' -f4)
                codec=$(echo "$ffprobe_output" | head -1 | cut -d',' -f5)
                local fps_frac=$(echo "$ffprobe_output" | head -1 | cut -d',' -f6)
                
                if [[ "$fps_frac" =~ ^[0-9]+/[0-9]+$ ]]; then
                    local num=$(echo "$fps_frac" | cut -d'/' -f1)
                    local den=$(echo "$fps_frac" | cut -d'/' -f2)
                    [[ $den -gt 0 ]] && fps=$((num / den))
                fi
                
                resolution="${width}x${height}"
                [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
                [[ ! "$bitrate" =~ ^[0-9]+$ ]] && bitrate="0"
                [[ ! "$fps" =~ ^[0-9]+$ ]] && fps="0"
            fi
        fi
        
        # Create content fingerprint
        local content_fingerprint="${size}:${resolution}:${duration}:${bitrate}:${fps}:${codec}:${format}"
        
        # Format results
        local analysis_result="$video_file|$checksum|$size|$content_fingerprint|$perceptual_hash|$duration|$resolution|$codec|$format"
        
        # Write results atomically
        echo "$analysis_result" >> "$result_file"
        
        # Save to cache
        save_video_analysis_to_cache "$video_file" "$analysis_result"
        
        return 0
    }
    
    # Track cache statistics
    local cache_hits=0
    local cache_misses=0
    
    # Process files with progress tracking
    if [[ $files_to_analyze -gt 0 ]]; then
        echo -e "  ${BLUE}ðŸš€ Processing ${files_to_analyze} video files using TRUE parallel hashing (${AI_DUPLICATE_THREADS} threads)${NC}"
        echo -e "  ${GREEN}ðŸ’¾ Skipping ${files_cached} cached files (instant load)${NC}"
        echo -e "  ${CYAN}âš¡ Hash algorithm: ${HASH_ALGORITHM} (${HASH_SPEED})${NC}"
    else
        echo -e "  ${GREEN}ðŸš€ All ${total_files} video files are cached - loading instantly!${NC}"
    fi
    echo -e "  ${GRAY}ðŸ”ˆ Cache-enabled: Files analyzed before will load instantly!${NC}"
    
    # ðŸš€ REVOLUTIONARY: TRUE PARALLEL BATCH HASHING!
    # Instead of hashing one file at a time, hash ALL files at once using all CPU cores
    if [[ $files_to_analyze -gt 0 ]]; then
        echo -e "  ${MAGENTA}ðŸ”¥ Using parallel batch hashing for ${files_to_analyze} files...${NC}"
        
        # Create temporary file for batch hash results
        local batch_hash_file="$temp_analysis_dir/batch_hashes.txt"
        : > "$batch_hash_file"
        
        # Use parallel_hash_batch to hash ALL uncached files at once!
        parallel_hash_batch uncached_files_list "$batch_hash_file"
        
        echo -e "  ${GREEN}âœ“ Pre-calculated ${files_to_analyze} hashes in parallel${NC}"
        
        # ðŸš€ PARALLEL METADATA EXTRACTION with progress bar
        if command -v parallel >/dev/null 2>&1 && [[ $files_to_analyze -gt 5 ]]; then
            echo -e "  ${MAGENTA}ðŸš€ Analyzing metadata in parallel (${AI_DUPLICATE_THREADS} threads)...${NC}"
            
            # Create parallel metadata extraction script
            local metadata_script="$temp_analysis_dir/extract_metadata.sh"
            local metadata_results="$temp_analysis_dir/metadata_out.txt"
            local progress_counter="$temp_analysis_dir/meta_progress.txt"
            echo "0" > "$progress_counter"
            
            cat > "$metadata_script" << 'META_EOF'
#!/bin/bash
extract_video_metadata() {
    local video_file="$1"
    local checksum="$2"
    local progress_file="$3"
    
    local size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
    local duration="0"
    local resolution="unknown"
    local bitrate="0"
    local codec="unknown"
    local fps="0"
    local width="0"
    local height="0"
    local format="${video_file##*.}"
    format="${format,,}"
    local perceptual_hash=""
    
    if command -v ffprobe >/dev/null 2>&1; then
        local ffprobe_output=$(timeout 8 ffprobe -v error -select_streams v:0 \
            -show_entries stream=duration,width,height,bit_rate,codec_name,r_frame_rate \
            -of csv=p=0 "$video_file" 2>/dev/null)
        
        if [[ -n "$ffprobe_output" ]]; then
            duration=$(echo "$ffprobe_output" | head -1 | cut -d',' -f1 | cut -d'.' -f1)
            width=$(echo "$ffprobe_output" | head -1 | cut -d',' -f2)
            height=$(echo "$ffprobe_output" | head -1 | cut -d',' -f3)
            bitrate=$(echo "$ffprobe_output" | head -1 | cut -d',' -f4)
            codec=$(echo "$ffprobe_output" | head -1 | cut -d',' -f5)
            local fps_frac=$(echo "$ffprobe_output" | head -1 | cut -d',' -f6)
            
            if [[ "$fps_frac" =~ ^[0-9]+/[0-9]+$ ]]; then
                local num=$(echo "$fps_frac" | cut -d'/' -f1)
                local den=$(echo "$fps_frac" | cut -d'/' -f2)
                [[ $den -gt 0 ]] && fps=$((num / den))
            fi
            
            resolution="${width}x${height}"
            [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
            [[ ! "$bitrate" =~ ^[0-9]+$ ]] && bitrate="0"
            [[ ! "$fps" =~ ^[0-9]+$ ]] && fps="0"
        fi
    fi
    
    # Update progress
    if [[ -n "$progress_file" ]]; then
        flock -x "$progress_file" bash -c 'echo $(($(cat "$1" 2>/dev/null || echo 0) + 1)) > "$1"' _ "$progress_file" 2>/dev/null || true
    fi
    
    local content_fingerprint="${size}:${resolution}:${duration}:${bitrate}:${fps}:${codec}:${format}"
    echo "$video_file|$checksum|$size|$content_fingerprint|$perceptual_hash|$duration|$resolution|$codec|$format"
}
export -f extract_video_metadata
META_EOF
            chmod +x "$metadata_script"
            
            # Create input file with video paths and hashes
            local metadata_input="$temp_analysis_dir/metadata_input.txt"
            : > "$metadata_input"
            while read -r hash_value filepath; do
                [[ -n "$filepath" && -f "$filepath" ]] && echo "$filepath	$hash_value" >> "$metadata_input"
            done < "$batch_hash_file"
            
            # Start parallel processing in background
            source "$metadata_script"
            (
                cat "$metadata_input" | parallel --colsep '\t' -j "$AI_DUPLICATE_THREADS" \
                    "extract_video_metadata {1} {2} '$progress_counter'" > "$metadata_results" 2>/dev/null
            ) &
            local parallel_pid=$!
            
            # Monitor progress with live progress bar
            local last_count=0
            while kill -0 $parallel_pid 2>/dev/null; do
                local current_count=$(cat "$progress_counter" 2>/dev/null || echo "0")
                
                if [[ $current_count -ne $last_count || $current_count -eq 0 ]]; then
                    # Validate numbers before division
                    [[ ! "$current_count" =~ ^[0-9]+$ ]] && current_count=0
                    [[ ! "$files_to_analyze" =~ ^[0-9]+$ || $files_to_analyze -eq 0 ]] && files_to_analyze=1
                    
                    local progress=$((current_count * 100 / files_to_analyze))
                    [[ $progress -gt 100 ]] && progress=100
                    local filled=$((progress * 30 / 100))
                    local empty=$((30 - filled))
                    
                    printf "\r  ${CYAN}["
                    for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                    for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                    printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d videos)${NC}" "$progress" "$current_count" "$files_to_analyze"
                    
                    last_count=$current_count
                fi
                
                sleep 0.2
            done
            
            # Wait for completion
            wait $parallel_pid 2>/dev/null
            
            # Show final 100%
            printf "\r  ${CYAN}["
            for ((k=0; k<30; k++)); do printf "${GREEN}â–ˆ${NC}"; done
            printf "${CYAN}] ${BOLD}100%%${NC} ${GRAY}(%d/%d videos)${NC}\n" "$files_to_analyze" "$files_to_analyze"
            
            # Append results to main file and save to cache
            while IFS='|' read -r filepath checksum size fingerprint phash duration resolution codec format; do
                [[ -z "$filepath" ]] && continue
                echo "$filepath|$checksum|$size|$fingerprint|$phash|$duration|$resolution|$codec|$format" >> "$results_file"
                save_video_analysis_to_cache "$filepath" "$filepath|$checksum|$size|$fingerprint|$phash|$duration|$resolution|$codec|$format"
            done < "$metadata_results"
            
        else
            # Sequential fallback
            echo -e "  ${YELLOW}âš ï¸  Processing metadata sequentially...${NC}"
        # Now process each file with its pre-calculated hash
        local loop_idx=0
        for video_file in "${uncached_files_list[@]}"; do
            # Check if user requested interrupt (Ctrl+C)
            if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
                echo -e "\\n  ${YELLOW}â¸ï¸  Analysis interrupted by user${NC}"
                echo -e "  ${CYAN}ðŸ’¾ Processed: $loop_idx, Cached: $files_cached${NC}"
                break
            fi
            
            ((loop_idx++))
            
            # Get pre-calculated hash from batch results
            local checksum=$(grep -F "$video_file" "$batch_hash_file" 2>/dev/null | awk '{print $1}')
            
            # If hash failed, mark as error
            if [[ -z "$checksum" || "$checksum" == "ERROR" ]]; then
                checksum="ERROR"
            fi
            
            # Now analyze with pre-calculated hash (skip hash calculation)
            analyze_video_with_hash "$video_file" "$checksum" "$temp_analysis_dir" "$results_file" "$loop_idx" "$files_to_analyze"
        done
        fi  # End of parallel/sequential metadata extraction
        
        # Clean up batch hash file
        rm -f "$batch_hash_file" 2>/dev/null
    fi
    
    echo -e "  ${GREEN}âœ“ Stage 1 complete${NC}"
    
    # DEBUG: Check results file
    local results_line_count=$(wc -l < "$results_file" 2>/dev/null || echo "0")
    echo -e "  ${YELLOW}DEBUG: Results file has $results_line_count lines${NC}"
    if [[ $results_line_count -eq 0 ]]; then
        echo -e "  ${RED}ERROR: Results file is empty! Path: $results_file${NC}"
        echo -e "  ${YELLOW}This means all files failed analysis or cache lookup failed${NC}"
    fi
    
    # SANITY CHECK: Verify checksums detect duplicates
    echo -e "  ${CYAN}ðŸ” Sanity check: Validating checksum uniqueness...${NC}"
    # Note: head may close the pipe early which can cause uniq to get SIGPIPE and print
    # "Broken pipe" warnings. We silence uniq's stderr to avoid noisy but harmless messages.
    local duplicate_checksums=$(cut -d'|' -f2 "$results_file" | sort | uniq -d 2>/dev/null | wc -l)
    if [[ $duplicate_checksums -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ Found $duplicate_checksums duplicate checksum(s) - detection working!${NC}"
        # Show sample duplicates
        local sample_dup=$(cut -d'|' -f2 "$results_file" | sort | uniq -d 2>/dev/null | head -1)
        if [[ -n "$sample_dup" ]]; then
            echo -e "  ${GRAY}  Sample: Files with checksum ${sample_dup:0:16}...${NC}"
            grep "|$sample_dup|" "$results_file" | cut -d'|' -f1 | while read fname; do
                echo -e "  ${GRAY}    - $(basename "$fname")${NC}"
            done | head -3
        fi
    else
        echo -e "  ${YELLOW}âš  No duplicate checksums found in Stage 1${NC}"
        echo -e "  ${GRAY}  This could mean:${NC}"
        echo -e "  ${GRAY}  - All files are truly unique${NC}"
        echo -e "  ${GRAY}  - OR cache has stale/mixed hash algorithms${NC}"
    fi
    
    # Parse results and build comprehensive lookup tables
    # Build a basename->fullpath mapping for results file entries
    declare -A basename_to_fullpath
    for fullpath in "${video_files_list[@]}"; do
        local bn=$(basename "$fullpath")
        basename_to_fullpath["$bn"]="$fullpath"
    done
    
    local processed_count=0
    declare -A format_counts
    
    while IFS='|' read -r filename checksum size fingerprint perceptual_hash duration resolution codec format; do
        [[ -z "$filename" || "$checksum" == "ERROR" || "$checksum" == "CORRUPTED" ]] && continue
        
        # Map basename from results to full path from video_files_list
        local fullpath="${basename_to_fullpath[$filename]}"
        [[ -z "$fullpath" ]] && continue
        
        video_checksums["$fullpath"]="$checksum"
        video_sizes["$fullpath"]="$size"
        video_fingerprints["$fullpath"]="$fingerprint"
        video_visual_hashes["$fullpath"]="$perceptual_hash"
        video_durations["$fullpath"]="$duration"
        video_resolutions["$fullpath"]="$resolution"
        video_codecs["$fullpath"]="$codec"
        video_formats["$fullpath"]="$format"
        
        # Extract bitrate and FPS from fingerprint (format: size:resolution:duration:bitrate:fps:codec:format)
        local bitrate=$(echo "$fingerprint" | cut -d':' -f4)
        local fps=$(echo "$fingerprint" | cut -d':' -f5)
        video_bitrates["$filename"]="${bitrate:-0}"
        video_fps_values["$filename"]="${fps:-0}"
        
        # Track format distribution
        ((format_counts[$format]++))
        ((processed_count++))
    done < "$results_file"
    
    # Show format distribution
    if [[ ${#format_counts[@]} -gt 0 ]]; then
        echo -e "  ${CYAN}ðŸ“ˆ Format distribution:${NC}"
        for fmt in "${!format_counts[@]}"; do
            echo -e "    ${GRAY}â€¢ ${fmt}: ${format_counts[$fmt]} files${NC}"
        done
    fi
    
    # Stage 2: Pairwise comparison with AI decision engine
    echo -e "  ${BLUE}${BOLD}ðŸ§  Stage 2: Fast Duplicate Detection (Levels 1-6)...${NC}"
    
    # ðŸš€ OPTIMIZATION: Hash-based grouping to reduce comparisons
    echo -e "  ${CYAN}âš¡ Optimizing: Grouping files by hash prefix...${NC}"
    declare -A hash_groups
    for file in "${video_files_list[@]}"; do
        local checksum="${video_checksums["$file"]}"
        if [[ -n "$checksum" && "$checksum" != "ERROR" ]]; then
            local hash_prefix="${checksum:0:4}"  # Group by first 4 chars
            hash_groups["$hash_prefix"]+="$file|"
        fi
    done
    
    local total_groups=${#hash_groups[@]}
    echo -e "  ${GREEN}âœ“ Grouped into $total_groups hash buckets (smart comparison)${NC}"
    
    local total_comparisons=$(( total_files * (total_files - 1) / 2 ))
    local current_comparison=0
    
    # Adaptive progress update frequency (faster for large collections)
    local progress_update_freq=10
    if [[ $total_files -gt 200 ]]; then
        progress_update_freq=100
    elif [[ $total_files -gt 100 ]]; then
        progress_update_freq=50
    fi
    
    declare -A compared_pairs
    
    # ðŸš€ PARALLEL COMPARISON FRAMEWORK - RE-ENABLED
    # Now works with top-level worker function + persistent directories + no EXIT trap
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    # Use 66% of available cores (leave 33% for system + other processes)
    local max_workers=$(( cpu_cores * 2 / 3 ))
    [[ $max_workers -lt 4 ]] && max_workers=4     # Minimum 4 workers
    [[ $max_workers -gt 24 ]] && max_workers=24   # Maximum 24 workers (diminishing returns)
    
    # Create synchronized result files
    local results_dir="$temp_analysis_dir/stage2_results"
    mkdir -p "$results_dir"
    local duplicates_file="$results_dir/duplicates.txt"
    local progress_file="$results_dir/progress.txt"
    local lock_file="$results_dir/lock"
    echo "0" > "$progress_file"
    : > "$duplicates_file"
    
    # Write all array data to lookup files for workers
    local lookup_dir="$results_dir/lookup"
    mkdir -p "$lookup_dir" || { echo "ERROR: Failed to create $lookup_dir" >&2; return 1; }
    
    echo -e "  ${CYAN}âš¡ Creating lookup tables for parallel workers...${NC}"
    
    # Write file list with indices
    local filelist="$lookup_dir/files.txt"
    : > "$filelist"
    for ((i=0; i<total_files; i++)); do
        echo "$i|${video_files_list[$i]}" >> "$filelist"
    done
    
    # Write checksums lookup - use same keys as video_files_list
    local checksums_lookup="$lookup_dir/checksums.txt"
    : > "$checksums_lookup"
    for file in "${video_files_list[@]}"; do
        local checksum="${video_checksums["$file"]}"
        [[ -n "$checksum" ]] && echo "$file|$checksum" >> "$checksums_lookup"
    done
    
    # Write visual hashes lookup - use same keys as video_files_list
    local hashes_lookup="$lookup_dir/visual_hashes.txt"
    : > "$hashes_lookup"
    for file in "${video_files_list[@]}"; do
        local hash="${video_visual_hashes["$file"]}"
        [[ -n "$hash" ]] && echo "$file|$hash" >> "$hashes_lookup"
    done
    
    # Write fingerprints lookup - use same keys as video_files_list
    local fingerprints_lookup="$lookup_dir/fingerprints.txt"
    : > "$fingerprints_lookup"
    for file in "${video_files_list[@]}"; do
        local fp="${video_fingerprints["$file"]}"
        [[ -n "$fp" ]] && echo "$file|$fp" >> "$fingerprints_lookup"
    done
    
    # Write sizes lookup - use same keys as video_files_list
    local sizes_lookup="$lookup_dir/sizes.txt"
    : > "$sizes_lookup"
    for file in "${video_files_list[@]}"; do
        local size="${video_sizes["$file"]}"
        [[ -n "$size" ]] && echo "$file|$size" >> "$sizes_lookup"
    done
    
    # Write durations lookup - use same keys as video_files_list
    local durations_lookup="$lookup_dir/durations.txt"
    : > "$durations_lookup"
    for file in "${video_files_list[@]}"; do
        local dur="${video_durations["$file"]}"
        [[ -n "$dur" ]] && echo "$file|$dur" >> "$durations_lookup"
    done
    
    # Write resolutions lookup - use same keys as video_files_list
    local resolutions_lookup="$lookup_dir/resolutions.txt"
    : > "$resolutions_lookup"
    for file in "${video_files_list[@]}"; do
        local res="${video_resolutions["$file"]}"
        [[ -n "$res" ]] && echo "$file|$res" >> "$resolutions_lookup"
    done
    echo -e "  ${GREEN}âœ“ Lookup tables ready${NC}"
    
    # ðŸ’¡ Initialize Multi-Layer Smart Comparison Cache
    echo -e "  ${CYAN}ðŸ’¡ Initializing smart comparison cache system...${NC}"
    printf "  ${GRAY}  â””â”€ Validating cache integrity...${NC}"
    local video_comparison_cache=$(init_comparison_cache "video")
    validate_and_repair_comparison_cache "$video_comparison_cache" "video"
    printf "\r\033[K"
    echo -e "  ${GREEN}  âœ“ Cache validated${NC}"
    
    # Layer 1: Load cache into memory (in-memory hash table)
    declare -A completed_pairs_cache
    printf "  ${CYAN}  â””â”€ Loading smart cache into memory...${NC}"
    local cache_loaded=$(load_comparison_cache "$video_comparison_cache" completed_pairs_cache)
    printf "\r\033[K"
    [[ $cache_loaded -gt 0 ]] && echo -e "  ${GREEN}  âœ“ Loaded $cache_loaded cached pairs from smart cache${NC}"
    
    # Layer 2: Legacy state file for backward compatibility
    local progress_state_file="$HOME/.smart-gif-converter/video_comparison_state.txt"
    mkdir -p "$(dirname "$progress_state_file")"
    
    # Merge legacy state file into memory cache
    declare -A completed_pairs
    local pairs_resumed=0
    if [[ -f "$progress_state_file" ]]; then
        printf "  ${CYAN}  â””â”€ Loading legacy state file...${NC}"
        while IFS= read -r pair_hash; do
            [[ -n "$pair_hash" && "$pair_hash" != "#"* ]] && completed_pairs["$pair_hash"]=1 && ((pairs_resumed++))
        done < "$progress_state_file"
        printf "\r\033[K"
        [[ $pairs_resumed -gt 0 ]] && echo -e "  ${GREEN}  âœ“ Loaded $pairs_resumed cached pairs from legacy file${NC}"
    fi
    
    # Merge both caches (Layer 1 + Layer 2)
    printf "  ${CYAN}  â””â”€ Merging cache layers...${NC}"
    for pair_hash in "${!completed_pairs_cache[@]}"; do
        completed_pairs["$pair_hash"]=1
    done
    printf "\r\033[K"
    
    local total_cached=$((cache_loaded + pairs_resumed))
    if [[ $total_cached -gt 0 ]]; then
        echo -e "  ${GREEN}â†» Smart cache ready: ${BOLD}$total_cached${NC}${GREEN} pairs available (skips comparisons)${NC}"
        local cache_stats=$(get_comparison_cache_stats "$video_comparison_cache" "video")
        [[ -n "$cache_stats" ]] && echo -e "  ${GRAY}    $cache_stats${NC}"
    else
        echo -e "  ${CYAN}  âœ“ Fresh cache initialized (no previous comparisons)${NC}"
    fi
    
    # Note: Cache is dynamic and survives file additions!
    # Note: No collection hash validation - cache is dynamic and survives file additions!
    
    # Generate comparison queue (all pairs to compare)
    local queue_file="$results_dir/queue.txt"
    local completed_state_file="$results_dir/completed_pairs.txt"
    local estimated_pairs=$(( total_files * (total_files - 1) / 2 ))
    echo -e "  ${CYAN}âš¡ Generating comparison queue (${BOLD}~$estimated_pairs${NC}${CYAN} potential pairs)...${NC}"
    : > "$queue_file"
    : > "$completed_state_file"
    
    local pairs_skipped=0
    local pairs_generated=0
    local pairs_exact_match=0
    local last_progress_pct=0
    
    for ((i=0; i<total_files; i++)); do
        # Show progress every 5%
        local progress_pct=$((i * 100 / total_files))
        if [[ $progress_pct -ge $((last_progress_pct + 5)) ]]; then
            printf "\r  ${CYAN}  Building queue: ${BOLD}%3d%%${NC} ${GRAY}(file %d/%d, %d pairs generated, %d cached)${NC}" "$progress_pct" "$i" "$total_files" "$pairs_generated" "$pairs_skipped"
            last_progress_pct=$progress_pct
        fi
        
        local file1="${video_files_list[$i]}"
        [[ ! -f "$file1" ]] && continue
        local checksum1="${video_checksums["$file1"]}"
        [[ -z "$checksum1" ]] && continue
        
        for ((j=i+1; j<total_files; j++)); do
            local file2="${video_files_list[$j]}"
            [[ ! -f "$file2" ]] && continue
            local checksum2="${video_checksums["$file2"]}"
            [[ -z "$checksum2" ]] && continue
            
            # OPTIMIZATION 1: Skip pairs with identical checksums (exact duplicates already found in Stage 1)
            if [[ "$checksum1" == "$checksum2" ]]; then
                ((pairs_exact_match++))
                continue
            fi
            
            # Create deterministic pair hash using concatenated checksums
            # OPTIMIZATION: Use checksums directly instead of re-hashing
            local pair_hash
            if [[ "$checksum1" < "$checksum2" ]]; then
                pair_hash="${checksum1}_${checksum2}"
            else
                pair_hash="${checksum2}_${checksum1}"
            fi
            
            # Skip if already completed
            if [[ -n "${completed_pairs[$pair_hash]:-}" ]]; then
                ((pairs_skipped++))
                echo "$pair_hash" >> "$completed_state_file"
                continue
            fi
            
            # Write pair to queue with hash
            echo "$i|$j|$pair_hash" >> "$queue_file"
            ((pairs_generated++))
        done
    done
    printf "\r\033[K"
    
    local total_queued=$(wc -l < "$queue_file")
    [[ $pairs_skipped -gt 0 ]] && echo -e "  ${GREEN}âœ“ Skipped $pairs_skipped already completed pairs${NC}"
    [[ $pairs_exact_match -gt 0 ]] && echo -e "  ${GREEN}âœ“ Skipped $pairs_exact_match exact checksum matches (Stage 1 duplicates)${NC}"
    echo -e "  ${GREEN}âœ“ Queue ready: $total_queued new comparisons${NC}"
    [[ $total_queued -eq 0 ]] && echo -e "  ${GREEN}âœ“ All comparisons complete!${NC}" && return 0
    
    # Export worker function and cache functions
    export -f video_compare_worker
    export -f save_comparison_to_cache
    
    # Launch workers with smart cache
    local worker_pids=()
    for ((w=0; w<max_workers; w++)); do
        video_compare_worker $w "$queue_file" "$duplicates_file" "$progress_file" "$lock_file" "$lookup_dir" "$completed_state_file" "$progress_state_file" "$video_comparison_cache" &
        worker_pids+=($!)
    done
    
    echo -e "  ${MAGENTA}ðŸš€ Started $max_workers parallel workers...${NC}"
    
    # Monitor progress
    echo -e "  ${CYAN}Comparing pairs with $max_workers parallel workers...${NC}"
    local last_progress=0
    while true; do
        local current_progress=$(cat "$progress_file" 2>/dev/null || echo "0")
        
        # Check if all workers finished
        local workers_alive=0
        for pid in "${worker_pids[@]}"; do
            if kill -0 $pid 2>/dev/null; then
                ((workers_alive++))
            fi
        done
        
        [[ $workers_alive -eq 0 ]] && break
        
        # Show progress with worker count
        if [[ $current_progress -ne $last_progress ]]; then
            local progress_pct=0
            if [[ $total_queued -gt 0 ]]; then
                progress_pct=$((current_progress * 100 / total_queued))
            fi
            local filled=$((progress_pct * 30 / 100))
            local empty=$((30 - filled))
            
            printf "\r  ${CYAN}["
            for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
            for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
            printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d)${NC} ${BLUE}Workers: %d${NC}" "${progress_pct:-0}" "${current_progress:-0}" "${total_queued:-0}" "${workers_alive:-0}"
            
            last_progress=$current_progress
        fi
        
        sleep 0.2
    done
    
    printf "\r\033[K"
    
    # Wait for all workers to complete
    for pid in "${worker_pids[@]}"; do
        wait $pid 2>/dev/null
    done
    
    # Collect results
    while IFS= read -r duplicate_line; do
        [[ -z "$duplicate_line" ]] && continue
        duplicate_pairs+=("$duplicate_line")
        ((duplicate_count++))
    done < "$duplicates_file"
    
    echo -e "  ${GREEN}âœ“ Parallel comparison complete (Levels 1-3)${NC}"
    
    # ðŸ“Š Display smart cache statistics
    local final_cache_stats=$(get_comparison_cache_stats "$video_comparison_cache" "video")
    echo -e "  ${CYAN}ðŸ’¾ Smart cache: $final_cache_stats${NC}"
    
    # ðŸ§º Optimize cache if needed (background)
    ( cleanup_comparison_cache "$video_comparison_cache" "video" ) &
    
    # Clean up temporary files
    rm -rf "$lookup_dir" 2>/dev/null
    
    # SEQUENTIAL CODE - DISABLED (parallel workers are working now!)
    if false; then
    for ((i=0; i<total_files; i++)); do
        local file1="${video_files_list[$i]}"
        [[ ! -f "$file1" ]] && continue
        
        local checksum1="${video_checksums["$file1"]}"
        [[ -z "$checksum1" ]] && continue
        
        for ((j=i+1; j<total_files; j++)); do
            local file2="${video_files_list[$j]}"
            [[ ! -f "$file2" ]] && continue
            
            local checksum2="${video_checksums["$file2"]}"
            [[ -z "$checksum2" ]] && continue
            
            ((current_comparison++))
            
            # Show progress (adaptive frequency for speed)
            if [[ $((current_comparison % progress_update_freq)) -eq 0 || $current_comparison -eq $total_comparisons ]]; then
                local progress=$((current_comparison * 100 / total_comparisons))
                local filled=$((progress * 30 / 100))
                local empty=$((30 - filled))
                
                local name1="$(basename -- "$file1")"
                local name2="$(basename -- "$file2")"
                [[ ${#name1} -gt 30 ]] && name1="${name1:0:27}..."
                [[ ${#name2} -gt 30 ]] && name2="${name2:0:27}..."
                
                # Progress bar on first line
                printf "\r  ${CYAN}["
                for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(Levels 1-5)${NC}" "$progress"
                
                # File comparison below
                printf "\n  ${BLUE}Comparing: %s â†” %s${NC}" "$name1" "$name2"
                printf "\r\033[1A"  # Move cursor back up to progress bar line
            fi
            
            # Level 1: Exact binary match (MD5)
            if [[ "$checksum1" == "$checksum2" ]]; then
                duplicate_pairs+=("LEVEL1|100|$file1|$file2|Exact binary match")
                ((duplicate_count++))
                continue
            fi
            
            # Level 2: Visual similarity (perceptual hash)
            local hash1="${video_visual_hashes["$file1"]}"
            local hash2="${video_visual_hashes["$file2"]}"
            
            if [[ -n "$hash1" && -n "$hash2" && "$hash1" == "$hash2" ]]; then
                duplicate_pairs+=("LEVEL2|95|$file1|$file2|Identical visual fingerprint")
                ((duplicate_count++))
                continue
            fi
            
            # Level 3: Content fingerprint match
            local fp1="${video_fingerprints["$file1"]}"
            local fp2="${video_fingerprints["$file2"]}"
            
            if [[ "$fp1" == "$fp2" ]]; then
                local size1="${video_sizes["$file1"]:-0}"
                local size2="${video_sizes["$file2"]:-0}"
                
                # Only calculate ratio if both sizes are valid and non-zero
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_ratio=$(( (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                    
                    if [[ $size_ratio -ge 95 ]]; then
                        duplicate_pairs+=("LEVEL3|90|$file1|$file2|Identical metadata + similar size")
                        ((duplicate_count++))
                        continue
                    fi
                fi
            fi
            
            # Level 4: Near-identical detection
            local dur1="${video_durations["$file1"]}"
            local dur2="${video_durations["$file2"]}"
            local res1="${video_resolutions["$file1"]}"
            local res2="${video_resolutions["$file2"]}"
            
            if [[ "$dur1" == "$dur2" && "$res1" == "$res2" ]]; then
                local size1="${video_sizes["$file1"]:-0}"
                local size2="${video_sizes["$file2"]:-0}"
                
                # Only calculate if both sizes are valid and non-zero
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( 100 - (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                    
                    if [[ $size_diff_pct -le 10 ]]; then
                        duplicate_pairs+=("LEVEL4|80|$file1|$file2|Same duration + resolution, similar size")
                        ((duplicate_count++))
                        continue
                    fi
                fi
            fi
            
            # Level 5: Filename similarity + file properties
            local name1="$(basename -- "${file1%.*}")"
            local name2="$(basename -- "${file2%.*}")"
            
            # Calculate Levenshtein distance for filename similarity
            local filename_similarity=$(calculate_filename_similarity "$name1" "$name2")
            
            # Get file timestamps for additional comparison
            local mtime1=$(stat -c%Y -- "$file1" 2>/dev/null || echo "0")
            local mtime2=$(stat -c%Y -- "$file2" 2>/dev/null || echo "0")
            local atime1=$(stat -c%X "$file1" 2>/dev/null || echo "0")
            local atime2=$(stat -c%X "$file2" 2>/dev/null || echo "0")
            
            # Time difference in seconds
            local mtime_diff=$(( mtime1 > mtime2 ? mtime1 - mtime2 : mtime2 - mtime1 ))
            local atime_diff=$(( atime1 > atime2 ? atime1 - atime2 : atime2 - atime1 ))
            
            # Track if duplicate found
            local is_duplicate=false
            
            # Check for similar filenames with similar properties
            if [[ $filename_similarity -ge 75 ]]; then
                local size1="${video_sizes["$file1"]:-0}"
                local size2="${video_sizes["$file2"]:-0}"
                
                # Only calculate ratio if both sizes are valid and non-zero
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_ratio=$(( (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                    
                    # Similar filename + similar size + close modification times = likely duplicate
                    if [[ $size_ratio -ge 90 && $mtime_diff -lt 86400 ]]; then  # Within 1 day
                        duplicate_pairs+=("LEVEL5|75|$file1|$file2|Similar filename (${filename_similarity}%) + properties")
                        ((duplicate_count++))
                        is_duplicate=true
                        continue
                    fi
                    
                    # Very similar filename + same duration = possible re-encode
                    if [[ $filename_similarity -ge 90 && "$dur1" == "$dur2" && $size_ratio -ge 85 ]]; then
                        duplicate_pairs+=("LEVEL5|70|$file1|$file2|Very similar filename (${filename_similarity}%) + duration match")
                        ((duplicate_count++))
                        is_duplicate=true
                        continue
                    fi
                fi
            fi
            
            # Level 6: Advanced Frame-by-Frame Deep Analysis (AI-powered)
            # AI DECISION ENGINE: Intelligently decides when Level 6 should run
            local should_run_level6=false
            local skip_level6_calculation=false
            
            # Quick bailout #1: Already found duplicate
            if [[ "$is_duplicate" == "true" ]]; then
                skip_level6_calculation=true
            fi
            
            # Quick bailout #2: Collection too large
            if [[ $total_files -ge 200 ]] && [[ "$skip_level6_calculation" != "true" ]]; then
                local quick_size1="${video_sizes["$file1"]:-0}"
                local quick_size2="${video_sizes["$file2"]:-0}"
                if [[ $quick_size1 -gt 0 && $quick_size2 -gt 0 ]]; then
                    local quick_diff=$(( (quick_size1 > quick_size2 ? quick_size1 - quick_size2 : quick_size2 - quick_size1) * 100 / (quick_size1 > quick_size2 ? quick_size1 : quick_size2) ))
                    if [[ $quick_diff -gt 20 ]]; then
                        skip_level6_calculation=true
                    fi
                fi
            fi
            
            # Only run expensive AI calculation if bailout conditions not met
            if [[ "$skip_level6_calculation" != "true" ]] && \
               [[ "${AI_ENABLED:-true}" == "true" ]] && [[ "${AI_VISUAL_SIMILARITY:-true}" == "true" ]] && \
               command -v convert >/dev/null 2>&1; then
                
                # ==============================================================
                # ðŸ§  COMPREHENSIVE 10-FACTOR AI DECISION ENGINE
                # Uses: MD5, metadata, file stats, timestamps, visual hashes, codecs, formats!
                # ==============================================================
                
                # Factor 1: Collection size (base penalty for large collections)
                local collection_size=$total_files
                local size_score=0
                if [[ $collection_size -lt 30 ]]; then
                    size_score=100  # Small collection - run liberally
                elif [[ $collection_size -lt 75 ]]; then
                    size_score=50   # Medium - run selectively
                elif [[ $collection_size -lt 150 ]]; then
                    size_score=15   # Large - extremely rare
                else
                    size_score=2    # Very large - virtually never
                fi
                
                # Factor 2: MD5 Hash Proximity Analysis
                local md5_score=0
                local hash1="${video_checksums["$file1"]}"
                local hash2="${video_checksums["$file2"]}"
                if [[ -n "$hash1" && -n "$hash2" && "$hash1" != "ERROR" && "$hash2" != "ERROR" ]]; then
                    if [[ "${hash1:0:8}" == "${hash2:0:8}" ]]; then
                        ((md5_score += 50))  # Very strong similarity
                    elif [[ "${hash1:0:4}" == "${hash2:0:4}" ]]; then
                        ((md5_score += 25))  # Moderate similarity
                    elif [[ "${hash1:0:2}" == "${hash2:0:2}" ]]; then
                        ((md5_score += 10))  # Weak similarity
                    fi
                fi
                
                # Factor 3: File Metadata & Timestamps
                local metadata_score=0
                if [[ $mtime1 -gt 0 && $mtime2 -gt 0 ]]; then
                    if [[ $mtime_diff -lt 60 ]]; then
                        ((metadata_score += 40))  # Created within 1 minute
                    elif [[ $mtime_diff -lt 300 ]]; then
                        ((metadata_score += 20))  # Within 5 minutes
                    elif [[ $mtime_diff -lt 3600 ]]; then
                        ((metadata_score += 10))  # Within 1 hour
                    fi
                fi
                
                # Factor 4: Duration & Resolution Match
                local duration_resolution_score=0
                if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    if [[ $dur1 -eq $dur2 ]]; then
                        ((duration_resolution_score += 45))  # Exact duration match
                    else
                        local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                        if [[ $dur_diff -lt 5 ]]; then
                            ((duration_resolution_score += 30))  # Within 5%
                        elif [[ $dur_diff -lt 10 ]]; then
                            ((duration_resolution_score += 15))  # Within 10%
                        fi
                    fi
                fi
                
                # Factor 5: Visual Hash Similarity
                local visual_hash_score=0
                local vhash1="${video_visual_hashes["$file1"]}"
                local vhash2="${video_visual_hashes["$file2"]}"
                if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" ]]; then
                    if [[ "$vhash1" == "$vhash2" ]]; then
                        ((visual_hash_score += 50))  # Identical visual hash
                    else
                        local hash_diff=$(echo "scale=2; ($vhash1 - $vhash2) / $vhash1 * 100" | bc -l 2>/dev/null | tr -d '-' || echo "100")
                        local hash_diff_int=${hash_diff%.*}
                        if [[ $hash_diff_int -lt 5 ]]; then
                            ((visual_hash_score += 35))  # Very similar
                        elif [[ $hash_diff_int -lt 15 ]]; then
                            ((visual_hash_score += 20))  # Somewhat similar
                        fi
                    fi
                fi
                
                # Factor 6: Content Fingerprint Analysis
                local fingerprint_score=0
                local fp1="${video_fingerprints["$file1"]}"
                local fp2="${video_fingerprints["$file2"]}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                    ((fingerprint_score += 40))  # Identical fingerprint
                fi
                
                # Factor 7: Codec & Format Compatibility
                local codec_format_score=0
                local codec1="${video_codecs["$file1"]}"
                local codec2="${video_codecs["$file2"]}"
                local format1="${video_formats["$file1"]}}"
                local format2="${video_formats["$file2"]}}"
                
                if [[ "$codec1" == "$codec2" ]]; then
                    ((codec_format_score += 20))  # Same codec
                fi
                if [[ "$format1" == "$format2" ]]; then
                    ((codec_format_score += 20))  # Same format
                fi
                
                # Factor 8: Filename Similarity
                local similarity_score=$filename_similarity
                
                # Factor 9: File Size Similarity
                local size_similarity_score=0
                local size1="${video_sizes["$file1"]}"
                local size2="${video_sizes["$file2"]}"
                if [[ -n "$size1" && -n "$size2" && $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    if [[ $size_diff_pct -lt 10 ]]; then
                        ((size_similarity_score += 30))  # Within 10%
                    elif [[ $size_diff_pct -lt 20 ]]; then
                        ((size_similarity_score += 15))  # Within 20%
                    fi
                fi
                
                # Factor 10: Previous layers found nothing (might be hidden duplicate)
                local previous_layers_score=0
                if [[ "$is_duplicate" != "true" ]]; then
                    previous_layers_score=20
                fi
                
                # ==============================================================
                # ðŸ§  AI DECISION ALGORITHM - 10-Factor Weighted Scoring
                # ==============================================================
                local ai_confidence=$(( 
                    (size_score * 10 + 
                     md5_score * 12 + 
                     metadata_score * 10 + 
                     duration_resolution_score * 15 + 
                     visual_hash_score * 13 + 
                     fingerprint_score * 12 + 
                     codec_format_score * 10 + 
                     similarity_score * 10 + 
                     size_similarity_score * 3 + 
                     previous_layers_score * 5) / 100 
                ))
                
                # ADAPTIVE THRESHOLD: Extremely strict for large collections
                local confidence_threshold=60  # Default for small collections
                if [[ $collection_size -ge 200 ]]; then
                    confidence_threshold=98   # EXTREME: 98% for 200+ files
                elif [[ $collection_size -ge 150 ]]; then
                    confidence_threshold=90   # VERY STRICT for 150+ files
                elif [[ $collection_size -ge 100 ]]; then
                    confidence_threshold=80   # STRICT for 100+ files
                fi
                
                # Decision: Run Level 6 only if confidence exceeds threshold
                if [[ $ai_confidence -ge $confidence_threshold ]]; then
                    should_run_level6=true
                fi
            fi
            
            # Execute Level 6 deep frame analysis if AI decided to
            if [[ "$should_run_level6" == "true" ]]; then
                # Check Level 6 cache first
                local cache_key="L6_VIDEO_COMPARE:${file1}|${file2}"
                local cached_l6_result=$(grep "^$cache_key" "$AI_CACHE_INDEX" 2>/dev/null | cut -d'|' -f3)
                
                if [[ -n "$cached_l6_result" ]]; then
                    # Use cached result
                    if [[ "$cached_l6_result" == "DUPLICATE" ]]; then
                        duplicate_pairs+=("LEVEL6|95|$file1|$file2|Deep frame analysis (cached)")
                        ((duplicate_count++))
                    fi
                else
                    # Perform deep frame comparison
                    local frame_analysis=$(compare_video_frames "$file1" "$file2" "$temp_analysis_dir")
                    
                    if [[ -n "$frame_analysis" ]]; then
                        local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                        local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                        
                        if [[ $visual_match -ge 85 && $color_match -ge 85 ]]; then
                            duplicate_pairs+=("LEVEL6|95|$file1|$file2|Frame analysis (V:${visual_match}% C:${color_match}%)")
                            ((duplicate_count++))
                            # Cache result
                            echo "$cache_key|DUPLICATE" >> "$AI_CACHE_INDEX" 2>/dev/null || true
                        elif [[ $visual_match -ge 70 || $color_match -ge 75 ]]; then
                            duplicate_pairs+=("LEVEL6|75|$file1|$file2|Partial frame match (V:${visual_match}% C:${color_match}%)")
                            ((duplicate_count++))
                            # Cache result
                            echo "$cache_key|SIMILAR" >> "$AI_CACHE_INDEX" 2>/dev/null || true
                        else
                            # Cache negative result
                            echo "$cache_key|DIFFERENT" >> "$AI_CACHE_INDEX" 2>/dev/null || true
                        fi
                    fi
                fi
            fi
        done
    done
    fi  # End of if false - old sequential code disabled
    
    printf "\r\033[K"
    echo -e "  ${GREEN}âœ“ Stage 2 complete${NC}\n"
    
    # Stage 3: Optional Level 6 deep frame-by-frame analysis for suspicious pairs
    local suspicious_pairs=()
    declare -A level6_results
    
    # Identify suspicious pairs (Level 4-5 with lower confidence)
    for pair in "${duplicate_pairs[@]}"; do
        local level=$(echo "$pair" | cut -d'|' -f1)
        if [[ "$level" == "LEVEL4" || "$level" == "LEVEL5" ]]; then
            suspicious_pairs+=("$pair")
        fi
    done
    
    # Ask user if they want deep frame analysis for suspicious pairs
    if [[ ${#suspicious_pairs[@]} -gt 0 && ${#suspicious_pairs[@]} -le 10 ]]; then
        echo -e "${YELLOW}${BOLD}ðŸ” Found ${#suspicious_pairs[@]} suspicious pair(s) requiring deeper analysis${NC}"
        echo -e "${CYAN}Level 6 Deep Frame Analysis: Compare videos frame-by-frame${NC}"
        echo -e "  ${GRAY}â€¢ Extracts and compares key frames from both videos${NC}"
        echo -e "  ${GRAY}â€¢ Visual similarity + color profile analysis${NC}"
        echo -e "  ${GRAY}â€¢ Takes ~30-60 seconds per pair${NC}"
        echo ""
        echo -ne "${BOLD}Run deep frame analysis? [y/N]: ${NC}"
        read -r deep_analysis_choice
        
        if [[ "$deep_analysis_choice" =~ ^[Yy]$ ]]; then
            echo -e "\n  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 3: Level 6 Deep Frame Analysis...${NC}"
            
            local pair_idx=0
            for pair in "${suspicious_pairs[@]}"; do
                ((pair_idx++))
                IFS='|' read -r level confidence file1 file2 reason <<< "$pair"
                
                local name1="$(basename -- "$file1")"
                local name2="$(basename -- "$file2")"
                [[ ${#name1} -gt 30 ]] && name1="${name1:0:27}..."
                [[ ${#name2} -gt 30 ]] && name2="${name2:0:27}..."
                
                echo -e "\n  ${CYAN}Analyzing pair $pair_idx/${#suspicious_pairs[@]}:${NC}"
                echo -e "    ${BLUE}1.${NC} $name1"
                echo -e "    ${BLUE}2.${NC} $name2"
                
                # Perform frame-by-frame comparison
                local frame_analysis=$(compare_video_frames "$file1" "$file2" "$temp_analysis_dir")
                
                if [[ -n "$frame_analysis" ]]; then
                    local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                    local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                    
                    echo -e "    ${CYAN}Results: Visual ${visual_match}%, Color ${color_match}%${NC}"
                    
                    # Determine if it's a duplicate based on frame analysis
                    if [[ $visual_match -ge 85 && $color_match -ge 85 ]]; then
                        echo -e "    ${GREEN}âœ“ CONFIRMED DUPLICATE${NC} (High frame similarity)"
                        # Upgrade to Level 6 duplicate
                        duplicate_pairs+=("LEVEL6|95|$file1|$file2|Frame-by-frame analysis (V:${visual_match}% C:${color_match}%)")
                        level6_results["$file1|$file2"]="duplicate"
                    elif [[ $visual_match -ge 70 || $color_match -ge 75 ]]; then
                        echo -e "    ${YELLOW}âš ï¸ LIKELY SIMILAR${NC} (Moderate frame similarity)"
                        duplicate_pairs+=("LEVEL6|75|$file1|$file2|Partial frame match (V:${visual_match}% C:${color_match}%)")
                        level6_results["$file1|$file2"]="similar"
                    else
                        echo -e "    ${BLUE}âœ“ NOT DUPLICATE${NC} (Different content)"
                        level6_results["$file1|$file2"]="different"
                    fi
                else
                    echo -e "    ${RED}âœ— Analysis failed${NC}"
                fi
            done
            
            echo -e "\n  ${GREEN}âœ“ Stage 3 complete${NC}\n"
        fi
    fi
    
    # Display results
    if [[ $duplicate_count -eq 0 ]]; then
        echo -e "  ${GREEN}${BOLD}âœ¨ No duplicate videos detected (Levels 1-5)${NC}"
        echo -e "  ${GRAY}All $total_files video files are unique based on:
    â€¢ Binary comparison (MD5)
    â€¢ Visual hashing
    â€¢ Metadata matching
    â€¢ Properties comparison
    â€¢ Filename similarity${NC}"
        echo ""
        echo -e "${CYAN}${BOLD}ðŸ” Level 6: Deep Frame-by-Frame Analysis${NC}"
        echo -e "  ${GRAY}â€¢ Compares actual video frames for visual similarity${NC}"
        echo -e "  ${GRAY}â€¢ Can detect re-encoded or slightly modified duplicates${NC}"
        echo -e "  ${GRAY}â€¢ Much slower: ~30-60 seconds per pair${NC}"
        echo -e "  ${YELLOW}â€¢ For $total_files videos: $(( total_files * (total_files - 1) / 2 )) comparisons needed${NC}"
        echo ""
        echo -ne "${BOLD}Proceed with Level 6 frame-by-frame detection? (y/N): ${NC}"
        read -r level6_choice
        
        if [[ ! "$level6_choice" =~ ^[Yy]$ ]]; then
            echo -e "${GREEN}âœ“ Skipping Level 6 analysis${NC}"
            return 0
        fi
        
        # Run Level 6 analysis with BULLETPROOF PRE-FILTERING
        echo -e "\n  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 3: Level 6 Deep Frame Analysis...${NC}"
        echo -e "  ${CYAN}ðŸ§  AI Pre-filtering: Only analyzing likely duplicate candidates...${NC}"
        echo -e "  ${YELLOW}âš ï¸  Press Ctrl+C to cancel at any time${NC}\n"
        
        # Use original video_files_list instead of extracting from associative array
        local video_files_array=("${video_files_list[@]}")
        local level6_found=0
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ðŸ§  100% DYNAMIC AI THRESHOLD - PASS 1: CALCULATE ALL SCORES
        # AI analyzes actual similarity distribution to set intelligent threshold
        # NO PREDEFINED VALUES - completely data-driven!
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        echo -e "  ${BLUE}ðŸ” Stage 1: Building candidate pairs based on similarity indicators...${NC}"
        echo -e "  ${CYAN}ðŸ§  AI Pass 1: Analyzing similarity score distribution...${NC}"
        
local total_possible_pairs=$(( total_files * (total_files - 1) / 2 ))

# ðŸ’¾ PERSISTENT CACHE: Store similarity scores based on file hashes
local video_score_cache="$HOME/.smart-gif-converter/video_similarity_cache.txt"
mkdir -p "$(dirname "$video_score_cache")"
[[ ! -f "$video_score_cache" ]] && touch "$video_score_cache"

# Load existing cache
declare -A video_score_cache_map
if [[ -f "$video_score_cache" ]]; then
    local cache_hits=0
    while IFS='|' read -r pair_hash score file1 file2; do
        [[ -z "$pair_hash" || "$pair_hash" == "#"* ]] && continue
        video_score_cache_map["$pair_hash"]="$score|$file1|$file2"
        ((cache_hits++))
    done < "$video_score_cache"
    [[ $cache_hits -gt 0 ]] && echo -e "  ${GREEN}ðŸ“¦ Loaded $cache_hits cached similarity scores${NC}"
fi

# ðŸš€ PARALLEL AI PASS 1
local pass1_workers=$((CPU_CORES))
[[ $pass1_workers -gt 16 ]] && pass1_workers=16
[[ $pass1_workers -lt 4 ]] && pass1_workers=4

local pass1_dir="$temp_analysis_dir/pass1_results"
mkdir -p "$pass1_dir"
local pass1_scores="$pass1_dir/scores.txt"
local pass1_progress="$pass1_dir/progress.txt"
local pass1_lock="$pass1_dir/lock"
local pass1_cache="$pass1_dir/new_cache.txt"
echo "0" > "$pass1_progress"
: > "$pass1_scores"
: > "$pass1_cache"

# Generate queue
local pass1_queue="$pass1_dir/queue.txt"
: > "$pass1_queue"
for ((i=0; i<total_files; i++)); do
    for ((j=i+1; j<total_files; j++)); do
        echo "$i|$j" >> "$pass1_queue"
    done
done

echo -e "  ${MAGENTA}ðŸš€ Starting $pass1_workers parallel workers...${NC}"

# Worker function
calc_video_similarity_worker() {
    local worker_id=$1 queue=$2 results=$3 progress=$4 lockfile=$5 new_cache=$6
    
    while true; do
        local pair
        (
            flock -x 200
            pair=$(head -n 1 "$queue" 2>/dev/null)
            [[ -n "$pair" ]] && sed -i '1d' "$queue"
        ) 200>"$lockfile"
        
        [[ -z "$pair" ]] && break
        
        local i=$(echo "$pair" | cut -d'|' -f1)
        local j=$(echo "$pair" | cut -d'|' -f2)
        local file1="${video_files_array[$i]}"
        local file2="${video_files_array[$j]}"
        
        # Generate cache key
        local hash1="${video_checksums["$file1"]:-}"
        local hash2="${video_checksums["$file2"]:-}"
        [[ -z "$hash1" ]] && hash1="NOHASH_$(stat -c'%s_%Y' "$file1" 2>/dev/null || echo "0")"
        [[ -z "$hash2" ]] && hash2="NOHASH_$(stat -c'%s_%Y' "$file2" 2>/dev/null || echo "0")"
        
        local pair_hash
        if [[ "$hash1" < "$hash2" ]]; then
            pair_hash="${hash1}_${hash2}"
        else
            pair_hash="${hash2}_${hash1}"
        fi
        
        # Check cache
        local cached="${video_score_cache_map["$pair_hash"]:-}"
        if [[ -n "$cached" ]]; then
            local score=$(echo "$cached" | cut -d'|' -f1)
            [[ $score -gt 0 ]] && (
                flock -x 200
                echo "$score|$file1|$file2" >> "$results"
            ) 200>"$lockfile"
            (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
            continue
        fi
        
        # Skip already detected
        local checksum1="${video_checksums["$file1"]:-}"
        local checksum2="${video_checksums["$file2"]:-}"
        if [[ -n "$checksum1" && -n "$checksum2" && "$checksum1" == "$checksum2" ]]; then
            (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
            continue
        fi
        
        local vhash1="${video_visual_hashes["$file1"]:-}"
        local vhash2="${video_visual_hashes["$file2"]:-}"
        if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" && "$vhash1" == "$vhash2" ]]; then
            (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
            continue
        fi
        
        # Calculate score (existing 8-factor logic)
        local similarity_score=0
        
        # Factor 1: Filenames (40 max)
        local name1=$(basename -- "$file1"); name1="${name1%.*}"
        local name2=$(basename -- "$file2"); name2="${name2%.*}"
        [[ "${name1:0:15}" == "${name2:0:15}" ]] && similarity_score=$((similarity_score + 40)) ||
        [[ "${name1:0:10}" == "${name2:0:10}" ]] && similarity_score=$((similarity_score + 30)) ||
        [[ "${name1:0:5}" == "${name2:0:5}" ]] && similarity_score=$((similarity_score + 15))
        
        # Factor 2: File sizes (35 max)
        local size1="${video_sizes["$file1"]:-0}"
        local size2="${video_sizes["$file2"]:-0}"
        if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
            local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
            [[ $size_diff_pct -lt 5 ]] && similarity_score=$((similarity_score + 35)) ||
            [[ $size_diff_pct -lt 15 ]] && similarity_score=$((similarity_score + 25)) ||
            [[ $size_diff_pct -lt 30 ]] && similarity_score=$((similarity_score + 15)) ||
            [[ $size_diff_pct -lt 50 ]] && similarity_score=$((similarity_score + 5))
        fi
        
        # Factor 3: Duration (50 max)
        local dur1="${video_durations["$file1"]:-0}"
        local dur2="${video_durations["$file2"]:-0}"
        if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
            if [[ $dur1 -eq $dur2 ]]; then
                similarity_score=$((similarity_score + 50))
            else
                local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                [[ $dur_diff -lt 5 ]] && similarity_score=$((similarity_score + 40)) ||
                [[ $dur_diff -lt 10 ]] && similarity_score=$((similarity_score + 25)) ||
                [[ $dur_diff -lt 20 ]] && similarity_score=$((similarity_score + 10))
            fi
        fi
        
        # Factor 4: Resolution (45 max)
        local res1="${video_resolutions["$file1"]:-}"
        local res2="${video_resolutions["$file2"]:-}"
        [[ -n "$res1" && -n "$res2" && "$res1" == "$res2" ]] && similarity_score=$((similarity_score + 45))
        
        # Factor 6: Bitrate (30 max)
        local br1="${video_bitrates["$file1"]:-0}"
        local br2="${video_bitrates["$file2"]:-0}"
        if [[ $br1 -gt 0 && $br2 -gt 0 ]]; then
            local br_diff=$(( (br1 > br2 ? br1 - br2 : br2 - br1) * 100 / (br1 > br2 ? br1 : br2) ))
            [[ $br_diff -lt 10 ]] && similarity_score=$((similarity_score + 30)) ||
            [[ $br_diff -lt 25 ]] && similarity_score=$((similarity_score + 15))
        fi
        
        # Factor 7: Codec (35 max)
        local codec1="${video_codecs["$file1"]:-}"
        local codec2="${video_codecs["$file2"]:-}"
        [[ -n "$codec1" && -n "$codec2" && "$codec1" == "$codec2" ]] && similarity_score=$((similarity_score + 35))
        
        # Factor 8: FPS (30 max)
        local fps1="${video_fps_values["$file1"]:-0}"
        local fps2="${video_fps_values["$file2"]:-0}"
        if [[ -n "$fps1" && -n "$fps2" ]]; then
            local fps1_int=${fps1%.*}
            local fps2_int=${fps2%.*}
            [[ $fps1_int -eq $fps2_int ]] && similarity_score=$((similarity_score + 30))
        fi
        
        # Write result + cache
        (
            flock -x 200
            [[ $similarity_score -gt 0 ]] && echo "$similarity_score|$file1|$file2" >> "$results"
            echo "$pair_hash|$similarity_score|$file1|$file2" >> "$new_cache"
        ) 200>"$lockfile"
        
        (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
    done
}

export -f calc_video_similarity_worker

# Launch workers
local pids=()
for ((w=0; w<pass1_workers; w++)); do
    calc_video_similarity_worker $w "$pass1_queue" "$pass1_scores" "$pass1_progress" "$pass1_lock" "$pass1_cache" &
    pids+=($!)
done

# Monitor
local last=0
while true; do
    local curr=$(cat "$pass1_progress" 2>/dev/null || echo "0")
    local alive=0
    for pid in "${pids[@]}"; do
        kill -0 $pid 2>/dev/null && ((alive++))
    done
    [[ $alive -eq 0 ]] && break
    
    if [[ $curr -ne $last ]]; then
        local pct=$((curr * 100 / total_possible_pairs))
        local fill=$((pct * 30 / 100))
        printf "\r  ${CYAN}Analysis: ["
        for ((k=0; k<fill; k++)); do printf "${CYAN}â–ˆ${NC}"; done
        for ((k=fill; k<30; k++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d) Workers: ${CYAN}%d${GRAY}${NC}" "$pct" "$curr" "$total_possible_pairs" "$alive"
        last=$curr
    fi
    sleep 0.2
done

for pid in "${pids[@]}"; do wait $pid 2>/dev/null; done
printf "\r\033[K"

# Collect results
declare -a all_similarity_scores
local max_score_seen=0 total_score_sum=0
while IFS='|' read -r score file1 file2; do
    [[ -z "$score" ]] && continue
    all_similarity_scores+=("$score|$file1|$file2")
    total_score_sum=$((total_score_sum + score))
    [[ $score -gt $max_score_seen ]] && max_score_seen=$score
done < "$pass1_scores"

# Save cache
if [[ -f "$pass1_cache" && -s "$pass1_cache" ]]; then
    local new=$(wc -l < "$pass1_cache")
    cat "$pass1_cache" >> "$video_score_cache"
    echo -e "  ${GREEN}ðŸ’¾ Cached $new new scores${NC}"
    
    local temp="$video_score_cache.tmp"
    awk -F'|' '!seen[$1]++' "$video_score_cache" | tail -n 100000 > "$temp" 2>/dev/null
    mv "$temp" "$video_score_cache" 2>/dev/null || true
fi

rm -rf "$pass1_dir" 2>/dev/null

echo -e "  ${GREEN}âœ“ Pass 1 complete: ${BOLD}${#all_similarity_scores[@]}${NC}${GREEN} pairs with non-zero scores${NC}"

# Early exit if no similar pairs found
if [[ ${#all_similarity_scores[@]} -eq 0 ]]; then
    echo -e "  ${GREEN}${BOLD}âœ¨ No similar pairs found - all videos are unique!${NC}"
    trap - INT
    return 0
fi

echo -e "  ${CYAN}ðŸ§  AI Pass 2: Analyzing score distribution to determine optimal threshold...${NC}"

# Sort scores (descending)
IFS=$'\n' sorted_scores=($(sort -t'|' -k1 -n -r <<<"${all_similarity_scores[*]}"))
unset IFS

local avg_score=$((total_score_sum / ${#all_similarity_scores[@]}))
local highest_score=$(echo "${sorted_scores[0]}" | cut -d'|' -f1)
local median_idx=$((${#sorted_scores[@]} / 2))
local median_score=$(echo "${sorted_scores[$median_idx]}" | cut -d'|' -f1)

# Find 75th percentile
local p75_idx=$((${#sorted_scores[@]} / 4))
local p75_score=$(echo "${sorted_scores[$p75_idx]}" | cut -d'|' -f1)

# Find 90th percentile
local p90_idx=$((${#sorted_scores[@]} / 10))
[[ $p90_idx -lt 1 ]] && p90_idx=1
local p90_score=$(echo "${sorted_scores[$p90_idx]}" | cut -d'|' -f1)

echo -e "    ${GRAY}â”œâ”€ Max score: ${BOLD}$highest_score${NC}"
echo -e "    ${GRAY}â”œâ”€ 90th percentile: ${BOLD}$p90_score${NC}"
echo -e "    ${GRAY}â”œâ”€ 75th percentile: ${BOLD}$p75_score${NC}"
echo -e "    ${GRAY}â”œâ”€ Median: ${BOLD}$median_score${NC}"
echo -e "    ${GRAY}â””â”€ Average: ${BOLD}$avg_score${NC}"
        
        # ðŸ§  INTELLIGENT THRESHOLD SELECTION
        # Strategy: Target top 1-5% of most similar pairs based on collection size
        local ai_threshold
        local target_candidates
        
        if [[ $total_files -ge 500 ]]; then
            # Large collection: Be more selective (top 1%)
            target_candidates=$((${#sorted_scores[@]} / 100))
            [[ $target_candidates -lt 10 ]] && target_candidates=10
            [[ $target_candidates -gt 50 ]] && target_candidates=50
        elif [[ $total_files -ge 100 ]]; then
            # Medium collection: Top 2-3%
            target_candidates=$((${#sorted_scores[@]} * 2 / 100))
            [[ $target_candidates -lt 5 ]] && target_candidates=5
            [[ $target_candidates -gt 30 ]] && target_candidates=30
        else
            # Small collection: Top 5%
            target_candidates=$((${#sorted_scores[@]} * 5 / 100))
            [[ $target_candidates -lt 3 ]] && target_candidates=3
            [[ $target_candidates -gt 20 ]] && target_candidates=20
        fi
        
        # Set threshold to the score at target position
        local threshold_idx=$((target_candidates - 1))
        [[ $threshold_idx -lt 0 ]] && threshold_idx=0
        [[ $threshold_idx -ge ${#sorted_scores[@]} ]] && threshold_idx=$((${#sorted_scores[@]} - 1))
        
        ai_threshold=$(echo "${sorted_scores[$threshold_idx]}" | cut -d'|' -f1)
        
        # Safety: ensure threshold is reasonable (not too low)
        local min_threshold=$((avg_score + 20))
        [[ $ai_threshold -lt $min_threshold ]] && ai_threshold=$min_threshold
        [[ $ai_threshold -lt 80 ]] && ai_threshold=80  # Absolute minimum (higher for videos)
        
        echo -e "  ${MAGENTA}${BOLD}ðŸ§  AI DECISION:${NC}"
        echo -e "    ${CYAN}Target candidates: ${BOLD}$target_candidates${NC}${CYAN} pairs${NC}"
        echo -e "    ${CYAN}Dynamic threshold: ${BOLD}$ai_threshold${NC}${CYAN}/265 points${NC}"
        echo -e "    ${GREEN}âœ… AI selected threshold based on your actual data distribution!${NC}"
        echo ""
        
        # PASS 3: Apply threshold to select candidates
        echo -e "  ${CYAN}ðŸŽ¯ Pass 3: Selecting top candidates above threshold ${BOLD}$ai_threshold${NC}${CYAN}...${NC}"
        
        declare -a video_candidate_pairs
        for score_entry in "${sorted_scores[@]}"; do
            local score=$(echo "$score_entry" | cut -d'|' -f1)
            [[ $score -lt $ai_threshold ]] && break
            
            local file1=$(echo "$score_entry" | cut -d'|' -f2)
            local file2=$(echo "$score_entry" | cut -d'|' -f3)
            video_candidate_pairs+=("$file1|$file2|$score")
        done
        
        echo -e "  ${GREEN}âœ“ Candidate selection complete${NC}"
        echo -e "  ${CYAN}ðŸ“Š Final candidates: ${BOLD}${#video_candidate_pairs[@]}${NC}${CYAN} pairs out of ${BOLD}$total_possible_pairs${NC}${CYAN} total${NC}"
        
        if [[ ${#video_candidate_pairs[@]} -gt 0 ]]; then
            local reduction_pct=$(( (total_possible_pairs - ${#video_candidate_pairs[@]}) * 100 / total_possible_pairs ))
            echo -e "  ${GREEN}âš¡ Efficiency: ${BOLD}${reduction_pct}%${NC}${GREEN} of pairs filtered out${NC}"
        fi
        echo ""
        
        if [[ ${#video_candidate_pairs[@]} -eq 0 ]]; then
            trap - INT
            echo -e "  ${GREEN}${BOLD}âœ¨ No similar pairs detected - all videos are unique!${NC}"
            echo -e "  ${BLUE}ðŸš€ Your collection is fully optimized!${NC}"
            return 0
        fi
        
        echo -e "  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 2: Deep frame analysis on ${#video_candidate_pairs[@]} candidate pairs...${NC}\\n"
        
        local pair_count=0
        local progress_initialized=false
        
        # Analyze only the candidate pairs
        for candidate_pair in "${video_candidate_pairs[@]}"; do
            # Check for interruption
            if [[ "$interrupted" == "true" ]]; then
                echo -e "\\n\\n  ${YELLOW}â¸ï¸  Level 6 analysis interrupted by user${NC}"
                INTERRUPT_REQUESTED="true"
                break
            fi
            
            ((pair_count++))
            local file1="${candidate_pair%%|*}"
            local rest="${candidate_pair#*|}"
            local file2="${rest%%|*}"
            local sim_score="${rest##*|}"
            
            # Calculate progress
            local progress=$((pair_count * 100 / ${#video_candidate_pairs[@]}))
            local filled=$((progress * 40 / 100))
            local empty=$((40 - filled))
            
            # Get short filenames for display
            local name1="$(basename -- "$file1")"
            local name2="$(basename -- "$file2")"
            [[ ${#name1} -gt 25 ]] && name1="${name1:0:22}..."
            [[ ${#name2} -gt 25 ]] && name2="${name2:0:22}..."
            
            # Progress bar with files being compared
            # Only clear on updates (not first iteration)
            if [[ "$progress_initialized" == "true" ]]; then
                printf "\\r\\033[K\\n\\033[K\\n\\033[K\\r\\033[3A"  # Clear 3 lines and reset cursor
            fi
            
            printf "  ${CYAN}["
            for ((k=0; k<filled; k++)); do printf "${MAGENTA}â–ˆ${NC}"; done
            for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
            printf "${CYAN}] ${BOLD}%3d%%${NC}"
            printf "\\n  ${GRAY}Candidate %d/%d | Sim: ${CYAN}%d${GRAY} | Found: ${YELLOW}%d${GRAY} duplicates${NC}" "$pair_count" "${#video_candidate_pairs[@]}" "$sim_score" "$level6_found"
            printf "\\n  ${BLUE}Comparing:${NC} %s ${YELLOW}â†”${NC} %s" "$name1" "$name2"
            printf "\\r\\033[2A"  # Move cursor back up to progress bar line
            
            progress_initialized=true
            
            # Perform frame-by-frame comparison
            local frame_analysis=$(compare_video_frames "$file1" "$file2" "$temp_analysis_dir" 2>/dev/null)
            
            if [[ -n "$frame_analysis" ]]; then
                local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                
                # Determine if it's a duplicate based on frame analysis
                if [[ $visual_match -ge 85 && $color_match -ge 85 ]]; then
                    duplicate_pairs+=("LEVEL6|95|$file1|$file2|Frame-by-frame analysis (V:${visual_match}% C:${color_match}%)")
                    ((duplicate_count++))
                    ((level6_found++))
                elif [[ $visual_match -ge 70 || $color_match -ge 75 ]]; then
                    duplicate_pairs+=("LEVEL6|75|$file1|$file2|Partial frame match (V:${visual_match}% C:${color_match}%)")
                    ((duplicate_count++))
                    ((level6_found++))
                fi
            fi
        done
        
        # Clear progress lines and restore trap
        printf "\r\033[K\n\033[K\n\033[K\n"  # Clear 3 lines + move down
        trap - INT
        
        # Check if interrupted during frame analysis
        if [[ "$interrupted" == "true" ]]; then
            INTERRUPT_REQUESTED="true"
            return 1
        fi
        
        echo -e "  ${GREEN}âœ“ Level 6 analysis complete${NC}"
        echo -e "  ${MAGENTA}Found ${BOLD}$level6_found${NC}${MAGENTA} duplicates via frame analysis${NC}\n"
        
        # Check results
        if [[ $duplicate_count -eq 0 ]]; then
            echo -e "  ${GREEN}${BOLD}âœ¨ No duplicates found even with Level 6 deep analysis${NC}"
            echo -e "  ${BLUE}Your video collection is completely unique!${NC}"
            return 0
        fi
        
        # If duplicates found, continue to display results below
    fi
    
    echo -e "${YELLOW}${BOLD}ðŸ“Š DUPLICATE VIDEO DETECTION RESULTS${NC}\n"
    
    # Calculate unique duplicate files
    declare -A all_duplicate_files
    for pair in "${duplicate_pairs[@]}"; do
        IFS='|' read -r level confidence file1 file2 reason <<< "$pair"
        all_duplicate_files["$file1"]=1
        all_duplicate_files["$file2"]=1
    done
    local unique_duplicate_count=${#all_duplicate_files[@]}
    
    # Main statistics
    echo -e "${CYAN}ðŸ“ˆ Summary:${NC}"
    echo -e "  ${BOLD}â€¢ Total videos scanned:${NC} $total_files"
    echo -e "  ${BOLD}â€¢ Duplicate pairs found:${NC} ${YELLOW}$duplicate_count${NC}"
    echo -e "  ${BOLD}â€¢ Duplicate files:${NC} ${YELLOW}$unique_duplicate_count${NC}"
    echo -e "  ${BOLD}â€¢ Unique videos:${NC} $((total_files - unique_duplicate_count))"
    echo ""
    
    # Group by level
    declare -A level_counts
    for pair in "${duplicate_pairs[@]}"; do
        local level=$(echo "$pair" | cut -d'|' -f1)
        ((level_counts[$level]++))
    done
    
    echo -e "${BLUE}ðŸ” Detection breakdown by confidence level:${NC}"
    [[ -n "${level_counts[LEVEL1]}" ]] && echo -e "  ${GREEN}â€¢ Level 1 (Exact Binary):${NC} ${level_counts[LEVEL1]} pairs"
    [[ -n "${level_counts[LEVEL2]}" ]] && echo -e "  ${GREEN}â€¢ Level 2 (Visual Hash):${NC} ${level_counts[LEVEL2]} pairs"
    [[ -n "${level_counts[LEVEL3]}" ]] && echo -e "  ${YELLOW}â€¢ Level 3 (Metadata):${NC} ${level_counts[LEVEL3]} pairs"
    [[ -n "${level_counts[LEVEL4]}" ]] && echo -e "  ${YELLOW}â€¢ Level 4 (Properties):${NC} ${level_counts[LEVEL4]} pairs"
    [[ -n "${level_counts[LEVEL5]}" ]] && echo -e "  ${CYAN}â€¢ Level 5 (Filename):${NC} ${level_counts[LEVEL5]} pairs"
    [[ -n "${level_counts[LEVEL6]}" ]] && echo -e "  ${MAGENTA}â€¢ Level 6 (Frame Analysis):${NC} ${level_counts[LEVEL6]} pairs"
    echo ""
    
    # Calculate potential storage savings
    local potential_savings=0
    declare -A files_to_delete
    
    for pair in "${duplicate_pairs[@]}"; do
        IFS='|' read -r level confidence file1 file2 reason <<< "$pair"
        
        # In each pair, we'd delete the larger file (keep smaller)
        local size1="${video_sizes["$file1"]}"
        local size2="${video_sizes["$file2"]}"
        
        if [[ -n "$size1" && -n "$size2" ]]; then
            if [[ $size1 -gt $size2 ]]; then
                ((potential_savings += size1))
                files_to_delete["$file1"]=1
            else
                ((potential_savings += size2))
                files_to_delete["$file2"]=1
            fi
        fi
    done
    
    # Display potential savings
    echo -e "${GREEN}ðŸ’¾ Potential storage savings:${NC}"
    if [[ $potential_savings -gt 0 ]]; then
        local savings_mb=$((potential_savings / 1024 / 1024))
        local savings_gb=$((savings_mb / 1024))
        
        if [[ $savings_gb -gt 0 ]]; then
            echo -e "  ${BOLD}â€¢ Space to recover:${NC} ${GREEN}${savings_gb}GB${NC} (${savings_mb}MB)"
        else
            echo -e "  ${BOLD}â€¢ Space to recover:${NC} ${GREEN}${savings_mb}MB${NC}"
        fi
        echo -e "  ${BOLD}â€¢ Files to remove:${NC} ${#files_to_delete[@]}"
    fi
    echo ""
    
    # Simple deletion prompt
    echo -ne "${BOLD}Delete duplicate videos? (y/N): ${NC}"
    read -r dup_choice
    
    if [[ "$dup_choice" =~ ^[Yy]$ ]]; then
        # User chose to delete duplicates - delete larger files
        echo -e "\n${CYAN}ðŸ—‘ï¸  Deleting duplicate videos...${NC}\n"
        local deleted_count=0
        local freed_space=0
        
        for pair in "${duplicate_pairs[@]}"; do
            IFS='|' read -r level confidence file1 file2 reason <<< "$pair"
            
            # Determine which file is larger (delete the larger one)
            local size1="${video_sizes["$file1"]}"
            local size2="${video_sizes["$file2"]}"
            local file_to_delete
            local file_to_keep
            
            if [[ $size1 -gt $size2 ]]; then
                file_to_delete="$file1"
                file_to_keep="$file2"
                freed_space=$((freed_space + size1))
            else
                file_to_delete="$file2"
                file_to_keep="$file1"
                freed_space=$((freed_space + size2))
            fi
            
            echo -e "  ${RED}âŒ Deleting: $(basename -- "$file_to_delete")${NC}"
            rm -f "$file_to_delete"
            ((deleted_count++))
            
            # ðŸ§  Train AI from user's delete decision
            train_ai_from_decision "$file1" "$file2" "$confidence" "delete_$([ "$file_to_delete" == "$file1" ] && echo "file1" || echo "file2")" "$level"
        done
        
        local freed_mb=$((freed_space / 1024 / 1024))
        echo -e "\n${GREEN}âœ“ Deletion complete${NC}"
        echo -e "  ${BOLD}Deleted: $deleted_count files${NC}"
        echo -e "  ${BOLD}Space freed: ${freed_mb}MB${NC}"
        
        # ðŸ§  Show AI learning progress
        show_ai_training_stats
    else
        # User chose to keep files (default)
        echo -e "${GREEN}âœ“ Keeping all files - no changes made${NC}"
    fi
    
    echo -e "\n${GREEN}âœ“ Video duplicate detection complete${NC}"
    return 0
}

# ðŸ› ï¸ Video Corruption Detection
detect_corrupted_videos() {
    echo -e "  ${CYAN}ðŸ” Scanning for corrupted video files...${NC}"
    
    local corrupted_count=0
    local scanned_count=0
    declare -a corrupted_files
    declare -A corruption_reasons  # Track why each file is corrupted
    
    shopt -s nullglob
    local all_videos=(*.mp4 *.MP4 *.avi *.AVI *.mov *.MOV *.mkv *.MKV *.webm *.WEBM \
                      *.m4v *.M4V *.flv *.FLV *.wmv *.WMV *.mpg *.MPG *.mpeg *.MPEG \
                      *.3gp *.3GP *.ogv *.OGV *.ts *.TS *.mts *.MTS *.m2ts *.M2TS)
    shopt -u nullglob
    
    local total_videos=${#all_videos[@]}
    
    if [[ $total_videos -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No video files found to check${NC}"
        return 0
    fi
    
    echo -e "  ${BLUE}Checking ${BOLD}$total_videos${NC}${BLUE} video files with ${BOLD}4-layer validation${NC}${BLUE}...${NC}"
    
    # Check if GNU parallel is available for fast validation
    if command -v parallel >/dev/null 2>&1 && [[ $total_videos -gt 10 ]]; then
        # PARALLEL MODE: Process all videos at once using all CPU cores
        local temp_validation_dir="$(mktemp -d)"
        local validation_script="$temp_validation_dir/validate_video.sh"
        local validation_results="$temp_validation_dir/results.txt"
        local progress_counter="$temp_validation_dir/progress.txt"
        echo "0" > "$progress_counter"
        
        # Create validation script
        cat > "$validation_script" << 'VIDEO_VALIDATION_EOF'
#!/bin/bash
validate_single_video() {
    local video_file="$1"
    local progress_file="$2"
    
    local failed_checks=0
    local failure_reasons=()
    
    # Layer 1: File size check
    local file_size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
    if [[ $file_size -lt 1024 ]]; then
        ((failed_checks++))
        failure_reasons+=("File too small")
    fi
    
    # Layer 2: Codec detection
    if command -v ffprobe >/dev/null 2>&1; then
        if ! timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=codec_name \
            -of csv=p=0 -- "$video_file" >/dev/null 2>&1; then
            ((failed_checks++))
            failure_reasons+=("No video codec")
        fi
    fi
    
    # Layer 3: Metadata check
    if command -v ffprobe >/dev/null 2>&1; then
        local duration=$(timeout 5 ffprobe -v error -show_entries format=duration \
            -of csv=p=0 -- "$video_file" 2>/dev/null | cut -d'.' -f1)
        local width=$(timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=width \
            -of csv=p=0 -- "$video_file" 2>/dev/null)
        
        if [[ -z "$duration" || "$duration" == "0" || -z "$width" || "$width" == "0" ]]; then
            ((failed_checks++))
            failure_reasons+=("Missing metadata")
        fi
    fi
    
    # Layer 4: Frame extraction test
    if command -v ffmpeg >/dev/null 2>&1; then
        if ! timeout 8 ffmpeg -i -- "$video_file" -vframes 1 -f null - >/dev/null 2>&1; then
            ((failed_checks++))
            failure_reasons+=("Cannot extract frames")
        fi
    fi
    
    # Update progress
    if [[ -n "$progress_file" ]]; then
        flock -x "$progress_file" bash -c 'echo $(($(cat "$1" 2>/dev/null || echo 0) + 1)) > "$1"' _ "$progress_file" 2>/dev/null || true
    fi
    
    # Output result if corrupted (2+ failures)
    if [[ $failed_checks -ge 2 ]]; then
        local reasons_str=$(IFS=','; echo "${failure_reasons[*]}")
        echo "CORRUPTED|$video_file|$failed_checks|$reasons_str"
    fi
}
export -f validate_single_video
VIDEO_VALIDATION_EOF
        chmod +x "$validation_script"
        
        # Start parallel validation in background
        source "$validation_script"
        (
            printf '%s\n' "${all_videos[@]}" | parallel -j "${AI_DUPLICATE_THREADS:-4}" \
                "validate_single_video {} '$progress_counter'" > "$validation_results" 2>/dev/null
        ) &
        local parallel_pid=$!
        
        # Monitor progress with live progress bar
        local last_count=0
        while kill -0 $parallel_pid 2>/dev/null; do
            local current_count=$(cat "$progress_counter" 2>/dev/null || echo "0")
            
            if [[ $current_count -ne $last_count || $current_count -eq 0 ]]; then
                local progress=$((current_count * 100 / total_videos))
                [[ $progress -gt 100 ]] && progress=100
                local filled=$((progress * 30 / 100))
                local empty=$((30 - filled))
                
                printf "\r  ${CYAN}["
                for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d)${NC}" "$progress" "$current_count" "$total_videos"
                
                last_count=$current_count
            fi
            
            sleep 0.2
        done
        
        # Wait for completion
        wait $parallel_pid 2>/dev/null
        
        # Show final 100%
        printf "\r  ${CYAN}["
        for ((k=0; k<30; k++)); do printf "${GREEN}â–ˆ${NC}"; done
        printf "${CYAN}] ${BOLD}100%%${NC} ${GRAY}(%d/%d)${NC}\n" "$total_videos" "$total_videos"
        
        # Process results
        while IFS='|' read -r status filepath check_count reasons; do
            if [[ "$status" == "CORRUPTED" ]]; then
                corrupted_files+=("$filepath")
                corruption_reasons["$filepath"]="$reasons"
                ((corrupted_count++))
            fi
        done < "$validation_results"
        
        scanned_count=$total_videos
        
        # Cleanup
        rm -rf "$temp_validation_dir" 2>/dev/null
        
    else
        # SEQUENTIAL MODE: For small file counts or when parallel not available
    echo -e "  ${YELLOW}âš ï¸  Press Ctrl+C to cancel at any time${NC}"
    
    # Enable Ctrl+C handling
    local interrupted=false
    trap 'interrupted=true' INT
    
    for video_file in "${all_videos[@]}"; do
        # Check for interruption
        if [[ "$interrupted" == "true" ]]; then
            echo -e "\n  ${YELLOW}â¸ï¸  Corruption scan interrupted by user${NC}"
            break
        fi
        [[ ! -f "$video_file" ]] && continue
        ((scanned_count++))
        
        # Show progress (update on every file)
        local progress=$((scanned_count * 100 / total_videos))
        local filled=$((progress * 30 / 100))
        local empty=$((30 - filled))
        
        printf "\r  ${CYAN}["
        for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d)${NC}" "$progress" "$scanned_count" "$total_videos"
        
        # Multi-layer corruption validation (bulletproof)
        local is_corrupted=false
        local failed_checks=0
        local failure_reasons=()
        
        # Layer 1: File size check (suspiciously small files)
        local file_size=$(stat -c%s -- "$video_file" 2>/dev/null || echo "0")
        if [[ $file_size -lt 1024 ]]; then
            # File less than 1KB is almost certainly corrupted
            ((failed_checks++))
            failure_reasons+=("File too small (<1KB)")
        fi
        
        # Layer 2: Basic codec detection with ffprobe
        if command -v ffprobe >/dev/null 2>&1; then
            if ! timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=codec_name \
                -of csv=p=0 -- "$video_file" >/dev/null 2>&1; then
                ((failed_checks++))
                failure_reasons+=("No video codec detected")
            fi
        fi
        
        # Layer 3: Try to read video duration and resolution
        if command -v ffprobe >/dev/null 2>&1; then
            local duration=$(timeout 5 ffprobe -v error -show_entries format=duration \
                -of csv=p=0 -- "$video_file" 2>/dev/null | cut -d'.' -f1)
            local width=$(timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=width \
                -of csv=p=0 -- "$video_file" 2>/dev/null)
            
            if [[ -z "$duration" || "$duration" == "0" || -z "$width" || "$width" == "0" ]]; then
                ((failed_checks++))
                failure_reasons+=("Missing metadata (duration/resolution)")
            fi
        fi
        
        # Layer 4: Attempt to extract a frame (ultimate test)
        if command -v ffmpeg >/dev/null 2>&1; then
            local test_frame="/tmp/corruption_test_${RANDOM}.jpg"
            if ! timeout 8 ffmpeg -i -- "$video_file" -vframes 1 -f image2 -- "$test_frame" >/dev/null 2>&1; then
                ((failed_checks++))
                failure_reasons+=("Cannot extract frames")
            fi
            rm -f -- "$test_frame" 2>/dev/null
        fi
        
        # Mark as corrupted only if multiple checks failed (at least 2)
        if [[ $failed_checks -ge 2 ]]; then
            corrupted_files+=("$video_file")
            # Store reasons as comma-separated string
            local reasons_str=$(IFS=', '; echo "${failure_reasons[*]}")
            corruption_reasons["$video_file"]="$reasons_str"
            ((corrupted_count++))
        fi
    done
    
    printf "\r\033[K"
    trap - INT
    
    # Check if interrupted
    if [[ "$interrupted" == "true" ]]; then
        INTERRUPT_REQUESTED="true"
        echo -e "  ${GREEN}âœ“ Corruption scan interrupted (scanned $scanned_count/$total_videos files)${NC}"
        return 1
    fi
    
    fi  # End of parallel/sequential if-else
    
    echo -e "  ${GREEN}âœ“ Scanned $scanned_count video files${NC}"
    
    # Report results
    if [[ $corrupted_count -eq 0 ]]; then
        echo -e "  ${GREEN}âœ¨ No corrupted videos found - all files are healthy!${NC}"
        return 0
    fi
    
    # Display corrupted files with detailed reasons
    echo -e "\n  ${RED}${BOLD}âš ï¸  Found $corrupted_count corrupted video file(s):${NC}\n"
    
    for corrupted_file in "${corrupted_files[@]}"; do
        local file_size=$(stat -c%s -- "$corrupted_file" 2>/dev/null || echo "0")
        local file_size_mb=$((file_size / 1024 / 1024))
        local reasons="${corruption_reasons[$corrupted_file]}"
        
        echo -e "    ${RED}âŒ${NC} $(basename -- "$corrupted_file") ${GRAY}(${file_size_mb}MB)${NC}"
        echo -e "       ${YELLOW}Reason: ${reasons}${NC}"
    done
    
    # Ask user with simple yes/no prompt
    echo ""
    echo -e "${YELLOW}${BOLD}âš ï¸  CORRUPTED VIDEOS DETECTED${NC}"
    echo ""
    echo -e "${CYAN}These files failed multiple validation tests:${NC}"
    echo -e "${CYAN}  â€¢ Cannot be read by video tools${NC}"
    echo -e "${CYAN}  â€¢ Missing critical metadata${NC}"
    echo -e "${CYAN}  â€¢ Will cause conversion errors${NC}"
    echo ""
    echo -e "${RED}${BOLD}âš ï¸  DELETE these $corrupted_count corrupted video file(s)?${NC}"
    echo -e "${GRAY}(Pressing Enter or 'n' will keep them)${NC}"
    echo ""
    echo -ne "${BOLD}Delete corrupted videos? (y/N): ${NC}"
    read -r delete_choice
    
    if [[ "$delete_choice" =~ ^[Yy]$ ]]; then
        echo -e "\n${RED}Deleting corrupted files...${NC}"
        local deleted=0
        for corrupted_file in "${corrupted_files[@]}"; do
            if rm -f "$corrupted_file" 2>/dev/null; then
                echo -e "  ${RED}âŒ Deleted: $(basename -- "$corrupted_file")${NC}"
                ((deleted++))
            else
                echo -e "  ${YELLOW}âš ï¸  Failed to delete: $(basename -- "$corrupted_file")${NC}"
            fi
        done
        echo -e "\n${GREEN}âœ“ Deleted $deleted corrupted video(s)${NC}"
    else
        echo -e "\n${GREEN}âœ“ Keeping all files - no changes made${NC}"
    fi
    
    echo ""
    return 0
}

# ðŸ” Hyper-Optimized AI-Powered Duplicate Detection with Multi-Threading
detect_duplicate_gifs() {
    echo -e "${BLUE}${BOLD}ðŸš€ AI-Enhanced Parallel Duplicate Detection${NC}"
    echo -e "${CYAN}ðŸ”¬ Multi-threaded analysis: Content fingerprinting + Visual similarity + Metadata comparison...${NC}"
    echo -e "${GREEN}âš¡ Using ${BOLD}$AI_DUPLICATE_THREADS${NC}${GREEN} CPU threads for maximum performance!${NC}"
    
    # Initialize AI cache and training systems
    init_hash_system  # Must be first - sets HASH_ALGORITHM
    init_ai_cache
    init_ai_training
    init_checksum_cache
    local cache_stats=$(get_cache_stats)
    local training_stats=$(get_ai_training_stats)
    local checksum_cache_stats=$(get_checksum_cache_stats)
    echo -e "${BLUE}ðŸ—„ï¸ AI Cache: $cache_stats${NC}"
    echo -e "${GREEN}ðŸ§  AI Training: $training_stats${NC}"
    echo -e "${CYAN}ðŸ” Checksum Cache: $checksum_cache_stats${NC}"
    
    # Note: Corruption checks for GIFs now run in Step 2 (detect_corrupted_gifs)
    echo -e "${GRAY}â„¹ï¸  Corruption checks are performed in Step 2 to keep duplicate detection fast${NC}"
    
    # ðŸ’¾ Show Level 6 cache statistics (remembered comparisons) with visual progress
    if [[ -f "$AI_CACHE_INDEX" ]]; then
        local l6_cached_count=$(grep -c '^L6_COMPARE:' "$AI_CACHE_INDEX" 2>/dev/null || echo "0")
        l6_cached_count=$(echo "$l6_cached_count" | tr -d '\n\r')  # Remove any newlines
        [[ -z "$l6_cached_count" || ! "$l6_cached_count" =~ ^[0-9]+$ ]] && l6_cached_count=0
        if [[ $l6_cached_count -gt 0 ]]; then
            # Calculate estimated total pairs for progress visualization
            local estimated_total_pairs=$(( total_files * (total_files - 1) / 2 ))
            local cache_progress_pct=0
            if [[ $estimated_total_pairs -gt 0 ]]; then
                cache_progress_pct=$(( l6_cached_count * 100 / estimated_total_pairs ))
                # Cap at 100% to avoid overflow display
                [[ $cache_progress_pct -gt 100 ]] && cache_progress_pct=100
            fi
            
            echo -e "${MAGENTA}ðŸ’¾ Level 6 Cache: ${BOLD}$l6_cached_count${NC}${MAGENTA} pair comparisons remembered${NC}"
            
            # Visual progress bar showing cached portion
            if [[ $cache_progress_pct -gt 0 ]]; then
                local cache_filled=$((cache_progress_pct * 30 / 100))
                local cache_empty=$((30 - cache_filled))
                printf "  ${GRAY}Progress restored: [${NC}"
                for ((k=0; k<cache_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((k=0; k<cache_empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${GRAY}] ${BOLD}${cache_progress_pct}%%${NC} ${GRAY}complete${NC}\n"
            fi
            
            echo -e "  ${GRAY}â†’ These will load instantly without re-analysis${NC}"
        fi
    fi
    
    local total_gifs=0
    local duplicate_count=0
    local duplicate_pairs=()
    declare -A gif_checksums
    declare -A gif_sizes
    declare -A gif_fingerprints
    declare -A gif_visual_hashes
    declare -A gif_frame_counts
    declare -A gif_durations
    
    # Create temporary directory for analysis in persistent location
    local temp_analysis_dir="${GIF_CONVERTER_DIR}/temp/gif/analysis_$$"
    mkdir -p "$temp_analysis_dir"
    # Cleanup old temp directories (older than 1 day)
    find "${GIF_CONVERTER_DIR}/temp/gif" -maxdepth 1 -name "analysis_*" -type d -mtime +1 -exec rm -rf {} \; 2>/dev/null || true
rue
    
    # Count total GIF files first for progress calculation (avoid duplicates)
    local gif_files_list=()
    declare -A seen_files  # Track files to avoid duplicates
    
    echo -e "  ${CYAN}ðŸ” Scanning GIF files...${NC}"
    
    shopt -s nullglob
    
    # Build list of GIF files - ONLY scan OUTPUT_DIRECTORY if it's different from current dir
    local all_gifs=()
    
    if [[ -d "$OUTPUT_DIRECTORY" && "$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd)" != "$(pwd)" ]]; then
        # OUTPUT_DIRECTORY is configured and different - scan ONLY there
        echo -e "  ${BLUE}ðŸ“‚ Scanning output directory: $OUTPUT_DIRECTORY${NC}"
        all_gifs=("$OUTPUT_DIRECTORY"/*.gif)
    else
        # No separate output directory - scan current dir
        echo -e "  ${GRAY}ðŸ“‚ Scanning current directory${NC}"
        all_gifs=(*.gif)
    fi
    
    local total_to_scan=${#all_gifs[@]}
    local scan_count=0
    
    for gif_file in "${all_gifs[@]}"; do
        if [[ -f "$gif_file" && "${gif_file##*.}" == "gif" && -z "${seen_files["$gif_file"]}" ]]; then
            gif_files_list+=("$gif_file")
            seen_files["$gif_file"]=1
            ((scan_count++))
            
            # Show progress bar every few files
            if [[ $((scan_count % 5)) -eq 0 || $scan_count -eq $total_to_scan ]]; then
                local progress=$((scan_count * 100 / total_to_scan))
                local filled=$((progress * 20 / 100))
                local empty=$((20 - filled))
                
                # Truncate filename if too long
                local display_name="$(basename -- "$gif_file")"
                if [[ ${#display_name} -gt 50 ]]; then
                    display_name="${display_name:0:47}..."
                fi
                
                printf "\r  ${CYAN}["
                for ((j=0; j<filled; j++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((j=0; j<empty; j++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}Found %d files${NC}" "$progress" "$scan_count"
                printf "\n  ${GRAY}ðŸ“„ %s${NC}" "$display_name"
                printf "\r\033[1A"  # Move cursor back up to progress bar line
            fi
        fi
    done
    shopt -u nullglob
    
    # Show final count (keep it visible)
    printf "\r  ${GREEN}["
    for ((j=0; j<20; j++)); do printf "${GREEN}â–ˆ${NC}"; done
    printf "${GREEN}] ${BOLD}100%%${NC} ${BLUE}Found %d GIF files${NC}\n" "$scan_count"
    
    # Remove any duplicates from the array
    local unique_files_list=()
    declare -A dedup_tracker
    for gif_file in "${gif_files_list[@]}"; do
        if [[ -z "${dedup_tracker["$gif_file"]}" ]]; then
            unique_files_list+=("$gif_file")
            dedup_tracker["$gif_file"]=1
        fi
    done
    gif_files_list=("${unique_files_list[@]}")
    
    local total_files=${#gif_files_list[@]}
    if [[ $total_files -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No existing GIF files found${NC}"
        return 0
    fi
    
    # ðŸ§  DYNAMIC AI DECISION ENGINE
    # AI will intelligently evaluate EACH pair in real-time (no pre-decisions)
    if [[ "${AI_AUTO_OPTIMIZE:-true}" == "true" ]]; then
        echo -e "  ${MAGENTA}${BOLD}ðŸ§  AI Dynamic Decision Engine: Active${NC}"
        echo -e "    ${CYAN}ðŸ“Š Collection: $total_files files ($(( total_files * (total_files - 1) / 2 )) comparisons)${NC}"
        echo -e "    ${CYAN}âš¡ Resources: $CPU_CORES cores, $(free -g 2>/dev/null | awk '/^Mem:/{print $2}' || echo '?')GB RAM${NC}"
        echo -e "    ${GREEN}âœ“ AI will evaluate each pair dynamically with real-time intelligence${NC}"
        echo -e "      ${GRAY}â†’ Level 6: Adaptive threshold based on collection size & pair similarity${NC}"
        echo ""
    fi
    
    # Calculate total size and estimate time
    local total_size=0
    for gif_file in "${gif_files_list[@]}"; do
        local file_size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
        total_size=$((total_size + file_size))
    done
    
    # Convert to human readable
    local total_size_mb=$((total_size / 1024 / 1024))
    local estimated_time_sec=$((total_files * 2))  # Rough estimate: 2 seconds per file
    local estimated_time_min=$((estimated_time_sec / 60))
    
    # Show sample files after scanning complete (truncated for readability)
    local samples=""
    for ((i=0; i<3 && i<${#gif_files_list[@]}; i++)); do
        local fname="$(basename -- "${gif_files_list[$i]}")"
        # Truncate long filenames
        if [[ ${#fname} -gt 30 ]]; then
            fname="${fname:0:27}..."
        fi
        samples+="$fname, "
    done
    echo -e "  ${GRAY}ðŸ“‚ Sample: ${samples}...${NC}"
    
    # Pre-scan to count cached vs uncached files AND build list of only uncached files
    echo -e "  ${BLUE}${BOLD}ðŸ” Smart detection: Checking which files need analysis...${NC}"
    local files_to_analyze=0
    local files_cached=0
    declare -a uncached_files_list  # Only files that need processing
    
    # OPTIMIZATION: Load cache index into memory once instead of calling check_ai_cache 200+ times
    declare -A cache_lookup
    if [[ "$AI_CACHE_ENABLED" == "true" && -f "$AI_CACHE_INDEX" ]]; then
        # Load entire cache into associative array for O(1) lookups
        while IFS='|' read -r filename filesize filemtime timestamp analysis_data; do
            [[ "$filename" =~ ^# ]] && continue  # Skip comments
            [[ -z "$filename" ]] && continue     # Skip empty lines
            # Store with filename as key, fingerprint:data as value
            cache_lookup["$filename"]="${filesize}:${filemtime}|${analysis_data}"
        done < <(tail -n +4 "$AI_CACHE_INDEX" 2>/dev/null)
    fi
    
    # Initialize results file BEFORE cache loading (so cached data can be written to it)
    local results_file="$temp_analysis_dir/analysis_results.txt"
    : > "$results_file"  # Initialize empty file
    
    # Build list of ONLY files that need analysis (NEW, CHANGED, or NOT CACHED)
    local idx_prescan
    for ((idx_prescan=0; idx_prescan<total_files; idx_prescan++)); do
        local prescan_file="${gif_files_list[$idx_prescan]}"
        local prescan_basename=$(basename -- "$prescan_file")
        
        local needs_analysis=true
        
        # Fast O(1) cache lookup using associative array
        if [[ -n "${cache_lookup[$prescan_basename]}" ]]; then
            # Check if file changed by comparing fingerprints
            local cached_entry="${cache_lookup[$prescan_basename]}"
            local cached_fingerprint=$(echo "$cached_entry" | cut -d'|' -f1)
            local cached_data=$(echo "$cached_entry" | cut -d'|' -f2-)
            
            # Get current file fingerprint (fast: just size + mtime)
            local current_filesize=$(stat -c%s -- "$prescan_file" 2>/dev/null || echo "0")
            local current_filemtime=$(stat -c%Y -- "$prescan_file" 2>/dev/null || echo "0")
            local current_fingerprint="${current_filesize}:${current_filemtime}"
            
            # If fingerprint matches and it's duplicate detection data, file is cached
            if [[ "$cached_fingerprint" == "$current_fingerprint" && "$cached_data" =~ ^DUPLICATE_DETECT: ]]; then
                ((files_cached++))
                needs_analysis=false  # File unchanged, skip it!
                
                # Load cached data directly into results (no processing needed)
                local results_file="$temp_analysis_dir/analysis_results.txt"
                echo "${cached_data#DUPLICATE_DETECT:}" >> "$results_file"
            fi
        fi
        
        # Add to processing list only if needs analysis
        if [[ "$needs_analysis" == "true" ]]; then
            uncached_files_list+=("$prescan_file")
            ((files_to_analyze++))
        fi
    done
    
    # From now on, ONLY process files in uncached_files_list (not all files!)
    # Clean up cache lookup
    unset cache_lookup
    
    echo -e "  ${BLUE}${BOLD}ðŸ§  Stage 1: Parallel content fingerprinting (${AI_DUPLICATE_THREADS} threads)...${NC}"
    if [[ $files_cached -gt 0 ]]; then
        echo -e "  ${YELLOW}ðŸ“Š Found ${BOLD}${total_files}${NC}${YELLOW} GIF files (${BOLD}${total_size_mb}MB${NC}${YELLOW} total)${NC}"
        echo -e "  ${GREEN}ðŸ’¾ Cached: ${BOLD}${files_cached}${NC}${GREEN} files (instant load)${NC}"
        echo -e "  ${CYAN}âš¡ To analyze: ${BOLD}${files_to_analyze}${NC}${CYAN} files (need MD5 calculation)${NC}"
        if [[ $files_to_analyze -gt 0 ]]; then
            # Recalculate estimated time for only files needing analysis
            local estimated_time_min=$(( (total_size_mb / files_to_analyze) * files_to_analyze / 60 ))
            [[ $estimated_time_min -lt 1 ]] && estimated_time_min=1
            echo -e "  ${CYAN}â±ï¸  Estimated time: ~${estimated_time_min} minutes (varies by file size)${NC}"
        fi
    else
        echo -e "  ${YELLOW}ðŸ“Š Processing ${BOLD}${total_files}${NC}${YELLOW} GIF files (${BOLD}${total_size_mb}MB${NC}${YELLOW} total)${NC}"
        echo -e "  ${CYAN}â±ï¸  Estimated time: ~${estimated_time_min} minutes (varies by file size)${NC}"
    fi
    echo -e "  ${GRAY}ðŸ’¡ Larger files take longer to calculate MD5 checksums${NC}"
    
    # Parallel analysis function for individual GIF files with timeout
    analyze_gif_parallel() {
        local gif_file="$1"
        local temp_dir="$2"
        local result_file="$3"
        local current_index="$4"     # Current file index for progress
        local total_files="$5"       # Total file count for progress
        local timeout_seconds=60     # Increased to 60 seconds per file - more reasonable for complex GIFs
        
        # Check if file exists and is readable
        if [[ ! -f "$gif_file" ]]; then
            local error_msg="File not found: $gif_file"
            log_error "$error_msg" "$gif_file" "File missing during duplicate detection"
            echo "$gif_file|ERROR|0|0:0:0:0x0||0|0" >> "$result_file"
            return 1
        elif [[ ! -r "$gif_file" ]]; then
            local error_msg="File not readable: $gif_file (permissions issue)"
            log_error "$error_msg" "$gif_file" "Permission denied during duplicate detection"
            echo "$gif_file|ERROR|0|0:0:0:0x0||0|0" >> "$result_file"
            return 1
        fi
        
        # Check cache first - look for DUPLICATE_DETECT prefix
        local cached_analysis=$(check_ai_cache "$gif_file" 2>/dev/null)
        if [[ $? -eq 0 && -n "$cached_analysis" ]]; then
            # Check if this is duplicate detection cache data
            if [[ "$cached_analysis" =~ ^DUPLICATE_DETECT: ]]; then
                # Cache hit - extract and use cached results (skip MD5 calculation!)
                local cached_data="${cached_analysis#DUPLICATE_DETECT:}"
                echo "$cached_data" >> "$result_file"
                
                # Update progress to show cache hit
                if [[ -n "$current_index" && -n "$total_files" ]]; then
                    update_file_progress "$current_index" "$total_files" "$(basename -- "$gif_file") [cached]" "Analyzing GIFs" 30
                fi
                # Increment cache hit counter (use file to share between function calls)
                echo "1" >> "$temp_dir/cache_hits.count" 2>/dev/null || true
                return 0
            fi
        fi
        
        # Simplified analysis using MD5 hash - much faster and reliable
        {
            # Display progress for current file
            if [[ -n "$current_index" && -n "$total_files" ]]; then
                update_file_progress "$current_index" "$total_files" "$(basename -- "$gif_file")" "Analyzing GIFs" 30
            fi
            
            # Stage 1: Fast MD5 checksum with intelligent caching
            # Use cached checksum if available, only calculate if needed
            local checksum
            local size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
            
            # Try to get cached checksum first
            checksum=$(get_cached_checksum "$gif_file" 2>/dev/null)
            
            # If cache failed or returned empty, fallback to direct calculation with timeout
            if [[ -z "$checksum" ]]; then
                # Use fast hash (xxhash/blake3/md5) - dramatically faster!
                if checksum=$(timeout 10 fast_hash "$gif_file" 2>/dev/null); then
                    [[ -z "$checksum" ]] && checksum="ERROR"
                else
                    checksum="TIMEOUT_HASH"
                    echo -e "  ${YELLOW}â° Hash timeout: $(basename -- "$gif_file")${NC}" >&2
                fi
            fi
            
            # Check if hash calculation failed or timed out (likely corruption)
            if [[ "$checksum" == "ERROR" || "$checksum" == "TIMEOUT_HASH" ]]; then
                local failure_reason
                if [[ "$checksum" == "TIMEOUT_HASH" ]]; then
                    failure_reason="Hash calculation timed out - likely severely corrupted file"
                    echo -e "  ${RED}ðŸš« Corrupted file (hash timeout): $(basename -- "$gif_file")${NC}" >&2
                else
                    failure_reason="Hash calculation failed - file may be corrupted"
                fi
                
                # Use AI to verify if this is truly corrupted or just a permission issue
                local ai_health_verdict=$(ai_analyze_file_health "$gif_file" "md5_failed")
                if [[ "$ai_health_verdict" == "SKIP_NON_GIF" || "$ai_health_verdict" == "SKIP_VIDEO_FILE" ]]; then
                    # AI skipped - treat as regular MD5 failure
                    local error_msg="Cannot calculate MD5 hash: $gif_file ($failure_reason)"
                    log_error "$error_msg" "$gif_file" "$failure_reason"
                    echo "$gif_file|CORRUPTED|$size|unknown||0|0" >> "$result_file"
                    return 1
                elif [[ "$ai_health_verdict" == "CORRUPTED" ]]; then
                    # SAFETY: AI corruption detection NEVER triggers automatic deletion
                    # Only log and mark for manual review
                    local error_msg="AI detected potential corruption: $gif_file (MD5 failed, AI analysis suggests corruption)"
                    log_error "$error_msg" "$gif_file" "AI corruption detection - file marked for manual review, NOT auto-deleted"
                    echo "$gif_file|AI_CORRUPTED_REVIEW|$size|unknown||0|0" >> "$result_file"
                    # Train AI model with this corruption pattern
                    train_ai_file_health "$gif_file" "corrupted" "md5_failed" "confirmed"
                    echo -e "  ${YELLOW}ðŸ” AI flagged for review: $(basename -- "$gif_file") (potential corruption)${NC}" >&2
                    return 1
                else
                    # AI thinks file might be OK despite MD5 failure - mark as suspicious
                    local error_msg="Suspicious file (MD5 failed but AI uncertain): $gif_file"
                    log_error "$error_msg" "$gif_file" "MD5 failed but AI analysis suggests possible false positive"
                    echo "$gif_file|AI_SUSPICIOUS|$size|unknown||0|0" >> "$result_file"
                    # Train AI model with this edge case
                    train_ai_file_health "$gif_file" "suspicious" "md5_failed" "uncertain"
                    return 1
                fi
            fi
            
            # Stage 2: Enhanced metadata with FFprobe (fast and reliable for frame/duration)
            local frame_count="0"
            local duration="0" 
            local resolution="unknown"
            local perceptual_hash=""
            
            # Use FFprobe to get accurate frame count and duration (much faster than FFmpeg)
            # Timeout after 3 seconds to avoid hanging on corrupted files
            if command -v ffprobe >/dev/null 2>&1; then
                local ffprobe_output=$(timeout 3 ffprobe -v error -select_streams v:0 \
                    -count_packets -show_entries stream=nb_read_packets,duration,width,height \
                    -of csv=p=0 "$gif_file" 2>/dev/null)
                
                if [[ -n "$ffprobe_output" ]]; then
                    # Parse ffprobe output: nb_read_packets,duration,width,height
                    frame_count=$(echo "$ffprobe_output" | cut -d',' -f1)
                    duration=$(echo "$ffprobe_output" | cut -d',' -f2 | cut -d'.' -f1)  # Round to integer
                    local width=$(echo "$ffprobe_output" | cut -d',' -f3)
                    local height=$(echo "$ffprobe_output" | cut -d',' -f4)
                    resolution="${width}x${height}"
                    
                    # Ensure we have valid numbers
                    [[ ! "$frame_count" =~ ^[0-9]+$ ]] && frame_count="0"
                    [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
                fi
            fi
            
            # AI-powered perceptual hash for visual similarity detection
            # Extract middle frame and create a simple perceptual hash
            if [[ "$frame_count" -gt 0 ]] && command -v ffmpeg >/dev/null 2>&1; then
                # Extract a frame from middle of GIF for perceptual hashing
                local temp_frame="$temp_dir/frame_${RANDOM}.png"
                if timeout 2 ffmpeg -i "$gif_file" -vf "select=eq(n\,$(( frame_count / 2 )))" \
                    -vframes 1 -f image2 "$temp_frame" >/dev/null 2>&1; then
                    
                    # Create simple perceptual hash: average hash (aHash) algorithm
                    # Resize to 8x8, convert to grayscale, get average brightness
                    if command -v convert >/dev/null 2>&1; then
                        # Using ImageMagick for fast perceptual hash
                        perceptual_hash=$(convert "$temp_frame" -resize 8x8! -colorspace gray \
                            -format "%[fx:mean]" info: 2>/dev/null | tr -d '.')
                    fi
                    rm -f "$temp_frame" 2>/dev/null
                fi
            fi
            
            # Fallback to basic file validation if FFprobe unavailable
            if [[ "$resolution" == "unknown" ]]; then
                local file_info=$(file "$gif_file" 2>/dev/null || echo "unknown")
                if [[ "$file_info" == *"GIF"* ]]; then
                    resolution="valid_gif"
                elif [[ "$file_info" == *"data"* ]] && [[ $size -gt 1024 ]]; then
                    resolution="possible_gif"
                else
                    resolution="invalid_format"
                fi
            fi
            
            # Create enhanced content fingerprint with frame/duration data
            local content_fingerprint="${size}:${resolution}:${frame_count}:${duration}"
            
            # Prepare analysis data with perceptual hash
            local analysis_data="$gif_file|$checksum|$size|$content_fingerprint|$perceptual_hash|$frame_count|$duration"
            
            # Save to cache for future runs with DUPLICATE_DETECT prefix to distinguish from AI analysis cache
            save_to_ai_cache "$gif_file" "DUPLICATE_DETECT:$analysis_data" 2>/dev/null || true
            
            # Increment cache miss counter (MD5 was calculated)
            echo "1" >> "$temp_dir/cache_misses.count" 2>/dev/null || true
            
            # Write results atomically (no background processing - keep it simple and fast)
            echo "$analysis_data" >> "$result_file"
            
        } # No background process - execute immediately to avoid timeout issues
        
        return 0
    }
    
    # Export function for parallel execution
    export -f analyze_gif_parallel
    
    # Optimized version that uses pre-calculated hash from parallel batch
    analyze_gif_with_hash() {
        local gif_file="$1"
        local checksum="$2"  # Pre-calculated hash!
        local temp_dir="$3"
        local result_file="$4"
        local current_index="$5"
        local total_files="$6"
        
        # Display progress
        if [[ -n "$current_index" && -n "$total_files" ]]; then
            update_file_progress "$current_index" "$total_files" "$(basename -- "$gif_file")" "Analyzing metadata" 30
        fi
        
        local size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
        
        # Stage 2: Enhanced metadata with FFprobe (hash already done!)
        local frame_count="0"
        local duration="0"
        local resolution="unknown"
        local perceptual_hash=""
        
        # Use FFprobe to get accurate frame count and duration
        if command -v ffprobe >/dev/null 2>&1; then
            local ffprobe_output=$(timeout 3 ffprobe -v error -select_streams v:0 \
                -count_packets -show_entries stream=nb_read_packets,duration,width,height \
                -of csv=p=0 "$gif_file" 2>/dev/null)
            
            if [[ -n "$ffprobe_output" ]]; then
                frame_count=$(echo "$ffprobe_output" | cut -d',' -f1)
                duration=$(echo "$ffprobe_output" | cut -d',' -f2 | cut -d'.' -f1)
                local width=$(echo "$ffprobe_output" | cut -d',' -f3)
                local height=$(echo "$ffprobe_output" | cut -d',' -f4)
                resolution="${width}x${height}"
                
                [[ ! "$frame_count" =~ ^[0-9]+$ ]] && frame_count="0"
                [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
            fi
        fi
        
        # Create enhanced content fingerprint
        local content_fingerprint="${size}:${resolution}:${frame_count}:${duration}"
        
        # Prepare analysis data
        local analysis_data="$gif_file|$checksum|$size|$content_fingerprint|$perceptual_hash|$frame_count|$duration"
        
        # Save to cache with DUPLICATE_DETECT prefix
        save_to_ai_cache "$gif_file" "DUPLICATE_DETECT:$analysis_data" 2>/dev/null || true
        
        # Write results atomically
        echo "$analysis_data" >> "$result_file"
        
        return 0
    }
    
    # Results file already initialized earlier (line 6841) before cache loading
    
    # Process files sequentially with minimal parallelism to avoid timeout cascades
    local processed_files=0
    local auto_fixed_files=0
    local auto_deleted_files=0
    local auto_skipped_files=0
    declare -a fixed_files_list
    declare -a deleted_files_list
    declare -a skipped_files_list
    
    # Track cache statistics
    local cache_hits=0
    local cache_misses=0
    
    if [[ $files_to_analyze -gt 0 ]]; then
        echo -e "  ${BLUE}ðŸš€ Processing ${files_to_analyze} GIF files using TRUE parallel hashing (${AI_DUPLICATE_THREADS} threads)${NC}"
        echo -e "  ${GREEN}ðŸ’¾ Skipping ${files_cached} cached files (instant load)${NC}"
        echo -e "  ${CYAN}âš¡ Hash algorithm: ${HASH_ALGORITHM} (${HASH_SPEED})${NC}"
    else
        echo -e "  ${GREEN}ðŸš€ All ${total_files} GIF files are cached - loading instantly!${NC}"
    fi
    echo -e "  ${GRAY}ðŸ”ˆ Cache-enabled: Files analyzed before will load instantly!${NC}"
    
    # ðŸš€ REVOLUTIONARY: TRUE PARALLEL BATCH HASHING FOR GIFS!
    # Pre-calculate ALL hashes at once using all CPU cores
    declare -A gif_hash_lookup
    if [[ ${#uncached_files_list[@]} -gt 0 ]]; then
        echo -e "  ${MAGENTA}ðŸ”¥ Using parallel batch hashing for ${#uncached_files_list[@]} GIF files...${NC}"
        
        # Create temporary file for batch hash results
        local batch_hash_file="$temp_analysis_dir/gif_batch_hashes.txt"
        : > "$batch_hash_file"
        
        # Hash ALL uncached GIFs at once using all CPU cores!
        parallel_hash_batch uncached_files_list "$batch_hash_file"
        
        # Load hashes into lookup table for fast access
        while read -r hash_value filepath; do
            [[ -n "$filepath" && -n "$hash_value" ]] && gif_hash_lookup["$filepath"]="$hash_value"
        done < "$batch_hash_file"
        
        echo -e "  ${GREEN}âœ“ Pre-calculated ${#gif_hash_lookup[@]} hashes in parallel${NC}"
    fi
    
    # Emergency break mechanism to prevent infinite loops
    declare -A processed_files_tracker
    local emergency_break=false
    local consecutive_loop_detections=0
    
    # Clear any previous state that might cause loops
    unset processed_files_tracker
    declare -A processed_files_tracker
    
    # Track actual processing (exclude cached)
    local files_actually_processed=0
    local files_loaded_from_cache=0
    
    # ðŸš€ TRUE PARALLEL METADATA ANALYSIS using GNU parallel!
    if [[ ${#uncached_files_list[@]} -gt 0 ]] && command -v parallel >/dev/null 2>&1; then
        echo -e "  ${MAGENTA}ðŸš€ Analyzing metadata in parallel (${AI_DUPLICATE_THREADS} threads)...${NC}"
        
        # Create temporary script for parallel execution
        local parallel_script="$temp_analysis_dir/analyze_metadata.sh"
        local progress_counter="$temp_analysis_dir/progress_counter.txt"
        echo "0" > "$progress_counter"
        
        cat > "$parallel_script" << 'PARALLEL_EOF'
#!/bin/bash
analyze_single_gif() {
    local gif_file="$1"
    local checksum="$2"
    local result_file="$3"
    local progress_file="$4"
    
    local size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
    local frame_count="0"
    local duration="0"
    local resolution="unknown"
    
    # Use FFprobe to get metadata
    if command -v ffprobe >/dev/null 2>&1; then
        local ffprobe_output=$(timeout 3 ffprobe -v error -select_streams v:0 \
            -count_packets -show_entries stream=nb_read_packets,duration,width,height \
            -of csv=p=0 "$gif_file" 2>/dev/null)
        
        if [[ -n "$ffprobe_output" ]]; then
            frame_count=$(echo "$ffprobe_output" | cut -d',' -f1)
            duration=$(echo "$ffprobe_output" | cut -d',' -f2 | cut -d'.' -f1)
            local width=$(echo "$ffprobe_output" | cut -d',' -f3)
            local height=$(echo "$ffprobe_output" | cut -d',' -f4)
            resolution="${width}x${height}"
            [[ ! "$frame_count" =~ ^[0-9]+$ ]] && frame_count="0"
            [[ ! "$duration" =~ ^[0-9]+$ ]] && duration="0"
        fi
    fi
    
    # Update progress counter atomically
    if [[ -n "$progress_file" ]]; then
        flock -x "$progress_file" bash -c 'echo $(($(cat "$1" 2>/dev/null || echo 0) + 1)) > "$1"' _ "$progress_file" 2>/dev/null || true
    fi
    
    local content_fingerprint="${size}:${resolution}:${frame_count}:${duration}"
    echo "$gif_file|$checksum|$size|$content_fingerprint||$frame_count|$duration"
}
export -f analyze_single_gif
PARALLEL_EOF
        chmod +x "$parallel_script"
        
        # Create input file with filepath and hash pairs
        local parallel_input="$temp_analysis_dir/parallel_input.txt"
        : > "$parallel_input"
        for gif_file in "${uncached_files_list[@]}"; do
            local hash="${gif_hash_lookup[$gif_file]}"
            echo "$gif_file	$hash" >> "$parallel_input"
        done
        
        # Start parallel processing in background
        local metadata_results="$temp_analysis_dir/metadata_results.txt"
        source "$parallel_script"
        (
            cat "$parallel_input" | parallel --colsep '\t' -j "$AI_DUPLICATE_THREADS" \
                "analyze_single_gif {1} {2} '$results_file' '$progress_counter'" > "$metadata_results" 2>/dev/null
        ) &
        local parallel_pid=$!
        
        # Monitor progress with live progress bar
        local total_files=${#uncached_files_list[@]}
        local last_count=0
        while kill -0 $parallel_pid 2>/dev/null; do
            local current_count=$(cat "$progress_counter" 2>/dev/null || echo "0")
            
            if [[ $current_count -ne $last_count || $current_count -eq 0 ]]; then
                local progress=$((current_count * 100 / total_files))
                [[ $progress -gt 100 ]] && progress=100
                local filled=$((progress * 30 / 100))
                local empty=$((30 - filled))
                
                printf "\r  ${CYAN}["
                for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d files)${NC}" "$progress" "$current_count" "$total_files"
                
                last_count=$current_count
            fi
            
            sleep 0.2
        done
        
        # Wait for parallel to finish
        wait $parallel_pid 2>/dev/null
        
        # Show final 100% state
        local final_count=$(cat "$progress_counter" 2>/dev/null || echo "$total_files")
        printf "\r  ${CYAN}["
        for ((k=0; k<30; k++)); do printf "${GREEN}â–ˆ${NC}"; done
        printf "${CYAN}] ${BOLD}100%%${NC} ${GRAY}(%d/%d files)${NC}\n" "$final_count" "$total_files"
        
        # Append results and save to cache (batch operation for speed)
        if [[ -f "$metadata_results" ]]; then
            local cache_batch_file="$temp_analysis_dir/cache_batch.txt"
            : > "$cache_batch_file"
            
            while IFS='|' read -r filepath checksum size fingerprint phash frames dur; do
                [[ -z "$filepath" ]] && continue
                echo "$filepath|$checksum|$size|$fingerprint|$phash|$frames|$dur" >> "$results_file"
                
                # Prepare cache entry
                if [[ "$AI_CACHE_ENABLED" == "true" && -f "$filepath" ]]; then
                    local filesize=$(stat -c%s "$filepath" 2>/dev/null || echo "0")
                    local filemtime=$(stat -c%Y "$filepath" 2>/dev/null || echo "0")
                    local timestamp=$(date +%s)
                    local filename=$(basename -- "$filepath")
                    local analysis_data="DUPLICATE_DETECT:$filepath|$checksum|$size|$fingerprint|$phash|$frames|$dur"
                    echo "$filename|$filesize|$filemtime|$timestamp|$analysis_data" >> "$cache_batch_file"
                fi
            done < "$metadata_results"
            
            # Single atomic append to cache index
            if [[ -s "$cache_batch_file" && "$AI_CACHE_ENABLED" == "true" ]]; then
                cat "$cache_batch_file" >> "$AI_CACHE_INDEX" 2>/dev/null || true
            fi
        fi
        
        files_actually_processed=${#uncached_files_list[@]}
        echo -e "  ${GREEN}âœ“ Analyzed ${files_actually_processed} files in parallel${NC}"
    else
        # Fallback to sequential processing if parallel not available
        echo -e "  ${YELLOW}âš ï¸  GNU parallel not available, using sequential processing${NC}"
    
    # Use simple while loop - process ONLY uncached files
    local loop_idx=0
    local total_to_process=${#uncached_files_list[@]}
    while [[ $loop_idx -lt $total_to_process ]]; do
        # Check if user requested interrupt (Ctrl+C)
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\n  ${YELLOW}â¸ï¸  Analysis interrupted by user${NC}"
            echo -e "  ${CYAN}ðŸ’¾ Processed: $files_actually_processed, Cached: $files_loaded_from_cache${NC}"
            break
        fi
        
        local gif_file="${uncached_files_list[$loop_idx]}"
        
        # This file needs processing (not cached)
        
        # Emergency break: If we've seen this EXACT file before in THIS session
        # This should NEVER happen in a proper loop, so it indicates array has duplicates
        if [[ -n "${processed_files_tracker["$gif_file"]}" ]]; then
            # Increment the detection count for THIS SPECIFIC FILE
            local file_detection_count=${processed_files_tracker["$gif_file"]}
            file_detection_count=$((file_detection_count + 1))
            processed_files_tracker["$gif_file"]=$file_detection_count
            
            echo -e "  ${RED}âš ï¸ Emergency break: Duplicate processing detected for $(basename -- "$gif_file") (seen $file_detection_count times)${NC}" >&2
            
            # If this SPECIFIC file has been seen too many times, skip it
            if [[ $file_detection_count -ge 3 ]]; then
                echo -e "  ${RED}ðŸ›‘ Skipping problematic file after $file_detection_count attempts${NC}" >&2
                log_conversion "EMERGENCY_SKIP" "$gif_file" "" "File appeared multiple times in loop - systematic issue"
                continue
            fi
            
            # Count consecutive different files being flagged
            consecutive_loop_detections=$((consecutive_loop_detections + 1))
            
            # If many DIFFERENT files are being flagged, abort entire analysis
            if [[ $consecutive_loop_detections -ge 5 ]]; then
                echo -e "  ${RED}ðŸ›‘ ABORTING: Too many different files flagged - likely systematic issue${NC}" >&2
                echo -e "  ${YELLOW}ðŸ’¡ Try restarting the script or check for file system issues${NC}" >&2
                emergency_break=true
                break
            fi
            
            log_conversion "EMERGENCY_SKIP" "$gif_file" "" "Duplicate file in processing queue - skipping"
            echo -e "  ${YELLOW}â­ï¸ Skipping duplicate queue entry: $(basename -- "$gif_file")${NC}" >&2
            ((loop_idx++))  # Increment before continue
            continue  # Skip this file and continue with next
        fi
        
        # Mark file as seen (first time = 1)
        processed_files_tracker["$gif_file"]=1
        
        # Reset consecutive counter on successful new file processing
        consecutive_loop_detections=0
        
        # ==================================================================
        # âš¡ PERFORMANCE OPTIMIZED: NO CORRUPTION CHECKING HERE
        # All corruption detection moved to detect_corrupted_gifs() phase
        # This keeps duplicate detection FAST (just MD5 + metadata)
        # ==================================================================
        
        # Get file size
        local size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
        
        # Skip unreadable files
        if [[ ! -r "$gif_file" ]]; then
            echo "$gif_file|UNREADABLE|0|unknown||0|0" >> "$results_file"
            echo -e "  ${RED}âš ï¸ Skipped unreadable: $(basename -- "$gif_file")${NC}" >&2
            log_conversion "AUTO_SKIP" "$gif_file" "" "File not readable - permission denied"
            ((loop_idx++))
            continue
        fi
        
        # Skip 0-byte files
        if [[ $size -eq 0 ]]; then
            echo "$gif_file|EMPTY|0|empty_file||0|0" >> "$results_file"
            ((loop_idx++))
            continue
        fi
        
        # This file is in uncached list, so it needs processing
        ((files_actually_processed++))
        
        # âš¡ OPTIMIZATION: Use pre-calculated hash from parallel batch!
        local precalc_checksum="${gif_hash_lookup[$gif_file]}"
        
        # If we have a pre-calculated hash, use optimized function
        if [[ -n "$precalc_checksum" && "$precalc_checksum" != "ERROR" ]]; then
            # Fast path: hash already calculated in parallel
            analyze_gif_with_hash "$gif_file" "$precalc_checksum" "$temp_analysis_dir" "$results_file" $files_actually_processed $files_to_analyze
        else
            # Fallback: calculate hash individually (should be rare)
            analyze_gif_parallel "$gif_file" "$temp_analysis_dir" "$results_file" $files_actually_processed $files_to_analyze
        fi
        
        # Increment loop counter at end of iteration
        ((loop_idx++))
    done
    
    # Check if we hit emergency break
    if [[ "$emergency_break" == "true" ]]; then
        echo -e "\n  ${RED}ðŸ›‘ ANALYSIS ABORTED DUE TO INFINITE LOOP DETECTION${NC}"
        echo -e "  ${YELLOW}ðŸ’¡ This usually indicates file system corruption or permission issues${NC}"
        echo -e "  ${BLUE}ðŸ”— Try: Check file permissions, restart script, or run fsck${NC}"
        return 1
    fi
    fi  # End of if-else for parallel vs sequential processing
    
    # Final progress update - show accurate counts
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        printf "\r  ${YELLOW}â¸ï¸  Analysis stopped!${NC}\n"
    else
        printf "\r  ${GREEN}âœ“ Analysis complete! ${NC}\n"
    fi
    
    # Display cache statistics
    if [[ -f "$temp_analysis_dir/cache_hits.count" ]]; then
        cache_hits=$(wc -l < "$temp_analysis_dir/cache_hits.count" 2>/dev/null || echo "0")
    fi
    if [[ -f "$temp_analysis_dir/cache_misses.count" ]]; then
        cache_misses=$(wc -l < "$temp_analysis_dir/cache_misses.count" 2>/dev/null || echo "0")
    fi
    
    if [[ $cache_hits -gt 0 || $cache_misses -gt 0 ]]; then
        local cache_percentage=$((cache_hits * 100 / (cache_hits + cache_misses)))
        echo -e "  ${CYAN}ðŸ’¾ Cache Performance:${NC}"
        echo -e "    ${GREEN}âœ“ Cached (instant): $cache_hits files${NC}"
        echo -e "    ${YELLOW}âš¡ Calculated (MD5): $cache_misses files${NC}"
        echo -e "    ${BLUE}ðŸ“Š Cache hit rate: ${cache_percentage}%${NC}"
        if [[ $cache_misses -gt 0 ]]; then
            echo -e "    ${GRAY}ðŸ’¡ Next run: ${cache_misses} more files will be cached!${NC}"
        fi
    fi
    
    # Show file maintenance summary
    local auto_actions_count=$(grep -E "AUTO_(FIXED|DELETED|SKIP)" "$results_file" 2>/dev/null | wc -l)
    if [[ $auto_actions_count -gt 0 ]]; then
        echo -e "\n  ${CYAN}${BOLD}ðŸ”§ AUTOMATIC FILE MAINTENANCE SUMMARY:${NC}"
        
        # Count and report fixed files
        local fixed_count=$(grep "AUTO_FIXED" "$results_file" 2>/dev/null | wc -l)
        if [[ $fixed_count -gt 0 ]]; then
            echo -e "    ${GREEN}âœ“ Fixed $fixed_count file(s) with double extensions (.gif.gif â†’ .gif)${NC}"
        fi
        
        # Count and report deleted files
        local deleted_count=$(grep "AUTO_DELETED" "$results_file" 2>/dev/null | wc -l)
        if [[ $deleted_count -gt 0 ]]; then
            echo -e "    ${RED}ðŸ—‘ï¸ Deleted $deleted_count empty file(s) (0 bytes)${NC}"
        fi
        
        # Count and report skipped files
        local skipped_count=$(grep "AUTO_SKIP" "$results_file" 2>/dev/null | wc -l)
        if [[ $skipped_count -gt 0 ]]; then
            echo -e "    ${YELLOW}âš ï¸ Skipped $skipped_count problematic file(s)${NC}"
        fi
        
        echo -e "    ${BLUE}ðŸ“„ All actions logged in: ${BOLD}$(basename -- "$CONVERSION_LOG")${NC}"
        echo -e "    ${GRAY}ðŸ” View details: tail -20 \"$CONVERSION_LOG\"${NC}"
    fi
    
    # Process results from parallel analysis and count errors
    local error_files=0
    local timeout_files=0
    local large_files=0
    local unreadable_files=0
    local successful_files=0
    
    while IFS='|' read -r gif_file checksum size content_fingerprint visual_hash frame_count duration; do
        [[ -z "$gif_file" ]] && continue  # Skip empty lines
        
        # Count different types of results
        case "$checksum" in
            "ERROR"|"UNREADABLE")
                ((error_files++))
                ((unreadable_files++))
                ;;
            "TIMEOUT"|"SLOW_ANALYSIS"|"CORRUPTED"|"AI_CORRUPTED")
                ((error_files++))
                ((timeout_files++))
                ;;
            "AI_SUSPICIOUS"|"AI_LEARNING")
                # AI learning cases - include in analysis but flag as uncertain
                gif_checksums["$gif_file"]="AI_UNCERTAIN_${size}"
                gif_sizes["$gif_file"]="$size"
                gif_fingerprints["$gif_file"]="$content_fingerprint"
                gif_visual_hashes["$gif_file"]="$visual_hash"
                gif_frame_counts["$gif_file"]="$frame_count"
                gif_durations["$gif_file"]="$duration"
                ((total_gifs++))
                ((successful_files++))
                ;;
            "AI_COMPLEX")
                # AI confirmed complex but valid files
                gif_checksums["$gif_file"]="AI_COMPLEX_${size}"
                gif_sizes["$gif_file"]="$size"
                gif_fingerprints["$gif_file"]="$content_fingerprint"
                gif_visual_hashes["$gif_file"]="$visual_hash"
                gif_frame_counts["$gif_file"]="$frame_count"
                gif_durations["$gif_file"]="$duration"
                ((total_gifs++))
                ((successful_files++))
                ;;
            "LARGE_FILE")
                ((large_files++))
                ;;
            *)
                gif_checksums["$gif_file"]="$checksum"
                gif_sizes["$gif_file"]="$size"
                gif_fingerprints["$gif_file"]="$content_fingerprint"
                gif_visual_hashes["$gif_file"]="$visual_hash"
                gif_frame_counts["$gif_file"]="$frame_count"
                gif_durations["$gif_file"]="$duration"
                ((total_gifs++))
                ((successful_files++))
                ;;
        esac
    done < "$results_file"
    
    # Clear progress line and show completion with error summary
    local final_cache_stats=$(get_cache_stats)
    
    # Show accurate status based on interruption
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        printf "\r  ${YELLOW}â¸ï¸  Analysis interrupted! ${NC}\n"
        echo -e "  ${CYAN}${BOLD}ðŸ“ˆ PARTIAL ANALYSIS SUMMARY:${NC}"
        echo -e "    ${YELLOW}â¸ï¸  Analyzed so far: ${BOLD}$successful_files${NC} ${YELLOW}files (out of $total_files)${NC}"
    else
        printf "\r  ${GREEN}âœ“ Parallel content analysis complete! ${NC}\n"
        echo -e "  ${CYAN}${BOLD}ðŸ“ˆ AI-ENHANCED ANALYSIS SUMMARY:${NC}"
        echo -e "    ${GREEN}âœ“ Successfully analyzed: ${BOLD}$successful_files${NC} ${GREEN}files${NC}"
    fi
    
    # Count AI-enhanced categories
    local ai_complex_files=0
    local ai_suspicious_files=0
    local ai_corrupted_files=0
    
    # Count AI categories from results
    while IFS='|' read -r gif_file checksum size content_fingerprint visual_hash frame_count duration; do
        [[ -z "$gif_file" ]] && continue
        case "$checksum" in
            "AI_CORRUPTED") ((ai_corrupted_files++)) ;;
            "AI_COMPLEX") ((ai_complex_files++)) ;;
            "AI_SUSPICIOUS"|"AI_LEARNING") ((ai_suspicious_files++)) ;;
        esac
    done < "$results_file"
    
    # Show AI analysis results
    if [[ $ai_complex_files -gt 0 ]]; then
        echo -e "    ${CYAN}ðŸ§  AI identified complex files: ${BOLD}$ai_complex_files${NC} ${CYAN}(legitimate but slow)${NC}"
    fi
    
    if [[ $ai_suspicious_files -gt 0 ]]; then
        echo -e "    ${YELLOW}ðŸ¤– AI learning from: ${BOLD}$ai_suspicious_files${NC} ${YELLOW}uncertain files${NC}"
    fi
    
    if [[ $ai_corrupted_files -gt 0 ]]; then
        echo -e "    ${RED}ðŸš« AI detected corruption: ${BOLD}$ai_corrupted_files${NC} ${RED}files${NC}"
    fi
    
    if [[ $large_files -gt 0 ]]; then
        echo -e "    ${YELLOW}âš ï¸ Skipped large files: ${BOLD}$large_files${NC} ${YELLOW}files (>100MB)${NC}"
    fi
    
    if [[ $timeout_files -gt 0 ]]; then
        echo -e "    ${RED}âš ï¸ Analysis issues: ${BOLD}$timeout_files${NC} ${RED}files (see error log)${NC}"
    fi
    
    if [[ $unreadable_files -gt 0 ]]; then
        echo -e "    ${RED}âš ï¸ Unreadable: ${BOLD}$unreadable_files${NC} ${RED}files (permission issues)${NC}"
    fi
    
    if [[ $error_files -gt 0 ]]; then
        echo -e "    ${RED}${BOLD}âš ï¸ Total issues: $error_files files${NC}"
        echo -e "    ${BLUE}ðŸ“„ Check error log: ${BOLD}$(basename -- "$ERROR_LOG")${NC}"
        echo -e "    ${GRAY}ðŸ¤– AI is learning from these patterns to improve future detection${NC}"
    fi
    
    echo -e "  ${BLUE}ðŸ—„ï¸ Cache updated: $final_cache_stats${NC}"
    echo -e "  ${GRAY}Used ${BOLD}$AI_DUPLICATE_THREADS threads${NC} ${GRAY}for parallel processing${NC}"
    
    # ðŸ’¾ Initialize Multi-Layer Smart Cache for GIF comparison
    echo -e "  ${CYAN}ðŸ’¾ Initializing multi-layer smart comparison cache...${NC}"
    printf "  ${GRAY}  â””â”€ Validating GIF cache integrity...${NC}"
    local gif_smart_cache_file=""
    if init_comparison_cache "gif" 2>/dev/null; then
        gif_smart_cache_file="$HOME/.smart-gif-converter/gif_comparison_cache.db"
        printf "\r\033[K"
        echo -e "  ${GREEN}  âœ“ GIF cache validated${NC}"
        
        # Check cache health
        printf "  ${CYAN}  â””â”€ Loading GIF cache entries...${NC}"
        local cache_header=$(head -n 10 "$gif_smart_cache_file" 2>/dev/null | grep -E "^# (Created|Last|Entries):" || true)
        local cache_created=$(echo "$cache_header" | grep "Created:" | cut -d':' -f2- | xargs)
        local cache_modified=$(echo "$cache_header" | grep "Last modified:" | cut -d':' -f2- | xargs)
        local cache_entries=$(echo "$cache_header" | grep "Entries:" | awk '{print $3}')
        printf "\r\033[K"
        
        if [[ -n "$cache_entries" && $cache_entries -gt 0 ]]; then
            echo -e "  ${GREEN}â†» Smart cache ready: ${BOLD}$cache_entries${NC}${GREEN} cached comparisons available${NC}"
            [[ -n "$cache_created" ]] && echo -e "  ${GRAY}    â”œâ”€ Cache created: $cache_created${NC}"
            [[ -n "$cache_modified" ]] && echo -e "  ${GRAY}    â””â”€ Last updated: $cache_modified${NC}"
        else
            echo -e "  ${CYAN}  âœ“ Fresh cache initialized (no previous comparisons)${NC}"
        fi
        
        # Show cache statistics if available
        local cache_stats=$(get_comparison_cache_stats "gif" 2>/dev/null || echo "")
        if [[ -n "$cache_stats" ]]; then
            echo -e "  ${BLUE}ðŸ“Š Cache Health:${NC}"
            echo "$cache_stats" | while IFS= read -r stat_line; do
                [[ -n "$stat_line" ]] && echo -e "  ${GRAY}    $stat_line${NC}"
            done
        fi
    else
        printf "\r\033[K"
        echo -e "  ${YELLOW}  âš  Smart cache initialization failed - continuing without cache${NC}"
    fi
    echo ""
    
    # SANITY CHECK: Verify checksums detect duplicates
    echo -e "  ${CYAN}ðŸ” Sanity check: Validating checksum uniqueness...${NC}"
    # Silence harmless "uniq: Broken pipe" warnings when head closes the pipe early
    local duplicate_checksums=$(cut -d'|' -f2 "$results_file" | grep -v -E '^(ERROR|UNREADABLE|TIMEOUT|EMPTY|AI_)' | sort | uniq -d 2>/dev/null | wc -l)
    if [[ $duplicate_checksums -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ Found $duplicate_checksums duplicate checksum(s) - detection working!${NC}"
        # Show sample duplicates
        local sample_dup=$(cut -d'|' -f2 "$results_file" | grep -v -E '^(ERROR|UNREADABLE|TIMEOUT|EMPTY|AI_)' | sort | uniq -d 2>/dev/null | head -1)
        if [[ -n "$sample_dup" ]]; then
            echo -e "  ${GRAY}  Sample: Files with checksum ${sample_dup:0:16}...${NC}"
            grep "|$sample_dup|" "$results_file" | cut -d'|' -f1 | while read fname; do
                echo -e "  ${GRAY}    - $(basename "$fname")${NC}"
            done | head -3
        fi
    else
        echo -e "  ${YELLOW}âš  No duplicate checksums found in Stage 1${NC}"
        echo -e "  ${GRAY}  This could mean:${NC}"
        echo -e "  ${GRAY}  - All files are truly unique${NC}"
        echo -e "  ${GRAY}  - OR cache has stale/mixed hash algorithms${NC}"
    fi
    
    echo -e "  ${BLUE}${BOLD}ðŸ” Stage 2: Multi-level duplicate detection...${NC}"
    echo -e "  ${CYAN}Running 6-layer analysis system:${NC}"
    echo -e "    ${GRAY}â”œâ”€ Level 1: Exact Binary Match (MD5) ${GREEN}âš¡ FAST${NC}${GRAY}${NC}"
    echo -e "    ${GRAY}â”œâ”€ Level 2: Visual Hash Matching ${GREEN}âš¡ FAST${NC}${GRAY}${NC}"
    echo -e "    ${GRAY}â”œâ”€ Level 3: Content Fingerprint ${GREEN}âš¡ FAST${NC}${GRAY}${NC}"
    echo -e "    ${GRAY}â”œâ”€ Level 4: Near-Identical Detection ${GREEN}âš¡ FAST${NC}${GRAY}${NC}"
    echo -e "    ${GRAY}â”œâ”€ Level 5: Filename Similarity ${GREEN}âš¡ FAST${NC}${GRAY}${NC}"
    echo -e "    ${GRAY}â””â”€ Level 6: AI Frame-by-Frame Analysis ${MAGENTA}(AI selective - < 0.1% of pairs)${NC}"
    
    # Calculate total comparisons for progress tracking
    local total_comparisons=$(( (total_gifs * (total_gifs - 1)) / 2 ))
    local current_comparison=0
    
    if [[ $total_comparisons -gt 0 ]]; then
        echo -e "  ${CYAN}ðŸ“Š Pairwise comparisons: ${BOLD}$total_comparisons${NC}${CYAN} pairs${NC}"
        echo -e "  ${GREEN}âš¡ Levels 1-5: All pairs (instant - uses cached data)${NC}"
        echo -e "  ${MAGENTA}ðŸ§  Level 6: AI will select < 0.1% (~${BOLD}$((total_comparisons / 1000))${NC}${MAGENTA} max) for deep analysis${NC}"
        echo ""
    fi
    
    # Initialize level counters for final summary
    local level1_checked=0 level2_checked=0 level3_checked=0 level4_checked=0 level5_checked=0 level6_checked=0
    local level6_cached=0
    
    # ðŸš€ SMART DELTA DETECTION: Track new/modified files for incremental analysis
    local file_tracking_db="$LOG_DIR/.file_tracking.db"
    local current_run_timestamp=$(date +%s)
    declare -A old_files  # Files from previous run
    declare -A new_files  # New or modified files
    declare -A file_is_new  # Quick lookup: is this file new?
    
    local new_file_count=0
    local old_file_count=0
    local modified_file_count=0
    local delta_mode_enabled=false
    
    # Load previous file tracking data
    if [[ -f "$file_tracking_db" ]]; then
        while IFS='|' read -r tracked_file file_mtime file_size; do
            [[ -z "$tracked_file" || "$tracked_file" =~ ^# ]] && continue
            old_files["$tracked_file"]="$file_mtime:$file_size"
        done < "$file_tracking_db"
        
        if [[ ${#old_files[@]} -gt 0 ]]; then
            delta_mode_enabled=true
            echo -e "  ${CYAN}ðŸ“¡ Delta detection: Found ${BOLD}${#old_files[@]}${NC}${CYAN} tracked files from previous run${NC}"
        fi
    fi
    
    # Identify new/modified files
    local gif_files=("${!gif_checksums[@]}")
    for gif_file in "${gif_files[@]}"; do
        local file_mtime=$(stat -c%Y -- "$gif_file" 2>/dev/null || echo "0")
        local file_size="${gif_sizes[$gif_file]}"
        local file_fingerprint="${file_mtime}:${file_size}"
        
        if [[ -n "${old_files[$gif_file]}" ]]; then
            # File was tracked before
            if [[ "${old_files[$gif_file]}" != "$file_fingerprint" ]]; then
                # File was modified (mtime or size changed)
                new_files["$gif_file"]=1
                file_is_new["$gif_file"]=1
                ((modified_file_count++))
            else
                # File unchanged
                ((old_file_count++))
            fi
        else
            # New file (not in previous tracking)
            new_files["$gif_file"]=1
            file_is_new["$gif_file"]=1
            ((new_file_count++))
        fi
    done
    
    # Calculate optimized comparison count
    local total_comparisons=$(( (total_gifs * (total_gifs - 1)) / 2 ))
    local optimized_comparisons=$total_comparisons
    local skipped_comparisons=0
    
    # âš ï¸ LEVEL 6 USER PROMPT: Ask upfront before starting comparisons
    if [[ -z "${LEVEL6_USER_CONFIRMED:-}" ]]; then
        echo ""
        echo -e "${YELLOW}${BOLD}âš ï¸  LEVEL 6 DEEP FRAME ANALYSIS OPTION${NC}"
        echo ""
        echo -e "${CYAN}ðŸ“Š What is Level 6?${NC}"
        echo -e "  Level 6 performs ${BOLD}deep frame-by-frame comparison${NC} on suspicious GIF pairs."
        echo -e "  The AI will decide which pairs need this analysis (typically < 0.1% of pairs)."
        echo -e "  It extracts and compares actual pixel data to detect visually identical"
        echo -e "  duplicates that hash-based methods (Levels 1-5) might miss."
        echo ""
        echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
        echo -e "  â€¢ If AI triggers Level 6: Adds ~1-2 seconds per pair analyzed"
        echo -e "  â€¢ Your collection: ${BOLD}$total_gifs files${NC} (~$((total_comparisons / 1000)) max Level 6 comparisons)"
        echo -e "  â€¢ Most collections: ${GREEN}Level 6 rarely triggers${NC} (AI is very selective)"
        echo ""
        echo -e "${CYAN}ðŸŽ¯ When to enable Level 6:${NC}"
        echo -e "  ${GREEN}âœ“${NC} You suspect visual duplicates with different file sizes"
        echo -e "  ${GREEN}âœ“${NC} You want the most thorough duplicate detection possible"
        echo -e "  ${GREEN}âœ“${NC} You have time and want maximum accuracy"
        echo ""
        echo -e "${CYAN}âš¡ When to disable Level 6:${NC}"
        echo -e "  ${YELLOW}â†’${NC} You're in a hurry (Levels 1-5 find most duplicates)"
        echo -e "  ${YELLOW}â†’${NC} You trust the fast hash-based detection"
        echo -e "  ${YELLOW}â†’${NC} Your collection is very large and time is critical"
        echo ""
        echo -e "${GRAY}ðŸ’¡ Note: Selecting 'No' will still run Levels 1-5 (fast hash-based detection)${NC}"
        echo -e "${GRAY}   Only the slow Level 6 frame analysis will be skipped.${NC}"
        echo ""
        echo -ne "${BOLD}Enable Level 6 deep analysis? [y/N]: ${NC}"
        read -r level6_response
        
        if [[ "$level6_response" =~ ^[Yy]$ ]]; then
            LEVEL6_USER_CONFIRMED="yes"
            echo -e "${GREEN}âœ“ Level 6 enabled - AI will use it when needed${NC}"
        else
            LEVEL6_USER_CONFIRMED="no"
            echo -e "${YELLOW}âŠ˜ Level 6 disabled - continuing with fast Levels 1-5${NC}"
        fi
        echo ""
    fi
    
    if [[ $delta_mode_enabled == true && ${#new_files[@]} -gt 0 ]]; then
        # In delta mode: only compare NEWÃ—NEW and NEWÃ—OLD
        local new_count=${#new_files[@]}
        local old_count=$old_file_count
        
        # NEWÃ—NEW comparisons: new_count * (new_count - 1) / 2
        # NEWÃ—OLD comparisons: new_count * old_count
        optimized_comparisons=$(( (new_count * (new_count - 1)) / 2 + (new_count * old_count) ))
        skipped_comparisons=$((total_comparisons - optimized_comparisons))
        
        echo -e "  ${GREEN}âš¡ Smart delta mode active!${NC}"
        echo -e "    ${YELLOW}ðŸ†• New files: ${BOLD}$new_file_count${NC}"
        if [[ $modified_file_count -gt 0 ]]; then
            echo -e "    ${YELLOW}âœï¸  Modified files: ${BOLD}$modified_file_count${NC}"
        fi
        echo -e "    ${GREEN}âœ“ Unchanged files: ${BOLD}$old_file_count${NC}"
        echo -e "    ${CYAN}ðŸš€ Optimized comparisons: ${BOLD}$optimized_comparisons${NC}${CYAN} (was $total_comparisons)${NC}"
        echo -e "    ${MAGENTA}â© Skipping: ${BOLD}$skipped_comparisons${NC}${MAGENTA} fully cached pairs${NC}"
        echo ""
    elif [[ $delta_mode_enabled == true && ${#new_files[@]} -eq 0 ]]; then
        echo -e "  ${GREEN}âœ“ No new or modified files detected - skipping duplicate detection!${NC}"
        echo -e "    ${GRAY}ðŸ“ All $total_gifs files are unchanged since last run${NC}"
        
        # Skip duplicate detection entirely and jump to cleanup
        # Save tracking data and exit early
        : > "$file_tracking_db"
        echo "# File Tracking Database - Updated: $(date)" >> "$file_tracking_db"
        echo "# Format: filename|mtime|size" >> "$file_tracking_db"
        for gif_file in "${gif_files[@]}"; do
            local file_mtime=$(stat -c%Y -- "$gif_file" 2>/dev/null || echo "0")
            local file_size="${gif_sizes[$gif_file]}"
            echo "$gif_file|$file_mtime|$file_size" >> "$file_tracking_db"
        done
        
        # Return early - no duplicates to process
        return 0
    fi
    
    # ðŸ’¾ STAGE 2 PROGRESS PERSISTENCE
    local stage2_progress_file="$LOG_DIR/.stage2_progress"
    local resume_i=0
    local resume_j=0
    
    # Try to restore previous progress
    if [[ -f "$stage2_progress_file" ]]; then
        source "$stage2_progress_file" 2>/dev/null && {
            resume_i=${STAGE2_LAST_I:-0}
            resume_j=${STAGE2_LAST_J:-0}
            if [[ $resume_i -gt 0 || $resume_j -gt 0 ]]; then
                echo -e "  ${GREEN}âœ… Resuming from previous session: pair index [$resume_i,$resume_j]${NC}"
            fi
        }
    fi
    
    # ðŸš€ REVOLUTIONARY CLUSTERING ALGORITHM - REDUCE 247K TO ~5K COMPARISONS!
    # Smart bucketing by size/frames/duration + Bloom filter pre-screening
    echo -e "  ${MAGENTA}${BOLD}ðŸš€ REVOLUTIONARY CLUSTERING OPTIMIZATION${NC}"
    echo -e "  ${CYAN}Grouping similar GIFs into clusters to eliminate 95%+ of comparisons...${NC}"
    
    # Step 1: Create smart clusters based on file characteristics
    declare -A size_clusters    # Key: size_bucket â†’ Value: space-separated file indices
    declare -A frame_clusters   # Key: frame_bucket â†’ Value: space-separated file indices  
    declare -A duration_clusters # Key: duration_bucket â†’ Value: space-separated file indices
    declare -A visual_hash_map  # Key: visual_hash â†’ Value: space-separated file indices
    
    local cluster_start=$(date +%s)
    
    for ((i=0; i<${#gif_files[@]}; i++)); do
        local file="${gif_files[i]}"
        local size="${gif_sizes["$file"]:-0}"
        local frames="${gif_frame_counts["$file"]:-0}"
        local duration="${gif_durations["$file"]:-0}"
        local vhash="${gif_visual_hashes["$file"]:-NONE}"
        
        # Size clustering: Â±25% tolerance buckets (exponential)
        # Files only compared within same or adjacent buckets
        local size_bucket=""
        if [[ $size -lt 100000 ]]; then size_bucket="0-100K"
        elif [[ $size -lt 500000 ]]; then size_bucket="100K-500K"
        elif [[ $size -lt 1000000 ]]; then size_bucket="500K-1M"
        elif [[ $size -lt 5000000 ]]; then size_bucket="1M-5M"
        elif [[ $size -lt 10000000 ]]; then size_bucket="5M-10M"
        else size_bucket="10M+"; fi
        
        size_clusters["$size_bucket"]+="$i "
        
        # Frame count clustering: Â±30% tolerance
        local frame_bucket=""
        if [[ $frames -lt 20 ]]; then frame_bucket="0-20"
        elif [[ $frames -lt 50 ]]; then frame_bucket="20-50"
        elif [[ $frames -lt 100 ]]; then frame_bucket="50-100"
        elif [[ $frames -lt 200 ]]; then frame_bucket="100-200"
        elif [[ $frames -lt 500 ]]; then frame_bucket="200-500"
        else frame_bucket="500+"; fi
        
        frame_clusters["$frame_bucket"]+="$i "
        
        # Duration clustering: Â±35% tolerance
        local dur_bucket=""
        if [[ $duration -lt 2 ]]; then dur_bucket="0-2s"
        elif [[ $duration -lt 5 ]]; then dur_bucket="2-5s"
        elif [[ $duration -lt 10 ]]; then dur_bucket="5-10s"
        elif [[ $duration -lt 30 ]]; then dur_bucket="10-30s"
        else dur_bucket="30s+"; fi
        
        duration_clusters["$dur_bucket"]+="$i "
        
        # Visual hash exact match clustering (instant duplicate detection)
        if [[ "$vhash" != "NONE" && -n "$vhash" ]]; then
            visual_hash_map["$vhash"]+="$i "
        fi
    done
    
    local cluster_time=$(($(date +%s) - cluster_start))
    echo -e "  ${GREEN}âœ“ Clustering complete in ${cluster_time}s${NC}"
    echo -e "    ${CYAN}â”œâ”€ Size buckets: ${BOLD}${#size_clusters[@]}${NC}"
    echo -e "    ${CYAN}â”œâ”€ Frame buckets: ${BOLD}${#frame_clusters[@]}${NC}"
    echo -e "    ${CYAN}â”œâ”€ Duration buckets: ${BOLD}${#duration_clusters[@]}${NC}"
    echo -e "    ${CYAN}â””â”€ Visual hash groups: ${BOLD}${#visual_hash_map[@]}${NC}"
    
    # Step 2: Smart comparison queue - only compare within same clusters
    # MASSIVE REDUCTION: Instead of 247K all-pairs, we only compare clustered candidates
    
    # ðŸš€ PARALLEL COMPARISON FRAMEWORK with file-based data exchange
    # Re-enabled now that EXIT trap removed and using persistent directories
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    # Use 66% of available cores (leave 33% for system + other processes)
    local max_workers=$(( cpu_cores * 2 / 3 ))
    [[ $max_workers -lt 4 ]] && max_workers=4     # Minimum 4 workers
    [[ $max_workers -gt 24 ]] && max_workers=24   # Maximum 24 workers
    
    # Create results directory
    local gif_results_dir="$temp_analysis_dir/gif_stage2_results"
    mkdir -p "$gif_results_dir"
    local gif_duplicates_file="$gif_results_dir/duplicates.txt"
    local gif_progress_file="$gif_results_dir/progress.txt"
    local gif_lock_file="$gif_results_dir/lock"
    echo "0" > "$gif_progress_file"
    : > "$gif_duplicates_file"
    
    # Write all GIF array data to lookup files for workers
    local gif_lookup_dir="$gif_results_dir/lookup"
    mkdir -p "$gif_lookup_dir" || { echo "ERROR: Failed to create $gif_lookup_dir" >&2; return 1; }
    
    echo -e "  ${CYAN}âš¡ Creating GIF lookup tables for parallel workers...${NC}"
    echo -e "  ${YELLOW}DEBUG: GIF Lookup dir: $gif_lookup_dir${NC}"
    
    # Write file list with indices
    local gif_filelist="$gif_lookup_dir/files.txt"
    : > "$gif_filelist"
    for ((i=0; i<total_gifs; i++)); do
        echo "$i|${gif_files[$i]}" >> "$gif_filelist"
    done
    
    # Write checksums lookup
    local gif_checksums_lookup="$gif_lookup_dir/checksums.txt"
    : > "$gif_checksums_lookup"
    for file in "${!gif_checksums[@]}"; do
        echo "$file|${gif_checksums["$file"]}" >> "$gif_checksums_lookup"
    done
    
    # Write visual hashes lookup
    local gif_hashes_lookup="$gif_lookup_dir/visual_hashes.txt"
    : > "$gif_hashes_lookup"
    for file in "${!gif_visual_hashes[@]}"; do
        echo "$file|${gif_visual_hashes["$file"]}" >> "$gif_hashes_lookup"
    done
    
    # Write fingerprints lookup
    local gif_fingerprints_lookup="$gif_lookup_dir/fingerprints.txt"
    : > "$gif_fingerprints_lookup"
    for file in "${!gif_fingerprints[@]}"; do
        echo "$file|${gif_fingerprints["$file"]}" >> "$gif_fingerprints_lookup"
    done
    
    # Write sizes lookup
    local gif_sizes_lookup="$gif_lookup_dir/sizes.txt"
    : > "$gif_sizes_lookup"
    for file in "${!gif_sizes[@]}"; do
        echo "$file|${gif_sizes["$file"]}" >> "$gif_sizes_lookup"
    done
    
    # Write frame counts lookup
    local gif_frames_lookup="$gif_lookup_dir/frame_counts.txt"
    : > "$gif_frames_lookup"
    for file in "${!gif_frame_counts[@]}"; do
        echo "$file|${gif_frame_counts["$file"]}" >> "$gif_frames_lookup"
    done
    
    # Write durations lookup
    local gif_durations_lookup="$gif_lookup_dir/durations.txt"
    : > "$gif_durations_lookup"
    for file in "${!gif_durations[@]}"; do
        echo "$file|${gif_durations["$file"]}" >> "$gif_durations_lookup"
    done
    
    echo -e "  ${GREEN}âœ“ GIF lookup tables ready${NC}"
    
    # ðŸ’¾ Persistent progress tracking using xxhash (dynamic - survives file additions)
    local gif_progress_state_file="$HOME/.smart-gif-converter/gif_comparison_state.txt"
    mkdir -p "$(dirname "$gif_progress_state_file")"
    
    # Load completed pairs (dynamic - uses pair hashes, not collection hash)
    declare -A gif_completed_pairs
    local gif_pairs_resumed=0
    if [[ -f "$gif_progress_state_file" ]]; then
        while IFS= read -r pair_hash; do
            [[ -n "$pair_hash" && "$pair_hash" != "#"* ]] && gif_completed_pairs["$pair_hash"]=1 && ((gif_pairs_resumed++))
        done < "$gif_progress_state_file"
        [[ $gif_pairs_resumed -gt 0 ]] && echo -e "  ${GREEN}â†» Resuming: $gif_pairs_resumed pairs already compared (dynamic cache)${NC}"
    fi
    
    # Note: No collection hash validation - cache is dynamic and survives file additions!
    
    # Generate SMART comparison queue using cluster intersection
    local gif_queue_file="$gif_results_dir/queue.txt"
    local gif_completed_state_file="$gif_results_dir/completed_pairs.txt"
    local estimated_gif_pairs=$(( total_gifs * (total_gifs - 1) / 2 ))
    echo -e "  ${MAGENTA}ðŸ§  Generating optimized comparison queue (smart clustering from ${BOLD}~$estimated_gif_pairs${NC}${MAGENTA} potential pairs)...${NC}"
    : > "$gif_queue_file"
    : > "$gif_completed_state_file"
    
    declare -A queued_pairs  # Track already queued pairs to avoid duplicates
    local pairs_from_visual=0
    local pairs_from_size=0
    local pairs_from_frames=0
    local pairs_from_duration=0
    local gif_pairs_skipped=0
    local gif_pairs_exact_match=0
    local strategies_completed=0
    local total_strategies=3
    
    # Strategy 1: Visual hash clusters (instant exact duplicates)
    printf "  ${CYAN}  \u2514\u2500 Strategy 1/3: Visual hash clustering...${NC}"
    for vhash in "${!visual_hash_map[@]}"; do
        local cluster_members=(${visual_hash_map[$vhash]})
        [[ ${#cluster_members[@]} -lt 2 ]] && continue
        
        # Compare all files with same visual hash
        for ((i=0; i<${#cluster_members[@]}; i++)); do
            local idx1=${cluster_members[i]}
            for ((j=i+1; j<${#cluster_members[@]}; j++)); do
                local idx2=${cluster_members[j]}
                local pair_key="${idx1}-${idx2}"
                
                if [[ -z "${queued_pairs[$pair_key]}" ]]; then
                    local file1="${gif_files[$idx1]}"
                    local file2="${gif_files[$idx2]}"
                    
                    # Apply delta mode filter
                    if [[ $delta_mode_enabled == true && ${#new_files[@]} -gt 0 ]]; then
                        if [[ -z "${file_is_new[$file1]}" && -z "${file_is_new[$file2]}" ]]; then
                            continue
                        fi
                    fi
                    
                    # Create deterministic pair hash using concatenated checksums
                    # OPTIMIZATION: Use checksums directly instead of re-hashing
                    local checksum1="${gif_checksums["$file1"]}"
                    local checksum2="${gif_checksums["$file2"]}"
                    
                    # OPTIMIZATION 1: Skip pairs with identical checksums (exact duplicates already found in Stage 1)
                    if [[ "$checksum1" == "$checksum2" ]]; then
                        ((gif_pairs_exact_match++))
                        continue
                    fi
                    
                    local pair_hash
                    if [[ "$checksum1" < "$checksum2" ]]; then
                        pair_hash="${checksum1}_${checksum2}"
                    else
                        pair_hash="${checksum2}_${checksum1}"
                    fi
                    
                    # Validate pair_hash before using as array subscript
                    [[ -z "$pair_hash" || "$pair_hash" =~ [^a-zA-Z0-9_] ]] && continue
                    
                    # Skip if already completed
                    if [[ -n "${gif_completed_pairs[$pair_hash]:-}" ]]; then
                        ((gif_pairs_skipped++))
                        echo "$pair_hash" >> "$gif_completed_state_file"
                        queued_pairs["$pair_key"]=1
                        continue
                    fi
                    
                    echo "$idx1|$idx2|$pair_hash" >> "$gif_queue_file"
                    queued_pairs["$pair_key"]=1
                    ((pairs_from_visual++))
                fi
            done
        done
    done
    printf "\r\033[K"
    echo -e "  ${GREEN}  âœ“ Strategy 1: Found $pairs_from_visual candidate pairs from visual hashes${NC}"
    
    # Strategy 2: Size cluster intersection with frame/duration validation
    printf "  ${CYAN}  â””â”€ Strategy 2/3: Size-based clustering...${NC}"
    for size_bucket in "${!size_clusters[@]}"; do
        local size_members=(${size_clusters[$size_bucket]})
        [[ ${#size_members[@]} -lt 2 ]] && continue
        
        for ((i=0; i<${#size_members[@]}; i++)); do
            local idx1=${size_members[i]}
            local file1="${gif_files[$idx1]}"
            local frames1="${gif_frame_counts["$file1"]:-0}"
            local dur1="${gif_durations["$file1"]:-0}"
            
            for ((j=i+1; j<${#size_members[@]}; j++)); do
                local idx2=${size_members[j]}
                local file2="${gif_files[$idx2]}"
                local pair_key="${idx1}-${idx2}"
                
                [[ -n "${queued_pairs[$pair_key]}" ]] && continue
                
                # Validate frame/duration similarity before queuing
                local frames2="${gif_frame_counts["$file2"]:-0}"
                local dur2="${gif_durations["$file2"]:-0}"
                
                local frame_ok=true
                if [[ $frames1 -gt 0 && $frames2 -gt 0 ]]; then
                    local frame_diff_pct=$(( (frames1 > frames2 ? frames1 - frames2 : frames2 - frames1) * 100 / (frames1 > frames2 ? frames1 : frames2) ))
                    [[ $frame_diff_pct -gt 50 ]] && frame_ok=false
                fi
                
                local dur_ok=true
                if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    local dur_diff_pct=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                    [[ $dur_diff_pct -gt 40 ]] && dur_ok=false
                fi
                
                if [[ "$frame_ok" == true && "$dur_ok" == true ]]; then
                    # Apply delta mode filter
                    if [[ $delta_mode_enabled == true && ${#new_files[@]} -gt 0 ]]; then
                        if [[ -z "${file_is_new[$file1]}" && -z "${file_is_new[$file2]}" ]]; then
                            continue
                        fi
                    fi
                    
                    # Create deterministic pair hash using concatenated checksums
                    # OPTIMIZATION: Use checksums directly instead of re-hashing
                    local checksum1="${gif_checksums["$file1"]}"
                    local checksum2="${gif_checksums["$file2"]}"
                    
                    # OPTIMIZATION 1: Skip pairs with identical checksums
                    if [[ "$checksum1" == "$checksum2" ]]; then
                        ((gif_pairs_exact_match++))
                        continue
                    fi
                    
                    local pair_hash
                    if [[ "$checksum1" < "$checksum2" ]]; then
                        pair_hash="${checksum1}_${checksum2}"
                    else
                        pair_hash="${checksum2}_${checksum1}"
                    fi
                    
                    # Validate pair_hash before using as array subscript
                    [[ -z "$pair_hash" || "$pair_hash" =~ [^a-zA-Z0-9_] ]] && continue
                    
                    # Skip if already completed
                    if [[ -n "${gif_completed_pairs[$pair_hash]:-}" ]]; then
                        ((gif_pairs_skipped++))
                        echo "$pair_hash" >> "$gif_completed_state_file"
                        queued_pairs["$pair_key"]=1
                        continue
                    fi
                    
                    echo "$idx1|$idx2|$pair_hash" >> "$gif_queue_file"
                    queued_pairs["$pair_key"]=1
                    ((pairs_from_size++))
                fi
            done
        done
    done
    printf "\r\033[K"
    echo -e "  ${GREEN}  âœ“ Strategy 2: Found $pairs_from_size candidate pairs from size clusters${NC}"
    
    # Strategy 3: Frame cluster candidates (for files in same frame range)
    printf "  ${CYAN}  â””â”€ Strategy 3/3: Frame-based clustering...${NC}"
    for frame_bucket in "${!frame_clusters[@]}"; do
        local frame_members=(${frame_clusters[$frame_bucket]})
        [[ ${#frame_members[@]} -lt 2 ]] && continue
        [[ ${#frame_members[@]} -gt 100 ]] && continue  # Skip huge clusters to prevent explosion
        
        for ((i=0; i<${#frame_members[@]}; i++)); do
            local idx1=${frame_members[i]}
            local file1="${gif_files[$idx1]}"
            local size1="${gif_sizes["$file1"]:-0}"
            
            for ((j=i+1; j<${#frame_members[@]}; j++)); do
                local idx2=${frame_members[j]}
                local file2="${gif_files[$idx2]}"
                local pair_key="${idx1}-${idx2}"
                
                [[ -n "${queued_pairs[$pair_key]}" ]] && continue
                
                # Size similarity check
                local size2="${gif_sizes["$file2"]:-0}"
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    [[ $size_diff_pct -gt 60 ]] && continue
                fi
                
                # Apply delta mode filter
                if [[ $delta_mode_enabled == true && ${#new_files[@]} -gt 0 ]]; then
                    if [[ -z "${file_is_new[$file1]}" && -z "${file_is_new[$file2]}" ]]; then
                        continue
                    fi
                fi
                
                # Create deterministic pair hash using concatenated checksums
                # OPTIMIZATION: Use checksums directly instead of re-hashing
                local checksum1="${gif_checksums["$file1"]}"
                local checksum2="${gif_checksums["$file2"]}"
                
                # OPTIMIZATION 1: Skip pairs with identical checksums
                if [[ "$checksum1" == "$checksum2" ]]; then
                    ((gif_pairs_exact_match++))
                    continue
                fi
                
                local pair_hash
                if [[ "$checksum1" < "$checksum2" ]]; then
                    pair_hash="${checksum1}_${checksum2}"
                else
                    pair_hash="${checksum2}_${checksum1}"
                fi
                
                # Validate pair_hash before using as array subscript
                [[ -z "$pair_hash" || "$pair_hash" =~ [^a-zA-Z0-9_] ]] && continue
                
                # Skip if already completed
                if [[ -n "${gif_completed_pairs[$pair_hash]:-}" ]]; then
                    ((gif_pairs_skipped++))
                    echo "$pair_hash" >> "$gif_completed_state_file"
                    queued_pairs["$pair_key"]=1
                    continue
                fi
                
                echo "$idx1|$idx2|$pair_hash" >> "$gif_queue_file"
                queued_pairs["$pair_key"]=1
                ((pairs_from_frames++))
            done
        done
    done
    printf "\r\033[K"
    echo -e "  ${GREEN}  âœ“ Strategy 3: Found $pairs_from_frames candidate pairs from frame clusters${NC}"
    
    local gif_total_queued=$(wc -l < "$gif_queue_file")
    local original_pairs=$(( (total_gifs * (total_gifs - 1)) / 2 ))
    
    # Safety check: If no comparisons needed, skip worker phase
    if [[ $gif_total_queued -eq 0 ]]; then
        echo -e "  ${GREEN}${BOLD}âœ“ CLUSTERING PERFECTION!${NC}"
        echo -e "    ${CYAN}Original all-pairs: ${BOLD}$original_pairs${NC}${CYAN} potential comparisons${NC}"
        echo -e "    ${GREEN}${BOLD}âœ¨ ZERO comparisons needed - all GIFs are unique by metadata!${NC}"
        echo -e "    ${GRAY}Smart clustering eliminated 100% of comparisons${NC}"
        
        # Update file tracking and exit early
        : > "$file_tracking_db"
        echo "# File Tracking Database - Updated: $(date)" >> "$file_tracking_db"
        echo "# Format: filename|mtime|size" >> "$file_tracking_db"
        for gif_file in "${gif_files[@]}"; do
            local file_mtime=$(stat -c%Y -- "$gif_file" 2>/dev/null || echo "0")
            local file_size="${gif_sizes[$gif_file]}"
            echo "$gif_file|$file_mtime|$file_size" >> "$file_tracking_db"
        done
        return 0
    fi
    
    [[ $gif_pairs_skipped -gt 0 ]] && echo -e "  ${GREEN}âœ“ Skipped $gif_pairs_skipped already completed pairs${NC}"
    [[ $gif_pairs_exact_match -gt 0 ]] && echo -e "  ${GREEN}âœ“ Skipped $gif_pairs_exact_match exact checksum matches (Stage 1 duplicates)${NC}"
    echo -e "  ${GREEN}âœ“ Queue ready: $gif_total_queued new comparisons${NC}"
    [[ $gif_total_queued -eq 0 && $gif_pairs_skipped -gt 0 ]] && echo -e "  ${GREEN}âœ“ All comparisons complete!${NC}" && return 0
    
    local reduction_pct=$(( (original_pairs - gif_total_queued - gif_pairs_skipped) * 100 / original_pairs ))
    
    echo -e "  ${GREEN}${BOLD}âœ“ REVOLUTIONARY SPEEDUP ACHIEVED!${NC}"
    echo -e "    ${CYAN}Original all-pairs: ${BOLD}$original_pairs${NC}${CYAN} comparisons${NC}"
    echo -e "    ${MAGENTA}Optimized queue: ${BOLD}$gif_total_queued${NC}${MAGENTA} comparisons${NC}"
    echo -e "    ${GREEN}${BOLD}ðŸ’¥ ELIMINATED: ${reduction_pct}% of comparisons!${NC}"
    echo -e "    ${GRAY}â”œâ”€ From visual hash: $pairs_from_visual pairs${NC}"
    echo -e "    ${GRAY}â”œâ”€ From size clusters: $pairs_from_size pairs${NC}"
    echo -e "    ${GRAY}â””â”€ From frame clusters: $pairs_from_frames pairs${NC}"
    
    # Worker function for parallel GIF comparison
    compare_gif_worker() {
        local worker_id=$1
        local queue=$2
        local results=$3
        local progress=$4
        local lockfile=$5
        local lookup_dir=$6
        local completed_state=$7
        local progress_state=$8
        local smart_cache=$9
        
        # OPTIMIZATION 2: Load ALL lookup data into memory once
        declare -A gif_file_map gif_checksum_map gif_hash_map gif_fingerprint_map gif_size_map gif_frame_map gif_dur_map
        
        while IFS='|' read -r idx filepath; do
            gif_file_map["$idx"]="$filepath"
        done < "$lookup_dir/files.txt"
        
        while IFS='|' read -r filepath checksum; do
            gif_checksum_map["$filepath"]="$checksum"
        done < "$lookup_dir/checksums.txt"
        
        while IFS='|' read -r filepath hash; do
            gif_hash_map["$filepath"]="$hash"
        done < "$lookup_dir/visual_hashes.txt"
        
        while IFS='|' read -r filepath fp; do
            gif_fingerprint_map["$filepath"]="$fp"
        done < "$lookup_dir/fingerprints.txt"
        
        while IFS='|' read -r filepath size; do
            gif_size_map["$filepath"]="$size"
        done < "$lookup_dir/sizes.txt"
        
        while IFS='|' read -r filepath frames; do
            gif_frame_map["$filepath"]="$frames"
        done < "$lookup_dir/frame_counts.txt"
        
        while IFS='|' read -r filepath dur; do
            gif_dur_map["$filepath"]="$dur"
        done < "$lookup_dir/durations.txt"
        
        # OPTIMIZATION 3: Batch results
        local gif_batch_results=()
        local gif_batch_completed=()
        local gif_batch_progress_state=()
        local gif_batch_count=0
        local gif_batch_size=100
        
        while true; do
            # Atomic queue pop - use exec to avoid subshell
            local pair
            exec 200>"$lockfile"
            flock -x 200
            pair=$(head -n 1 "$queue" 2>/dev/null)
            if [[ -n "$pair" ]]; then
                sed -i '1d' "$queue"
            fi
            flock -u 200
            exec 200>&-
            
            [[ -z "$pair" ]] && break
            
            local start_time=$(date +%s%3N)  # Millisecond precision
            local cache_result="NOT_DUPLICATE"
            
            local i=$(echo "$pair" | cut -d'|' -f1)
            local j=$(echo "$pair" | cut -d'|' -f2)
            local pair_hash=$(echo "$pair" | cut -d'|' -f3)
            
            # OPTIMIZATION 2: Get files from in-memory map
            local file1="${gif_file_map[$i]}"
            local file2="${gif_file_map[$j]}"
            
            [[ -z "$file1" || -z "$file2" ]] && continue
            
            # OPTIMIZATION 2: Get file properties from in-memory maps
            local size1="${gif_size_map[$file1]:-0}"
            local size2="${gif_size_map[$file2]:-0}"
            local frame1="${gif_frame_map[$file1]:-0}"
            local frame2="${gif_frame_map[$file2]:-0}"
            local dur1="${gif_dur_map[$file1]:-0}"
            local dur2="${gif_dur_map[$file2]:-0}"
            
            # PRE-FILTER 1: Size difference > 80% = definitely not duplicates
            if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                if [[ $size_diff_pct -gt 80 ]]; then
                    # Update progress and skip
                    exec 200>"$lockfile"
                    flock -x 200
                    local current=$(cat "$progress")
                    echo $((current + 1)) > "$progress"
                    echo "$pair_hash" >> "$completed_state"
                    echo "$pair_hash" >> "$progress_state"
                    flock -u 200
                    exec 200>&-
                    continue
                fi
            fi
            
            # PRE-FILTER 2: Frame count difference > 50% = definitely not duplicates
            if [[ $frame1 -gt 0 && $frame2 -gt 0 ]]; then
                local frame_diff_pct=$(( (frame1 > frame2 ? frame1 - frame2 : frame2 - frame1) * 100 / (frame1 > frame2 ? frame1 : frame2) ))
                if [[ $frame_diff_pct -gt 50 ]]; then
                    # Update progress and skip
                    exec 200>"$lockfile"
                    flock -x 200
                    local current=$(cat "$progress")
                    echo $((current + 1)) > "$progress"
                    echo "$pair_hash" >> "$completed_state"
                    echo "$pair_hash" >> "$progress_state"
                    flock -u 200
                    exec 200>&-
                    continue
                fi
            fi
            
            # PRE-FILTER 3: Duration difference > 40% = definitely not duplicates  
            if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                local dur_diff_pct=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                if [[ $dur_diff_pct -gt 40 ]]; then
                    # Update progress and skip
                    exec 200>"$lockfile"
                    flock -x 200
                    local current=$(cat "$progress")
                    echo $((current + 1)) > "$progress"
                    echo "$pair_hash" >> "$completed_state"
                    echo "$pair_hash" >> "$progress_state"
                    flock -u 200
                    exec 200>&-
                    continue
                fi
            fi
            
            # Passed pre-filters - perform detailed comparison (Levels 1-3)
            # OPTIMIZATION 2: Get checksums from in-memory map
            local checksum1="${gif_checksum_map[$file1]}"
            local checksum2="${gif_checksum_map[$file2]}"
            local duplicate_found=""
            
            # Level 1: Checksum match
            if [[ -n "$checksum1" && -n "$checksum2" && "$checksum1" == "$checksum2" ]]; then
                duplicate_found="LEVEL1|100|$file1|$file2|Exact binary match"
                cache_result="DUPLICATE_LEVEL1"
            fi
            
            # Level 2: Visual hash (OPTIMIZATION 2: in-memory lookup)
            if [[ -z "$duplicate_found" ]]; then
                local hash1="${gif_hash_map[$file1]}"
                local hash2="${gif_hash_map[$file2]}"
                if [[ -n "$hash1" && -n "$hash2" && "$hash1" == "$hash2" ]]; then
                    duplicate_found="LEVEL2|95|$file1|$file2|Identical visual fingerprint"
                    cache_result="DUPLICATE_LEVEL2"
                fi
            fi
            
            # Level 3: Content fingerprint (OPTIMIZATION 2: in-memory lookup)
            if [[ -z "$duplicate_found" ]]; then
                local fp1="${gif_fingerprint_map[$file1]}"
                local fp2="${gif_fingerprint_map[$file2]}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                    if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                        local size_ratio=$(( (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                        if [[ $size_ratio -ge 95 ]]; then
                            duplicate_found="LEVEL3|90|$file1|$file2|Identical metadata"
                            cache_result="DUPLICATE_LEVEL3"
                        fi
                    fi
                fi
            fi
            
            # Calculate duration
            local end_time=$(date +%s%3N)
            local duration_ms=$((end_time - start_time))
            
            # OPTIMIZATION 3: Batch results in memory
            [[ -n "$duplicate_found" ]] && gif_batch_results+=("$duplicate_found")
            gif_batch_completed+=("$pair_hash")
            gif_batch_progress_state+=("$pair_hash")
            ((gif_batch_count++))
            
            # Update progress immediately for live progress bar (lightweight)
            exec 200>"$lockfile"
            flock -x 200
            local current=$(cat "$progress")
            echo $((current + 1)) > "$progress"
            flock -u 200
            exec 200>&-
            
            # Save to smart cache (still immediate for persistence)
            # BUGFIX: use the shared smart cache file, not the pair_hash, otherwise
            # it creates thousands of small files named "checksum1_checksum2" in the
            # current working directory. The first argument to save_comparison_to_cache
            # must be the cache file path.
            if [[ -n "$smart_cache" && -f "$smart_cache" ]]; then
                save_comparison_to_cache "$smart_cache" "$pair_hash" "$checksum1" "$checksum2" "$cache_result" "$duration_ms" 2>/dev/null || true
            fi
            
            # Flush batch when full
            if [[ $gif_batch_count -ge $gif_batch_size ]]; then
                exec 200>"$lockfile"
                flock -x 200
                for result in "${gif_batch_results[@]}"; do
                    echo "$result" >> "$results"
                done
                for pair in "${gif_batch_completed[@]}"; do
                    echo "$pair" >> "$completed_state"
                done
                for pair in "${gif_batch_progress_state[@]}"; do
                    echo "$pair" >> "$progress_state"
                done
                flock -u 200
                exec 200>&-
                
                gif_batch_results=()
                gif_batch_completed=()
                gif_batch_progress_state=()
                gif_batch_count=0
            fi
        done
        
        # Flush remaining batch at end
        if [[ $gif_batch_count -gt 0 ]]; then
            exec 200>"$lockfile"
            flock -x 200
            for result in "${gif_batch_results[@]}"; do
                echo "$result" >> "$results"
            done
            for pair in "${gif_batch_completed[@]}"; do
                echo "$pair" >> "$completed_state"
            done
            for pair in "${gif_batch_progress_state[@]}"; do
                echo "$pair" >> "$progress_state"
            done
            flock -u 200
            exec 200>&-
        fi
    }
    
    # Export for workers
    export -f compare_gif_worker
    
    # Export smart cache functions if enabled
    if [[ -n "$gif_smart_cache_file" && -f "$gif_smart_cache_file" ]]; then
        export -f init_comparison_cache 2>/dev/null || true
        export -f validate_comparison_cache 2>/dev/null || true
        export -f rebuild_comparison_cache 2>/dev/null || true
        export -f load_comparison_cache 2>/dev/null || true
        export -f save_comparison_to_cache 2>/dev/null || true
        export -f cleanup_comparison_cache 2>/dev/null || true
        export -f get_comparison_cache_stats 2>/dev/null || true
        export -f validate_and_repair_comparison_cache 2>/dev/null || true
    fi
    
    # Launch workers
    echo -e "  ${MAGENTA}ðŸš€ Started $max_workers parallel workers for GIFs...${NC}"
    local gif_worker_pids=()
    for ((w=0; w<max_workers; w++)); do
        compare_gif_worker $w "$gif_queue_file" "$gif_duplicates_file" "$gif_progress_file" "$gif_lock_file" "$gif_lookup_dir" "$gif_completed_state_file" "$gif_progress_state_file" "$gif_smart_cache_file" &
        gif_worker_pids+=($!)
    done
    
    # Monitor progress
    echo -e "  ${CYAN}Comparing GIF pairs with $max_workers parallel workers...${NC}"
    local gif_last_progress=0
    while true; do
        local gif_current_progress=$(cat "$gif_progress_file" 2>/dev/null || echo "0")
        
        # Check workers
        local workers_alive=0
        for pid in "${gif_worker_pids[@]}"; do
            if kill -0 $pid 2>/dev/null; then
                ((workers_alive++))
            fi
        done
        
        [[ $workers_alive -eq 0 ]] && break
        
        # Show progress with worker count
        if [[ $gif_current_progress -ne $gif_last_progress ]]; then
            local progress_pct=0
            if [[ $gif_total_queued -gt 0 ]]; then
                progress_pct=$((gif_current_progress * 100 / gif_total_queued))
            fi
            local filled=$((progress_pct * 30 / 100))
            local empty=$((30 - filled))
            
            printf "\r  ${CYAN}["
            for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
            for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
            printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d)${NC} ${BLUE}Workers: %d${NC}" "${progress_pct:-0}" "${gif_current_progress:-0}" "${gif_total_queued:-0}" "${workers_alive:-0}"
            
            gif_last_progress=$gif_current_progress
        fi
        
        sleep 0.2
    done
    
    printf "\r\033[K"
    
    # Wait for completion
    for pid in "${gif_worker_pids[@]}"; do
        wait $pid 2>/dev/null
    done
    
    # Collect results
    while IFS= read -r duplicate_line; do
        [[ -z "$duplicate_line" ]] && continue
        duplicate_pairs+=("$duplicate_line")
        ((duplicate_count++))
    done < "$gif_duplicates_file"
    
    echo -e "  ${GREEN}âœ“ Parallel GIF comparison complete (Levels 1-3)${NC}"
    
    # ðŸ“Š Display smart cache statistics and trigger cleanup
    if [[ -n "$gif_smart_cache_file" && -f "$gif_smart_cache_file" ]]; then
        echo ""
        echo -e "  ${BLUE}ðŸ’¾ Multi-Layer Smart Cache Final Report:${NC}"
        
        # Get final cache statistics
        local final_cache_stats=$(get_comparison_cache_stats "gif" 2>/dev/null || echo "")
        if [[ -n "$final_cache_stats" ]]; then
            echo "$final_cache_stats" | while IFS= read -r stat_line; do
                [[ -n "$stat_line" ]] && echo -e "    ${CYAN}$stat_line${NC}"
            done
        fi
        
        # Trigger background cleanup and optimization
        echo -e "    ${GRAY}â”œâ”€ Running cache optimization...${NC}"
        cleanup_comparison_cache "gif" 2>/dev/null &
        echo -e "    ${GRAY}â””â”€ Cache optimization running in background${NC}"
        echo ""
    fi
    
    # Clean up temporary files
    rm -rf "$gif_lookup_dir" 2>/dev/null
    
    # SEQUENTIAL FALLBACK - DISABLED (parallel workers now use file-based lookups)
    if false; then
        echo -e "  ${CYAN}Processing queue sequentially (optimized with clustering)...${NC}"
        local seq_progress=0
        while IFS='|' read -r i j; do
            [[ -z "$i" ]] && continue
            ((seq_progress++))
            
            # Progress every 1000 pairs
            if [[ $((seq_progress % 1000)) -eq 0 ]]; then
                local progress_pct=0
                if [[ $gif_total_queued -gt 0 ]]; then
                    progress_pct=$((seq_progress * 100 / gif_total_queued))
                fi
                printf "\r  ${CYAN}[â–ˆ] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d)${NC}" "$progress_pct" "$seq_progress" "$gif_total_queued"
            fi
            
            local file1="${gif_files[$i]}"
            local file2="${gif_files[$j]}"
            
            local checksum1="${gif_checksums["$file1"]}"
            local checksum2="${gif_checksums["$file2"]}"
            
            # Level 1: MD5 match
            if [[ -n "$checksum1" && -n "$checksum2" && "$checksum1" == "$checksum2" ]]; then
                duplicate_pairs+=("LEVEL1|100|$file1|$file2|Exact binary match")
                ((duplicate_count++))
                continue
            fi
            
            # Level 2: Visual hash
            local hash1="${gif_visual_hashes["$file1"]}"
            local hash2="${gif_visual_hashes["$file2"]}"
            if [[ -n "$hash1" && -n "$hash2" && "$hash1" == "$hash2" ]]; then
                duplicate_pairs+=("LEVEL2|95|$file1|$file2|Identical visual fingerprint")
                ((duplicate_count++))
                continue
            fi
            
            # Level 3: Content fingerprint
            local fp1="${gif_fingerprints["$file1"]}"
            local fp2="${gif_fingerprints["$file2"]}"
            if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                local size1="${gif_sizes["$file1"]:-0}"
                local size2="${gif_sizes["$file2"]:-0}"
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_ratio=$(( (size1 < size2 ? size1 * 100 / size2 : size2 * 100 / size1) ))
                    if [[ $size_ratio -ge 95 ]]; then
                        duplicate_pairs+=("LEVEL3|90|$file1|$file2|Identical metadata")
                        ((duplicate_count++))
                    fi
                fi
            fi
        done < "$gif_queue_file"
        printf "\r\033[K"
        echo -e "  ${GREEN}âœ“ Sequential GIF comparison complete (Levels 1-5)${NC}"
        echo -e "  ${CYAN}ðŸ“Š Found ${BOLD}$duplicate_count${NC}${CYAN} duplicates via clustering + hash detection${NC}\\n"
    fi
    
    # Clean up
    rm -rf "$gif_results_dir" 2>/dev/null
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ðŸ›¡ï¸ STAGE 3: BULLETPROOF LEVEL 6 PRE-FILTERING & DEEP ANALYSIS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Check if user wants Level 6 analysis (ask upfront)
    if [[ -z "${LEVEL6_USER_CONFIRMED:-}" ]]; then
        echo ""
        echo -e "${YELLOW}${BOLD}âš ï¸  LEVEL 6 DEEP FRAME ANALYSIS OPTION${NC}"
        echo ""
        echo -e "${CYAN}ðŸ“Š What is Level 6?${NC}"
        echo -e "  Level 6 performs ${BOLD}deep frame-by-frame comparison${NC} on suspicious GIF pairs."
        echo -e "  The AI will intelligently pre-filter and only analyze highly suspicious pairs."
        echo -e "  It extracts and compares actual pixel data to detect visually identical"
        echo -e "  duplicates that hash-based methods (Levels 1-5) might miss."
        echo ""
        echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
        echo -e "  â€¢ With bulletproof pre-filtering: Usually ${GREEN}<1 minute${NC}"
        echo -e "  â€¢ Only highly suspicious pairs get analyzed (~1-5% of total)"
        echo -e "  â€¢ Your collection: ${BOLD}$total_gifs files${NC}"
        echo ""
        echo -e "${CYAN}ðŸŽ¯ When to enable Level 6:${NC}"
        echo -e "  ${GREEN}âœ“${NC} You suspect visual duplicates with different file sizes"
        echo -e "  ${GREEN}âœ“${NC} You want the most thorough duplicate detection possible"
        echo -e "  ${GREEN}âœ“${NC} You have a few minutes for maximum accuracy"
        echo ""
        echo -e "${CYAN}âš¡ When to disable Level 6:${NC}"
        echo -e "  ${YELLOW}â†’${NC} You're in a hurry (Levels 1-5 find most duplicates)"
        echo -e "  ${YELLOW}â†’${NC} You trust the fast hash-based detection"
        echo ""
        echo -e "${GRAY}ðŸ’¡ Note: Bulletproof pre-filtering makes Level 6 much faster than before${NC}"
        echo ""
        echo -ne "${BOLD}Enable Level 6 deep analysis? [y/N]: ${NC}"
        read -r level6_response
        
        if [[ "$level6_response" =~ ^[Yy]$ ]]; then
            LEVEL6_USER_CONFIRMED="yes"
            echo -e "${GREEN}âœ“ Level 6 enabled with bulletproof pre-filtering${NC}"
        else
            LEVEL6_USER_CONFIRMED="no"
            echo -e "${YELLOW}âŠš Level 6 disabled - using fast Levels 1-5 only${NC}"
        fi
        echo ""
    fi
    
    # Only proceed with Level 6 if user confirmed
    if [[ "$LEVEL6_USER_CONFIRMED" == "yes" ]]; then
        echo -e "  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 3: Level 6 Deep Frame Analysis...${NC}"
        echo -e "  ${CYAN}ðŸ§  AI Pre-filtering: Only analyzing likely duplicate candidates...${NC}"
        echo -e "  ${YELLOW}âš ï¸  Press Ctrl+C to cancel at any time${NC}\n"
        
        local total_gifs=${#gif_files[@]}
        local level6_found=0
        
        # Build candidate pairs using bulletproof similarity detection
        echo -e "  ${BLUE}ðŸ” Stage 3a: Building candidate pairs based on similarity indicators...${NC}"
        declare -a gif_candidate_pairs
        local total_possible_pairs=$(( total_gifs * (total_gifs - 1) / 2 ))
        local pairs_evaluated=0
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ðŸ§  100% DYNAMIC AI THRESHOLD - PASS 1: CALCULATE ALL SCORES
        # AI analyzes actual similarity distribution to set intelligent threshold
        # NO PREDEFINED VALUES - completely data-driven!
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        echo -e "  ${CYAN}ðŸ§  AI Pass 1: Analyzing similarity score distribution...${NC}"
        
        # ðŸ’¾ PERSISTENT CACHE: Store similarity scores based on file hashes
        local gif_score_cache="$HOME/.smart-gif-converter/gif_similarity_cache.txt"
        mkdir -p "$(dirname "$gif_score_cache")"
        [[ ! -f "$gif_score_cache" ]] && touch "$gif_score_cache"
        
        # Load existing cache
        declare -A gif_score_cache_map
        if [[ -f "$gif_score_cache" ]]; then
            local cache_hits=0
            while IFS='|' read -r pair_hash score file1 file2; do
                [[ -z "$pair_hash" || "$pair_hash" == "#"* ]] && continue
                gif_score_cache_map["$pair_hash"]="$score|$file1|$file2"
                ((cache_hits++))
            done < "$gif_score_cache"
            [[ $cache_hits -gt 0 ]] && echo -e "  ${GREEN}ðŸ“¦ Loaded $cache_hits cached similarity scores${NC}"
        fi
        
        # ðŸš€ PARALLEL AI PASS 1
        local pass1_workers=$((CPU_CORES))
        [[ $pass1_workers -gt 16 ]] && pass1_workers=16
        [[ $pass1_workers -lt 4 ]] && pass1_workers=4
        
        local gif_pass1_dir="$temp_analysis_dir/gif_pass1_results"
        mkdir -p "$gif_pass1_dir"
        local gif_pass1_scores="$gif_pass1_dir/scores.txt"
        local gif_pass1_progress="$gif_pass1_dir/progress.txt"
        local gif_pass1_lock="$gif_pass1_dir/lock"
        local gif_pass1_cache="$gif_pass1_dir/new_cache.txt"
        echo "0" > "$gif_pass1_progress"
        : > "$gif_pass1_scores"
        : > "$gif_pass1_cache"
        
        # Generate queue
        local gif_pass1_queue="$gif_pass1_dir/queue.txt"
        : > "$gif_pass1_queue"
        for ((i=0; i<total_gifs; i++)); do
            for ((j=i+1; j<total_gifs; j++)); do
                echo "$i|$j" >> "$gif_pass1_queue"
            done
        done
        
        echo -e "  ${MAGENTA}ðŸš€ Starting $pass1_workers parallel workers...${NC}"
        
        # Worker function
        calc_gif_similarity_worker() {
            local worker_id=$1 queue=$2 results=$3 progress=$4 lockfile=$5 new_cache=$6
            
            while true; do
                local pair
                (
                    flock -x 200
                    pair=$(head -n 1 "$queue" 2>/dev/null)
                    [[ -n "$pair" ]] && sed -i '1d' "$queue"
                ) 200>"$lockfile"
                
                [[ -z "$pair" ]] && break
                
                local i=$(echo "$pair" | cut -d'|' -f1)
                local j=$(echo "$pair" | cut -d'|' -f2)
                local file1="${gif_files[$i]}"
                local file2="${gif_files[$j]}"
                
                # Generate cache key
                local hash1="${gif_checksums[$i]:-}"
                local hash2="${gif_checksums[$j]:-}"
                [[ -z "$hash1" ]] && hash1="NOHASH_$(stat -c'%s_%Y' "$file1" 2>/dev/null || echo "0")"
                [[ -z "$hash2" ]] && hash2="NOHASH_$(stat -c'%s_%Y' "$file2" 2>/dev/null || echo "0")"
                
                local pair_hash
                if [[ "$hash1" < "$hash2" ]]; then
                    pair_hash="${hash1}_${hash2}"
                else
                    pair_hash="${hash2}_${hash1}"
                fi
                
                # Check cache
                local cached="${gif_score_cache_map["$pair_hash"]:-}"
                if [[ -n "$cached" ]]; then
                    local score=$(echo "$cached" | cut -d'|' -f1)
                    [[ $score -gt 0 ]] && (
                        flock -x 200
                        echo "$score|$file1|$file2" >> "$results"
                    ) 200>"$lockfile"
                    (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
                    continue
                fi
                
                # Skip already detected
                local checksum1="${gif_checksums[$i]:-}"
                local checksum2="${gif_checksums[$j]:-}"
                if [[ -n "$checksum1" && -n "$checksum2" && "$checksum1" == "$checksum2" ]]; then
                    (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
                    continue
                fi
                
                local vhash1="${gif_visual_hashes[$i]:-}"
                local vhash2="${gif_visual_hashes[$j]:-}"
                if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" && "$vhash1" == "$vhash2" ]]; then
                    (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
                    continue
                fi
                
                # Calculate score (GIF 5-factor logic)
                local similarity_score=0
                
                # Factor 1: Filenames (40 max)
                local name1=$(basename -- "$file1"); name1="${name1%.*}"
                local name2=$(basename -- "$file2"); name2="${name2%.*}"
                [[ "${name1:0:15}" == "${name2:0:15}" ]] && similarity_score=$((similarity_score + 40)) ||
                [[ "${name1:0:10}" == "${name2:0:10}" ]] && similarity_score=$((similarity_score + 30)) ||
                [[ "${name1:0:5}" == "${name2:0:5}" ]] && similarity_score=$((similarity_score + 15))
                
                # Factor 2: File sizes (35 max)
                local size1="${gif_sizes[$i]:-0}"
                local size2="${gif_sizes[$j]:-0}"
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    [[ $size_diff_pct -lt 5 ]] && similarity_score=$((similarity_score + 35)) ||
                    [[ $size_diff_pct -lt 15 ]] && similarity_score=$((similarity_score + 25)) ||
                    [[ $size_diff_pct -lt 30 ]] && similarity_score=$((similarity_score + 15)) ||
                    [[ $size_diff_pct -lt 50 ]] && similarity_score=$((similarity_score + 5))
                fi
                
                # Factor 3: Frame count (50 max)
                local frames1="${gif_frame_counts[$i]:-0}"
                local frames2="${gif_frame_counts[$j]:-0}"
                if [[ $frames1 -gt 0 && $frames2 -gt 0 ]]; then
                    if [[ $frames1 -eq $frames2 ]]; then
                        similarity_score=$((similarity_score + 50))
                    else
                        local frame_diff=$(( (frames1 > frames2 ? frames1 - frames2 : frames2 - frames1) * 100 / (frames1 > frames2 ? frames1 : frames2) ))
                        [[ $frame_diff -lt 10 ]] && similarity_score=$((similarity_score + 40)) ||
                        [[ $frame_diff -lt 25 ]] && similarity_score=$((similarity_score + 20))
                    fi
                fi
                
                # Factor 4: Duration (45 max)
                local dur1="${gif_durations[$i]:-0}"
                local dur2="${gif_durations[$j]:-0}"
                if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    if [[ $dur1 -eq $dur2 ]]; then
                        similarity_score=$((similarity_score + 45))
                    else
                        local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                        [[ $dur_diff -lt 5 ]] && similarity_score=$((similarity_score + 35)) ||
                        [[ $dur_diff -lt 10 ]] && similarity_score=$((similarity_score + 20)) ||
                        [[ $dur_diff -lt 20 ]] && similarity_score=$((similarity_score + 10))
                    fi
                fi
                
                # Factor 5: Content fingerprint (30 max)
                local fp1="${gif_fingerprints[$i]:-}"
                local fp2="${gif_fingerprints[$j]:-}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" != "0" && "$fp2" != "0" ]]; then
                    [[ "$fp1" == "$fp2" ]] && similarity_score=$((similarity_score + 30))
                fi
                
                # Write result + cache
                (
                    flock -x 200
                    [[ $similarity_score -gt 0 ]] && echo "$similarity_score|$file1|$file2" >> "$results"
                    echo "$pair_hash|$similarity_score|$file1|$file2" >> "$new_cache"
                ) 200>"$lockfile"
                
                (flock -x 200; echo $(($(cat "$progress") + 1)) > "$progress") 200>"$lockfile"
            done
        }
        
        export -f calc_gif_similarity_worker
        
        # Launch workers
        local pids=()
        for ((w=0; w<pass1_workers; w++)); do
            calc_gif_similarity_worker $w "$gif_pass1_queue" "$gif_pass1_scores" "$gif_pass1_progress" "$gif_pass1_lock" "$gif_pass1_cache" &
            pids+=($!)
        done
        
        # Monitor
        local last=0
        while true; do
            local curr=$(cat "$gif_pass1_progress" 2>/dev/null || echo "0")
            local alive=0
            for pid in "${pids[@]}"; do
                kill -0 $pid 2>/dev/null && ((alive++))
            done
            [[ $alive -eq 0 ]] && break
            
            if [[ $curr -ne $last ]]; then
                local pct=$((curr * 100 / total_possible_pairs))
                local fill=$((pct * 30 / 100))
                printf "\r  ${CYAN}Analysis: ["
                for ((k=0; k<fill; k++)); do printf "${CYAN}â–ˆ${NC}"; done
                for ((k=fill; k<30; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d/%d) Workers: ${CYAN}%d${GRAY}${NC}" "$pct" "$curr" "$total_possible_pairs" "$alive"
                last=$curr
            fi
            sleep 0.2
        done
        
        for pid in "${pids[@]}"; do wait $pid 2>/dev/null; done
        printf "\r\033[K"
        
        # Collect results
        declare -a all_similarity_scores
        local max_score_seen=0 total_score_sum=0
        while IFS='|' read -r score file1 file2; do
            [[ -z "$score" ]] && continue
            all_similarity_scores+=("$score|$file1|$file2")
            total_score_sum=$((total_score_sum + score))
            [[ $score -gt $max_score_seen ]] && max_score_seen=$score
        done < "$gif_pass1_scores"
        
        # Save cache
        if [[ -f "$gif_pass1_cache" && -s "$gif_pass1_cache" ]]; then
            local new=$(wc -l < "$gif_pass1_cache")
            cat "$gif_pass1_cache" >> "$gif_score_cache"
            echo -e "  ${GREEN}ðŸ’¾ Cached $new new scores${NC}"
            
            local temp="$gif_score_cache.tmp"
            awk -F'|' '!seen[$1]++' "$gif_score_cache" | tail -n 100000 > "$temp" 2>/dev/null
            mv "$temp" "$gif_score_cache" 2>/dev/null || true
        fi
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ðŸ§  100% DYNAMIC AI THRESHOLD - PASS 2: ANALYZE & DECIDE
        # AI analyzes actual score distribution to set intelligent threshold
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if [[ ${#all_similarity_scores[@]} -eq 0 ]]; then
            echo -e "  ${GREEN}${BOLD}âœ¨ No similar pairs found - all GIFs are unique!${NC}"
            trap - INT
            return 0
        fi
        
        echo -e "  ${CYAN}ðŸ§  AI Pass 2: Analyzing score distribution to determine optimal threshold...${NC}"
        
        # Sort scores (descending) to find distribution
        IFS=$'\n' sorted_scores=($(sort -t'|' -k1 -n -r <<<"${all_similarity_scores[*]}"))
        unset IFS
        
        local avg_score=$((total_score_sum / ${#all_similarity_scores[@]}))
        local highest_score=$(echo "${sorted_scores[0]}" | cut -d'|' -f1)
        local median_idx=$((${#sorted_scores[@]} / 2))
        local median_score=$(echo "${sorted_scores[$median_idx]}" | cut -d'|' -f1)
        
        # Find 75th percentile (top 25% of scores)
        local p75_idx=$((${#sorted_scores[@]} / 4))
        local p75_score=$(echo "${sorted_scores[$p75_idx]}" | cut -d'|' -f1)
        
        # Find 90th percentile (top 10% of scores)
        local p90_idx=$((${#sorted_scores[@]} / 10))
        [[ $p90_idx -lt 1 ]] && p90_idx=1
        local p90_score=$(echo "${sorted_scores[$p90_idx]}" | cut -d'|' -f1)
        
        echo -e "    ${GRAY}â”œâ”€ Max score: ${BOLD}$highest_score${NC}"
        echo -e "    ${GRAY}â”œâ”€ 90th percentile: ${BOLD}$p90_score${NC}"
        echo -e "    ${GRAY}â”œâ”€ 75th percentile: ${BOLD}$p75_score${NC}"
        echo -e "    ${GRAY}â”œâ”€ Median: ${BOLD}$median_score${NC}"
        echo -e "    ${GRAY}â””â”€ Average: ${BOLD}$avg_score${NC}"
        
        # ðŸ§  INTELLIGENT THRESHOLD SELECTION
        # Strategy: Target top 1-5% of most similar pairs based on collection size
        local ai_threshold
        local target_candidates
        
        if [[ $total_gifs -ge 500 ]]; then
            # Large collection: Be more selective (top 1%)
            target_candidates=$((${#sorted_scores[@]} / 100))
            [[ $target_candidates -lt 10 ]] && target_candidates=10
            [[ $target_candidates -gt 50 ]] && target_candidates=50
        elif [[ $total_gifs -ge 100 ]]; then
            # Medium collection: Top 2-3%
            target_candidates=$((${#sorted_scores[@]} * 2 / 100))
            [[ $target_candidates -lt 5 ]] && target_candidates=5
            [[ $target_candidates -gt 30 ]] && target_candidates=30
        else
            # Small collection: Top 5%
            target_candidates=$((${#sorted_scores[@]} * 5 / 100))
            [[ $target_candidates -lt 3 ]] && target_candidates=3
            [[ $target_candidates -gt 20 ]] && target_candidates=20
        fi
        
        # Set threshold to the score at target position
        local threshold_idx=$((target_candidates - 1))
        [[ $threshold_idx -lt 0 ]] && threshold_idx=0
        [[ $threshold_idx -ge ${#sorted_scores[@]} ]] && threshold_idx=$((${#sorted_scores[@]} - 1))
        
        ai_threshold=$(echo "${sorted_scores[$threshold_idx]}" | cut -d'|' -f1)
        
        # Safety: ensure threshold is reasonable (not too low)
        local min_threshold=$((avg_score + 20))
        [[ $ai_threshold -lt $min_threshold ]] && ai_threshold=$min_threshold
        [[ $ai_threshold -lt 60 ]] && ai_threshold=60  # Absolute minimum
        
        echo -e "  ${MAGENTA}${BOLD}ðŸ§  AI DECISION:${NC}"
        echo -e "    ${CYAN}Target candidates: ${BOLD}$target_candidates${NC}${CYAN} pairs${NC}"
        echo -e "    ${CYAN}Dynamic threshold: ${BOLD}$ai_threshold${NC}${CYAN}/200 points${NC}"
        echo -e "    ${GREEN}âœ… AI selected threshold based on your actual data distribution!${NC}"
        echo ""
        
        # PASS 3: Apply threshold to select candidates
        echo -e "  ${CYAN}ðŸŽ¯ Pass 3: Selecting top candidates above threshold ${BOLD}$ai_threshold${NC}${CYAN}...${NC}"
        
        declare -a gif_candidate_pairs
        for score_entry in "${sorted_scores[@]}"; do
            local score=$(echo "$score_entry" | cut -d'|' -f1)
            [[ $score -lt $ai_threshold ]] && break
            
            local file1=$(echo "$score_entry" | cut -d'|' -f2)
            local file2=$(echo "$score_entry" | cut -d'|' -f3)
            gif_candidate_pairs+=("$file1|$file2|$score")
        done
        
        echo -e "  ${GREEN}âœ“ Candidate selection complete${NC}"
        echo -e "  ${CYAN}ðŸ“Š Final candidates: ${BOLD}${#gif_candidate_pairs[@]}${NC}${CYAN} pairs out of ${BOLD}$total_possible_pairs${NC}${CYAN} total${NC}"
        
        if [[ ${#gif_candidate_pairs[@]} -gt 0 ]]; then
            local reduction_pct=$(( (total_possible_pairs - ${#gif_candidate_pairs[@]}) * 100 / total_possible_pairs ))
            echo -e "  ${GREEN}âš¡ Efficiency: ${BOLD}${reduction_pct}%${NC}${GREEN} of pairs filtered out (skipping unlikely matches)${NC}"
        fi
        echo ""
        
        # If no candidates, exit early
        if [[ ${#gif_candidate_pairs[@]} -eq 0 ]]; then
            trap - INT
            echo -e "  ${GREEN}${BOLD}âœ¨ No similar pairs detected - all files are unique!${NC}"
            echo -e "  ${BLUE}ðŸš€ Your collection is fully optimized!${NC}"
        else
            echo -e "  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 3b: Deep frame analysis on ${#gif_candidate_pairs[@]} candidate pairs...${NC}\\n"
            
            # Analyze only the candidate pairs
            local pair_count=0
            local progress_initialized=false
            
            for candidate_pair in "${gif_candidate_pairs[@]}"; do
                # Check for interruption
                if [[ "$interrupted" == "true" ]]; then
                    echo -e "\\n\\n  ${YELLOW}â¸ï¸  Level 6 analysis interrupted by user${NC}"
                    INTERRUPT_REQUESTED="true"
                    break
                fi
                
                ((pair_count++))
                local file1="${candidate_pair%%|*}"
                local rest="${candidate_pair#*|}"
                local file2="${rest%%|*}"
                local sim_score="${rest##*|}"
                
                # Calculate progress
                local progress=$((pair_count * 100 / ${#gif_candidate_pairs[@]}))
                local filled=$((progress * 40 / 100))
                local empty=$((40 - filled))
                
                # Get short filenames
                local name1="$(basename -- "$file1" .gif)"
                local name2="$(basename -- "$file2" .gif)"
                [[ ${#name1} -gt 25 ]] && name1="${name1:0:22}..."
                [[ ${#name2} -gt 25 ]] && name2="${name2:0:22}..."
                
                # Progress bar - only clear on updates (not first iteration)
                if [[ "$progress_initialized" == "true" ]]; then
                    printf "\\r\\033[K\\n\\033[K\\n\\033[K\\r\\033[3A"  # Clear 3 lines and reset cursor
                fi
                
                printf "  ${CYAN}["
                for ((k=0; k<filled; k++)); do printf "${MAGENTA}â–ˆ${NC}"; done
                for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${CYAN}] ${BOLD}%3d%%${NC}"
                printf "\\n  ${GRAY}Candidate %d/%d | Sim: ${CYAN}%d${GRAY} | Found: ${YELLOW}%d${GRAY} duplicates${NC}" "$pair_count" "${#gif_candidate_pairs[@]}" "$sim_score" "$level6_found"
                printf "\\n  ${BLUE}Comparing:${NC} %s ${YELLOW}â†”${NC} %s" "$name1" "$name2"
                printf "\\r\\033[2A"  # Move cursor back up to progress bar line
                
                progress_initialized=true
                
                # Check Level 6 cache first
                local cache_key="L6_COMPARE:$name1:$name2"
                local cached_result=""
                if [[ "$AI_CACHE_ENABLED" == "true" && -f "$AI_CACHE_INDEX" ]]; then
                    cached_result=$(grep "^$cache_key|" "$AI_CACHE_INDEX" 2>/dev/null | tail -1 | cut -d'|' -f5)
                fi
                
                local frame_analysis=""
                if [[ -n "$cached_result" ]]; then
                    frame_analysis="$cached_result"
                else
                    # Perform frame-by-frame comparison
                    frame_analysis=$(ai_advanced_frame_comparison "$file1" "$file2" "$temp_analysis_dir" "$AI_LEVEL6_FAST_MODE" 2>/dev/null)
                    
                    # Cache result
                    if [[ "$AI_CACHE_ENABLED" == "true" && -n "$frame_analysis" && "$frame_analysis" != "0:0" ]]; then
                        local timestamp=$(date +%s)
                        echo "$cache_key|0|0|$timestamp|$frame_analysis" >> "$AI_CACHE_INDEX" 2>/dev/null || true
                    fi
                fi
                
                # Process result
                if [[ -n "$frame_analysis" && "$frame_analysis" != "0:0" ]]; then
                    local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                    local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                    
                    # Determine if it's a duplicate
                    if [[ $visual_match -ge 80 && $color_match -ge 85 ]]; then
                        duplicate_pairs+=("LEVEL6|95|$file1|$file2|Frame-by-frame analysis (V:${visual_match}% C:${color_match}%)")
                        ((duplicate_count++))
                        ((level6_found++))
                    fi
                fi
            done
            
            # Clear progress lines and restore trap
            printf "\r\033[K\n\033[K\n\033[K\n"  # Clear 3 lines + move down
            trap - INT
            
            # Check if interrupted
            if [[ "$interrupted" == "true" ]]; then
                INTERRUPT_REQUESTED="true"
            else
                echo -e "  ${GREEN}âœ“ Level 6 analysis complete${NC}"
                echo -e "  ${MAGENTA}Found ${BOLD}$level6_found${NC}${MAGENTA} duplicates via frame analysis${NC}\n"
            fi
        fi
    fi
    
    # OLD SEQUENTIAL CODE - Disabled
    if false; then
    # Advanced duplicate detection with multiple similarity levels
    for ((i=resume_i; i<${#gif_files[@]}; i++)); do
        # Check for interrupt
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\n  ${YELLOW}â¸ï¸  Duplicate detection interrupted by user${NC}"
            return 0
        fi
        
        local file1="${gif_files[i]}"
        
        # Determine starting point for inner loop (resume support)
        local start_j=$((i + 1))
        if [[ $i -eq $resume_i && $resume_j -gt $start_j ]]; then
            start_j=$resume_j
        fi
        
        for ((j=start_j; j<${#gif_files[@]}; j++)); do
            local file2="${gif_files[j]}"
            
            # ðŸš€ DELTA MODE OPTIMIZATION: Skip OLDÃ—OLD pairs (already analyzed)
            if [[ $delta_mode_enabled == true && ${#new_files[@]} -gt 0 ]]; then
                # Both files are old (not new/modified) - skip this pair entirely
                if [[ -z "${file_is_new[$file1]}" && -z "${file_is_new[$file2]}" ]]; then
                    ((skipped_comparisons++))
                    continue  # Skip to next pair
                fi
            fi
            
            ((current_comparison++))
            
            # ðŸ’¾ Save progress every 100 comparisons
            if [[ $((current_comparison % 100)) -eq 0 ]]; then
                echo "STAGE2_LAST_I=$i" > "$stage2_progress_file"
                echo "STAGE2_LAST_J=$j" >> "$stage2_progress_file"
            fi
            
            # Display progress for stage 2
            if [[ $total_comparisons -gt 5 ]]; then  # Only show progress bar if significant work
                local progress=$((current_comparison * 100 / total_comparisons))
                local filled=$((progress * 25 / 100))  # Shorter bar for comparison stage
                local empty=$((25 - filled))
                
                # Show different message based on Level 6 status
                if [[ "${LEVEL6_USER_CONFIRMED:-no}" == "yes" ]]; then
                    # Level 6 enabled - show full analysis label
                    printf "\r  ${CYAN}âš¡ Fast Check (L1-5) [${NC}"
                    for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                    for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                    printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}%s â†” %s${NC}" "$progress" "$(basename -- "${file1:0:12}")..." "$(basename -- "${file2:0:12}")..."
                else
                    # Level 6 disabled - emphasize fast-only mode
                    printf "\r  ${GREEN}âš¡ Fast Hash Check [${NC}"
                    for ((k=0; k<filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
                    for ((k=0; k<empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                    printf "${GREEN}] ${BOLD}%3d%%${NC} ${GRAY}(L1-5 only)${NC}"
                    # Add helpful text below progress bar
                    printf "\n  ${GRAY}ðŸ’¡ Checking $current_comparison of $total_comparisons pairs (instant hash lookups, Level 6 skipped)${NC}"
                    printf "\r\033[1A"  # Move cursor back up to progress bar line
                fi
            fi
            
            local is_duplicate=false
            local similarity_reason=""
            
            # Track total files checked
            ((DUPLICATE_STATS_TOTAL_CHECKED++))
            
            # Level 1: Exact binary match (highest confidence)
            ((level1_checked++))
            if [[ "${gif_checksums["$file1"]}}" == "${gif_checksums["$file2"]}}" ]]; then
                is_duplicate=true
                similarity_reason="exact_binary"
                ((DUPLICATE_STATS_EXACT_BINARY++))
            # Level 2: Visual similarity (high confidence)
            ((level2_checked++))
            elif [[ -n "${gif_visual_hashes["$file1"]}}" && -n "${gif_visual_hashes["$file2"]}}" ]] && \
                 [[ "${gif_visual_hashes["$file1"]}}" == "${gif_visual_hashes["$file2"]}}" ]]; then
                is_duplicate=true
                similarity_reason="visual_identical"
                ((DUPLICATE_STATS_VISUAL_IDENTICAL++))
            # Level 3: Content fingerprint match (medium confidence)
            ((level3_checked++))
            elif [[ "${gif_fingerprints["$file1"]}}" == "${gif_fingerprints["$file2"]}}" ]]; then
                # Additional validation for content fingerprint matches
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                local size_diff=$(( (size1 > size2 ? size1 - size2 : size2 - size1) ))
                local size_ratio=$(( size_diff * 100 / (size1 > size2 ? size1 : size2) ))
                
                # Only consider as duplicate if size difference is small (< 5%)
                if [[ $size_ratio -lt 5 ]]; then
                    is_duplicate=true
                    similarity_reason="content_fingerprint"
                    ((DUPLICATE_STATS_CONTENT_FINGERPRINT++))
                fi
            # Level 4: AI-Enhanced Near-identical Detection (STRICT - visual similarity required)
            ((level4_checked++))
            elif [[ "${gif_frame_counts["$file1"]}}" == "${gif_frame_counts["$file2"]}}" ]] && \
                 [[ "${gif_durations["$file1"]}}" == "${gif_durations["$file2"]}}" ]] && \
                 [[ "${gif_frame_counts["$file1"]}}" != "0" ]] && \
                 [[ "${gif_durations["$file1"]}}" != "0" ]]; then
                
                # Both have actual frame/duration data (not just zeros)
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                local size_diff=$(( (size1 > size2 ? size1 - size2 : size2 - size1) ))
                local size_ratio=$(( size_diff * 100 / (size1 > size2 ? size1 : size2) ))
                
                # CRITICAL: Level 4 now REQUIRES visual similarity - no false positives
                local visual_similar=false
                if [[ -n "${gif_visual_hashes["$file1"]}}" && -n "${gif_visual_hashes["$file2"]}}" ]]; then
                    # Compare perceptual hashes
                    local hash1="${gif_visual_hashes["$file1"]}}"
                    local hash2="${gif_visual_hashes["$file2"]}}"
                    
                    # Exact hash match = visually identical
                    if [[ "$hash1" == "$hash2" ]]; then
                        visual_similar=true
                    elif [[ -n "$hash1" && -n "$hash2" ]]; then
                        # Calculate hamming distance between hashes
                        local hash_diff=$(echo "scale=2; ($hash1 - $hash2) / $hash1 * 100" | bc -l 2>/dev/null | tr -d '-' || echo "100")
                        local hash_diff_int=${hash_diff%.*}  # Convert to integer
                        # Very strict threshold: only < 2% difference
                        if [[ $hash_diff_int -lt 2 ]]; then
                            visual_similar=true
                        fi
                    fi
                fi
                
                # STRICT CRITERIA for Level 4:
                # 1. Visual hashes MUST be available and similar, AND
                # 2. Size difference must be < 10% (tighter than before), AND
                # 3. Frame count and duration must match exactly
                if [[ "$visual_similar" == "true" ]] && [[ $size_ratio -lt 10 ]]; then
                    is_duplicate=true
                    similarity_reason="near_identical"
                    ((DUPLICATE_STATS_NEAR_IDENTICAL++))
                fi
                # NOTE: Without visual similarity, even if size/frames match, NOT flagged as duplicate
            # Level 5: Filename-based similarity for identical properties
            # Catches cases where GIFs have same dimensions/frames but different color tables
            ((level5_checked++))
            elif [[ "${gif_frame_counts["$file1"]}}" == "${gif_frame_counts["$file2"]}}" ]] && \
                 [[ "${gif_durations["$file1"]}}" == "${gif_durations["$file2"]}}" ]] && \
                 [[ "${gif_frame_counts["$file1"]}}" != "0" ]] && \
                 [[ "${gif_durations["$file1"]}}" != "0" ]]; then
                
                # Check if filenames suggest they're from the same source
                local basename1=$(basename -- "$file1" .gif)
                local basename2=$(basename -- "$file2" .gif)
                
                # Calculate filename similarity
                local name_similarity=0
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                local size_diff=$(( (size1 > size2 ? size1 - size2 : size2 - size1) ))
                local size_ratio=$(( size_diff * 100 / (size1 > size2 ? size1 : size2) ))
                
                # Check various filename similarity patterns
                if [[ "${basename1:0:10}" == "${basename2:0:10}" ]] && [[ ${#basename1} -gt 10 ]] && [[ ${#basename2} -gt 10 ]]; then
                    # First 10 characters match - likely same source with different timestamp
                    name_similarity=70
                elif [[ "${basename1:0:5}" == "${basename2:0:5}" ]] && [[ ${#basename1} -gt 5 ]] && [[ ${#basename2} -gt 5 ]]; then
                    # First 5 characters match
                    name_similarity=50
                fi
                
                # If filenames are similar AND properties match AND size difference is reasonable
                if [[ $name_similarity -ge 50 ]] && [[ $size_ratio -lt 15 ]]; then
                    # Additional check: verify resolution matches (from content fingerprint)
                    local fp1="${gif_fingerprints["$file1"]}}"
                    local fp2="${gif_fingerprints["$file2"]}}"
                    local res1=$(echo "$fp1" | cut -d':' -f2)
                    local res2=$(echo "$fp2" | cut -d':' -f2)
                    
                    if [[ "$res1" == "$res2" ]] && [[ -n "$res1" ]] && [[ "$res1" != "0" ]]; then
                        # Same resolution, same frames, same duration, similar filenames
                        is_duplicate=true
                        similarity_reason="filename_property_match"
                        ((DUPLICATE_STATS_NEAR_IDENTICAL++))
                    fi
                fi
            fi
            
            # Level 6: Advanced Frame-by-Frame Color & Structure Matching (AI-powered deep analysis)
            # AI TRAINING MODEL: Intelligently decides when Level 6 should run
            # Factors: Collection size, file similarity, previous results, confidence scores
            
            # âš¡ PERFORMANCE OPTIMIZATION: Early bailout conditions
            # Skip expensive Level 6 AI calculation if:
            # 1. Duplicate already found by Levels 1-5 (99.9% of cases)
            # 2. Collection is massive (237 files = almost never trigger)
            # 3. Files have very different basic properties
            local should_run_level6=false
            local skip_level6_calculation=false
            
            # Quick bailout #1: Already found duplicate
            if [[ "$is_duplicate" == "true" ]]; then
                skip_level6_calculation=true
            fi
            
            # Quick bailout #2: Collection too large (237 files = < 0.1% trigger rate)
            if [[ $total_gifs -ge 200 ]] && [[ "$skip_level6_calculation" != "true" ]]; then
                # For massive collections, skip unless files are VERY suspicious
                local quick_size1="${gif_sizes["$file1"]}}"
                local quick_size2="${gif_sizes["$file2"]}}"
                if [[ -n "$quick_size1" && -n "$quick_size2" ]]; then
                    local quick_diff=$(( (quick_size1 > quick_size2 ? quick_size1 - quick_size2 : quick_size2 - quick_size1) * 100 / (quick_size1 > quick_size2 ? quick_size1 : quick_size2) ))
                    # If size difference > 20%, skip AI calculation entirely
                    if [[ $quick_diff -gt 20 ]]; then
                        skip_level6_calculation=true
                    fi
                fi
            fi
            
            # Only run expensive AI calculation if bailout conditions not met
            if [[ "$skip_level6_calculation" != "true" ]] && \
               [[ "$AI_ENABLED" == "true" ]] && [[ "$AI_VISUAL_SIMILARITY" == "true" ]] && \
               command -v convert >/dev/null 2>&1; then
                
                # ==============================================================
                # ðŸ§  COMPREHENSIVE 10-FACTOR AI DECISION ENGINE
                # Uses: MD5, metadata, file stats, timestamps, visual hashes, and more!
                # ==============================================================
                
                # Factor 1: Collection size (base penalty for large collections)
                local collection_size=$total_gifs
                local size_score=0
                if [[ $collection_size -lt 30 ]]; then
                    size_score=100  # Small collection - run liberally
                elif [[ $collection_size -lt 75 ]]; then
                    size_score=50   # Medium - run selectively
                elif [[ $collection_size -lt 150 ]]; then
                    size_score=15   # Large - extremely rare (< 1% of pairs)
                else
                    size_score=2    # Very large (237 files) - virtually never (< 0.1%)
                fi
                
                # Factor 2: MD5 Hash Proximity Analysis
                local md5_score=0
                local hash1="${gif_checksums["$file1"]}}"
                local hash2="${gif_checksums["$file2"]}}"
                if [[ -n "$hash1" && -n "$hash2" && "$hash1" != "ERROR" && "$hash2" != "ERROR" ]]; then
                    if [[ "${hash1:0:8}" == "${hash2:0:8}" ]]; then
                        ((md5_score += 50))  # Very strong similarity indicator
                    elif [[ "${hash1:0:4}" == "${hash2:0:4}" ]]; then
                        ((md5_score += 25))  # Moderate similarity
                    elif [[ "${hash1:0:2}" == "${hash2:0:2}" ]]; then
                        ((md5_score += 10))  # Weak similarity
                    fi
                fi
                
                # Factor 3: File Metadata & Timestamps
                local metadata_score=0
                local mtime1=$(stat -c%Y -- "$file1" 2>/dev/null || echo "0")
                local mtime2=$(stat -c%Y -- "$file2" 2>/dev/null || echo "0")
                if [[ $mtime1 -gt 0 && $mtime2 -gt 0 ]]; then
                    local time_diff=$((mtime1 > mtime2 ? mtime1 - mtime2 : mtime2 - mtime1))
                    if [[ $time_diff -lt 60 ]]; then
                        ((metadata_score += 40))  # Created within 1 minute
                    elif [[ $time_diff -lt 300 ]]; then
                        ((metadata_score += 20))  # Created within 5 minutes
                    elif [[ $time_diff -lt 3600 ]]; then
                        ((metadata_score += 10))  # Created within 1 hour
                    fi
                fi
                
                # Factor 4: Frame Count & Duration Match
                local frame_duration_score=0
                local frame1="${gif_frame_counts["$file1"]}}"
                local frame2="${gif_frame_counts["$file2"]}}"
                local dur1="${gif_durations["$file1"]}}"
                local dur2="${gif_durations["$file2"]}}"
                if [[ $frame1 -gt 0 && $frame2 -gt 0 && $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    if [[ $frame1 -eq $frame2 && $dur1 -eq $dur2 ]]; then
                        ((frame_duration_score += 45))  # Identical timing
                    else
                        local frame_diff=$(( (frame1 > frame2 ? frame1 - frame2 : frame2 - frame1) * 100 / (frame1 > frame2 ? frame1 : frame2) ))
                        local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                        if [[ $frame_diff -lt 5 && $dur_diff -lt 5 ]]; then
                            ((frame_duration_score += 30))  # Within 5%
                        elif [[ $frame_diff -lt 10 && $dur_diff -lt 10 ]]; then
                            ((frame_duration_score += 15))  # Within 10%
                        fi
                    fi
                fi
                
                # Factor 5: Visual Hash Similarity
                local visual_hash_score=0
                local vhash1="${gif_visual_hashes["$file1"]}}"
                local vhash2="${gif_visual_hashes["$file2"]}}"
                if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" ]]; then
                    if [[ "$vhash1" == "$vhash2" ]]; then
                        ((visual_hash_score += 50))  # Identical visual hash
                    else
                        local hash_diff=$(echo "scale=2; ($vhash1 - $vhash2) / $vhash1 * 100" | bc -l 2>/dev/null | tr -d '-' || echo "100")
                        local hash_diff_int=${hash_diff%.*}
                        if [[ $hash_diff_int -lt 5 ]]; then
                            ((visual_hash_score += 35))  # Very similar
                        elif [[ $hash_diff_int -lt 15 ]]; then
                            ((visual_hash_score += 20))  # Somewhat similar
                        fi
                    fi
                fi
                
                # Factor 6: Content Fingerprint
                local fingerprint_score=0
                local fp1="${gif_fingerprints["$file1"]}}"
                local fp2="${gif_fingerprints["$file2"]}}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                    ((fingerprint_score += 40))  # Identical fingerprint
                fi
                
                # Factor 7: Resolution/Quality
                local quality_score=0
                local res1=$(echo "$fp1" | cut -d':' -f2)
                local res2=$(echo "$fp2" | cut -d':' -f2)
                local width1=$(echo "$res1" | cut -d'x' -f1)
                local height1=$(echo "$res1" | cut -d'x' -f2)
                local width2=$(echo "$res2" | cut -d'x' -f1)
                local height2=$(echo "$res2" | cut -d'x' -f2)
                if [[ -n "$width1" && -n "$width2" && $width1 =~ ^[0-9]+$ && $width2 =~ ^[0-9]+$ ]]; then
                    local pixels1=$((width1 * height1))
                    local pixels2=$((width2 * height2))
                    if [[ $pixels1 -lt 921600 || $pixels2 -lt 921600 ]]; then
                        ((quality_score += 30))  # Low-res
                    fi
                    local res_diff_pct=$(( (pixels1 > pixels2 ? pixels1 - pixels2 : pixels2 - pixels1) * 100 / (pixels1 > pixels2 ? pixels1 : pixels2) ))
                    if [[ $res_diff_pct -lt 5 ]]; then
                        ((quality_score += 25))  # Nearly identical
                    elif [[ $res_diff_pct -lt 15 ]]; then
                        ((quality_score += 15))  # Similar
                    fi
                fi
                
                # Factor 8: Filename & Size Similarity
                local similarity_score=0
                local name1="$(basename "$file1" .gif)"
                local name2="$(basename "$file2" .gif)"
                if [[ "${name1:0:15}" == "${name2:0:15}" ]]; then
                    ((similarity_score += 40))
                elif [[ "${name1:0:8}" == "${name2:0:8}" ]]; then
                    ((similarity_score += 25))
                fi
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                if [[ -n "$size1" && -n "$size2" && $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    if [[ $size_diff_pct -lt 10 ]]; then
                        ((similarity_score += 30))
                    elif [[ $size_diff_pct -lt 20 ]]; then
                        ((similarity_score += 15))
                    fi
                fi
                
                # Factor 9: Previous Layers Failed
                local previous_layers_score=0
                if [[ "$is_duplicate" != "true" ]]; then
                    previous_layers_score=20
                fi
                
                # Factor 10: Location Similarity
                local location_score=0
                local dir1=$(dirname "$file1")
                local dir2=$(dirname "$file2")
                if [[ "$dir1" == "$dir2" ]]; then
                    ((location_score += 15))
                fi
                
                # Manual override
                if [[ "${AI_FRAME_ANALYSIS:-false}" == "true" ]]; then
                    should_run_level6=true
                else
                    # 10-Factor Weighted Scoring
                    local ai_confidence=$(( 
                        (size_score * 10 + 
                         md5_score * 12 + 
                         metadata_score * 10 + 
                         frame_duration_score * 15 + 
                         visual_hash_score * 13 + 
                         fingerprint_score * 12 + 
                         quality_score * 10 + 
                         similarity_score * 10 + 
                         previous_layers_score * 5 + 
                         location_score * 3) / 100 
                    ))
                    
                    # ADAPTIVE THRESHOLD
                    local confidence_threshold=60
                    if [[ $collection_size -ge 200 ]]; then
                        confidence_threshold=98  # 98% for 237 files
                    elif [[ $collection_size -ge 150 ]]; then
                        confidence_threshold=90
                    elif [[ $collection_size -ge 100 ]]; then
                        confidence_threshold=80
                    fi
                    
                    if [[ $ai_confidence -ge $confidence_threshold ]]; then
                        should_run_level6=true
                        if [[ $collection_size -ge 150 ]]; then
                            echo "" >&2
                            echo -e "  ${YELLOW}ðŸ” Level 6 triggered!${NC}" >&2
                            echo -e "    ${GRAY}Files: $(basename "$file1") â†” $(basename "$file2")${NC}" >&2
                            echo -e "    ${GRAY}Confidence: ${BOLD}${ai_confidence}%${NC}${GRAY} >= Threshold: ${BOLD}${confidence_threshold}%${NC}" >&2
                            echo -e "    ${GRAY}Top: md5=$md5_score frame=$frame_duration_score vhash=$visual_hash_score${NC}" >&2
                        fi
                    fi
                    
                    if [[ "$AI_TRAINING_ENABLED" == "true" ]]; then
                        echo "L6|$(basename "$file1")|$(basename "$file2")|size:$size_score|md5:$md5_score|meta:$metadata_score|frame:$frame_duration_score|vhash:$visual_hash_score|fp:$fingerprint_score|qual:$quality_score|sim:$similarity_score|prev:$previous_layers_score|loc:$location_score|conf:$ai_confidence|thresh:$confidence_threshold|decision:$should_run_level6" >> "$AI_TRAINING_DIR/level6_decisions.log" 2>/dev/null
                    fi
                fi
            fi
            
            # OLD COMPLEX CODE DELETED BELOW - IGNORE IT
            if false; then  # Never execute
                # Factor 2: MD5 Hash Proximity Analysis
                # Check if MD5 hashes are "close" (shared prefixes suggest similar content)
                local md5_score=0
                local hash1="${gif_checksums["$file1"]}}"
                local hash2="${gif_checksums["$file2"]}}"
                if [[ -n "$hash1" && -n "$hash2" && "$hash1" != "ERROR" && "$hash2" != "ERROR" ]]; then
                    # Compare first 8 characters of MD5 (collision unlikely but similarity indicator)
                    if [[ "${hash1:0:8}" == "${hash2:0:8}" ]]; then
                        ((md5_score += 50))  # Very strong similarity indicator
                    elif [[ "${hash1:0:4}" == "${hash2:0:4}" ]]; then
                        ((md5_score += 25))  # Moderate similarity
                    elif [[ "${hash1:0:2}" == "${hash2:0:2}" ]]; then
                        ((md5_score += 10))  # Weak similarity
                    fi
                fi
                
                # Factor 3: File Metadata & Timestamps Analysis
                local metadata_score=0
                
                # Get file metadata
                local mtime1=$(stat -c%Y -- "$file1" 2>/dev/null || echo "0")
                local mtime2=$(stat -c%Y -- "$file2" 2>/dev/null || echo "0")
                local ctime1=$(stat -c%Z "$file1" 2>/dev/null || echo "0")
                local ctime2=$(stat -c%Z "$file2" 2>/dev/null || echo "0")
                
                # Files created/modified within 60 seconds = likely related
                if [[ $mtime1 -gt 0 && $mtime2 -gt 0 ]]; then
                    local time_diff=$((mtime1 > mtime2 ? mtime1 - mtime2 : mtime2 - mtime1))
                    if [[ $time_diff -lt 60 ]]; then
                        ((metadata_score += 40))  # Created within 1 minute
                    elif [[ $time_diff -lt 300 ]]; then
                        ((metadata_score += 20))  # Created within 5 minutes
                    elif [[ $time_diff -lt 3600 ]]; then
                        ((metadata_score += 10))  # Created within 1 hour
                    fi
                fi
                
                # Factor 4: Frame Count & Duration Match
                local frame_duration_score=0
                local frame1="${gif_frame_counts["$file1"]}}"
                local frame2="${gif_frame_counts["$file2"]}}"
                local dur1="${gif_durations["$file1"]}}"
                local dur2="${gif_durations["$file2"]}}"
                
                if [[ $frame1 -gt 0 && $frame2 -gt 0 && $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    # Exact match = very suspicious
                    if [[ $frame1 -eq $frame2 && $dur1 -eq $dur2 ]]; then
                        ((frame_duration_score += 45))  # Identical timing = likely duplicate
                    else
                        # Calculate differences
                        local frame_diff=$(( (frame1 > frame2 ? frame1 - frame2 : frame2 - frame1) * 100 / (frame1 > frame2 ? frame1 : frame2) ))
                        local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                        
                        # Very close = suspicious
                        if [[ $frame_diff -lt 5 && $dur_diff -lt 5 ]]; then
                            ((frame_duration_score += 30))  # Within 5%
                        elif [[ $frame_diff -lt 10 && $dur_diff -lt 10 ]]; then
                            ((frame_duration_score += 15))  # Within 10%
                        fi
                    fi
                fi
                
                # Factor 5: Visual Hash Similarity (if available)
                local visual_hash_score=0
                local vhash1="${gif_visual_hashes["$file1"]}}"
                local vhash2="${gif_visual_hashes["$file2"]}}"
                if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" ]]; then
                    if [[ "$vhash1" == "$vhash2" ]]; then
                        ((visual_hash_score += 50))  # Identical visual hash
                    else
                        # Calculate hash distance
                        local hash_diff=$(echo "scale=2; ($vhash1 - $vhash2) / $vhash1 * 100" | bc -l 2>/dev/null | tr -d '-' || echo "100")
                        local hash_diff_int=${hash_diff%.*}
                        if [[ $hash_diff_int -lt 5 ]]; then
                            ((visual_hash_score += 35))  # Very similar
                        elif [[ $hash_diff_int -lt 15 ]]; then
                            ((visual_hash_score += 20))  # Somewhat similar
                        fi
                    fi
                fi
                
                # Factor 6: Content Fingerprint Analysis
                local fingerprint_score=0
                local fp1="${gif_fingerprints["$file1"]}}"
                local fp2="${gif_fingerprints["$file2"]}}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                    ((fingerprint_score += 40))  # Identical fingerprint
                fi
                
                # Factor 7: Resolution/Quality detection (detect low-res/pixelated)
                local quality_score=0
                local fp1="${gif_fingerprints["$file1"]}}"
                local fp2="${gif_fingerprints["$file2"]}}"
                
                # Extract resolution from fingerprint (format: size:resolution:frames:duration)
                local res1=$(echo "$fp1" | cut -d':' -f2)
                local res2=$(echo "$fp2" | cut -d':' -f2)
                
                # Parse resolution (format: WIDTHxHEIGHT)
                local width1=$(echo "$res1" | cut -d'x' -f1)
                local height1=$(echo "$res1" | cut -d'x' -f2)
                local width2=$(echo "$res2" | cut -d'x' -f1)
                local height2=$(echo "$res2" | cut -d'x' -f2)
                
                # Low resolution = likely similar content (easier to match)
                if [[ -n "$width1" && -n "$width2" && $width1 =~ ^[0-9]+$ && $width2 =~ ^[0-9]+$ ]]; then
                    # Calculate pixel count
                    local pixels1=$((width1 * height1))
                    local pixels2=$((width2 * height2))
                    
                    # Low-res files (< 720p) are more likely to be duplicates with different quality
                    if [[ $pixels1 -lt 921600 || $pixels2 -lt 921600 ]]; then  # 921600 = 1280x720
                        ((quality_score += 30))  # Boost - low res files benefit from deep analysis
                    fi
                    
                    # Very similar resolutions
                    local res_diff_pct=$(( (pixels1 > pixels2 ? pixels1 - pixels2 : pixels2 - pixels1) * 100 / (pixels1 > pixels2 ? pixels1 : pixels2) ))
                    if [[ $res_diff_pct -lt 5 ]]; then
                        ((quality_score += 25))  # Nearly identical resolution
                    elif [[ $res_diff_pct -lt 15 ]]; then
                        ((quality_score += 15))  # Similar resolution
                    fi
                fi
                
                # Factor 3: File similarity indicators
                local similarity_score=0
                local name1="$(basename "$file1" .gif)"
                local name2="$(basename "$file2" .gif)"
                
                # Similar filenames suggest possible duplicates
                if [[ "${name1:0:15}" == "${name2:0:15}" ]]; then
                    ((similarity_score += 40))  # First 15 chars match
                elif [[ "${name1:0:8}" == "${name2:0:8}" ]]; then
                    ((similarity_score += 25))  # First 8 chars match
                fi
                
                # Similar file sizes
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                if [[ -n "$size1" && -n "$size2" && $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    if [[ $size_diff_pct -lt 10 ]]; then
                        ((similarity_score += 30))  # Within 10%
                    elif [[ $size_diff_pct -lt 20 ]]; then
                        ((similarity_score += 15))  # Within 20%
                    fi
                fi
                
                # Factor 8: Previous layers found nothing (Level 6 might catch subtle cases)
                local previous_layers_score=0
                if [[ "$is_duplicate" != "true" ]]; then
                    previous_layers_score=20  # Boost - might be hidden duplicate
                fi
                
                # Factor 9: File path/location similarity (same directory = related)
                local location_score=0
                local dir1=$(dirname "$file1")
                local dir2=$(dirname "$file2")
                if [[ "$dir1" == "$dir2" ]]; then
                    ((location_score += 15))  # Same directory
                fi
                
                # Factor 10: Manual override
                if [[ "${AI_FRAME_ANALYSIS:-false}" == "true" ]]; then
                    should_run_level6=true  # User explicitly enabled
                else
                    # ==============================================================
                    # ðŸ§  COMPREHENSIVE AI DECISION ALGORITHM
                    # 10-Factor Weighted Scoring System
                    # ==============================================================
                    # Weights designed to prioritize strongest indicators:
                    # 1. Collection size (10%) - base penalty for large collections
                    # 2. MD5 proximity (12%) - strong technical indicator
                    # 3. Metadata/timestamps (10%) - temporal correlation
                    # 4. Frame/duration match (15%) - critical similarity metric
                    # 5. Visual hash (13%) - perceptual similarity
                    # 6. Fingerprint (12%) - content signature
                    # 7. Resolution/quality (10%) - technical characteristics
                    # 8. Filename/size similarity (10%) - heuristic indicators
                    # 9. Previous layers failed (5%) - investigation flag
                    # 10. Location similarity (3%) - contextual hint
                    # ==============================================================
                    
                    local ai_confidence=$(( 
                        (size_score * 10 + 
                         md5_score * 12 + 
                         metadata_score * 10 + 
                         frame_duration_score * 15 + 
                         visual_hash_score * 13 + 
                         fingerprint_score * 12 + 
                         quality_score * 10 + 
                         similarity_score * 10 + 
                         previous_layers_score * 5 + 
                         location_score * 3) / 100 
                    ))
                    
                    # ADAPTIVE THRESHOLD: EXTREMELY strict for large collections!
                    local confidence_threshold=60  # Default for small collections
                    if [[ $collection_size -ge 200 ]]; then
                        confidence_threshold=98   # EXTREME: 98% for 200+ files (virtually impossible)
                    elif [[ $collection_size -ge 150 ]]; then
                        confidence_threshold=90   # VERY STRICT for 150+ files
                    elif [[ $collection_size -ge 100 ]]; then
                        confidence_threshold=80   # STRICT for 100+ files
                    fi
                    
                    # Decision: Run Level 6 only if confidence exceeds adaptive threshold
                    if [[ $ai_confidence -ge $confidence_threshold ]]; then
                        should_run_level6=true
                        
                        # DEBUG: Log what triggered Level 6 (for large collections only)
                        if [[ $collection_size -ge 150 ]]; then
                            echo "" >&2
                            echo -e "  ${YELLOW}ðŸ” DEBUG: Level 6 triggered!${NC}" >&2
                            echo -e "    ${GRAY}Files: $(basename "$file1") â†” $(basename "$file2")${NC}" >&2
                            echo -e "    ${GRAY}Confidence: ${BOLD}${ai_confidence}%${NC}${GRAY} >= Threshold: ${BOLD}${confidence_threshold}%${NC}" >&2
                            echo -e "    ${GRAY}Top scores: md5=$md5_score frame=$frame_duration_score vhash=$visual_hash_score${NC}" >&2
                        fi
                    fi
                    
                    # Learning: Track AI decisions with ALL 10 factors for future improvement
                    if [[ "$AI_TRAINING_ENABLED" == "true" ]]; then
                        # Comprehensive training log with all decision factors
                        echo "L6_DECISION|$(basename "$file1")|$(basename "$file2")|size:$size_score|md5:$md5_score|meta:$metadata_score|frame:$frame_duration_score|vhash:$visual_hash_score|fp:$fingerprint_score|qual:$quality_score|sim:$similarity_score|prev:$previous_layers_score|loc:$location_score|conf:$ai_confidence|thresh:$confidence_threshold|decision:$should_run_level6" >> "$AI_TRAINING_DIR/level6_decisions.log" 2>/dev/null
                    fi
                fi
            fi
            
            # Execute Level 6 only if AI decided it's worth it
            if [[ "$should_run_level6" == "true" ]]; then
                # Check if user wants to skip Level 6 (only ask once per session)
                if [[ -z "${LEVEL6_USER_CONFIRMED:-}" ]]; then
                    echo ""
                    echo -e "${YELLOW}${BOLD}âš ï¸  LEVEL 6 DEEP FRAME ANALYSIS DETECTED${NC}"
                    echo ""
                    echo -e "${CYAN}ðŸ“Š What is Level 6?${NC}"
                    echo -e "  Level 6 performs ${BOLD}deep frame-by-frame comparison${NC} between GIF pairs."
                    echo -e "  It extracts and compares actual pixel data to detect visually identical"
                    echo -e "  or near-identical duplicates that other methods might miss."
                    echo ""
                    echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
                    echo -e "  â€¢ Small collections (< 30 files): ~1-2 minutes"
                    echo -e "  â€¢ Medium collections (30-100 files): ~5-15 minutes"
                    echo -e "  â€¢ Large collections (100+ files): ~30+ minutes"
                    echo -e "  â€¢ Your collection: ${BOLD}$total_gifs files${NC}"
                    echo ""
                    echo -e "${CYAN}ðŸŽ¯ When to use Level 6:${NC}"
                    echo -e "  ${GREEN}âœ“${NC} You suspect visual duplicates with different file sizes"
                    echo -e "  ${GREEN}âœ“${NC} You want the most thorough duplicate detection possible"
                    echo -e "  ${GREEN}âœ“${NC} You have time and want maximum accuracy"
                    echo ""
                    echo -e "${CYAN}âš¡ When to skip Level 6:${NC}"
                    echo -e "  ${YELLOW}â†’${NC} You're in a hurry (Levels 1-5 already found most duplicates)"
                    echo -e "  ${YELLOW}â†’${NC} Your collection is very large and time is limited"
                    echo -e "  ${YELLOW}â†’${NC} You trust the fast hash-based detection (Levels 1-5)"
                    echo ""
                    echo -ne "${BOLD}Run Level 6 deep analysis? [y/N]: ${NC}"
                    read -r level6_response
                    
                    if [[ "$level6_response" =~ ^[Yy]$ ]]; then
                        LEVEL6_USER_CONFIRMED="yes"
                        echo -e "${GREEN}âœ“ Level 6 enabled for this session${NC}"
                        echo ""
                    else
                        LEVEL6_USER_CONFIRMED="no"
                        echo -e "${YELLOW}âŠ˜ Level 6 skipped - using fast detection only (Levels 1-5)${NC}"
                        echo ""
                        should_run_level6=false
                    fi
                fi
                
                # Check user's previous response
                if [[ "$LEVEL6_USER_CONFIRMED" == "no" ]]; then
                    should_run_level6=false
                fi
            fi
            
            # Continue with Level 6 execution only if still enabled
            if [[ "$should_run_level6" == "true" ]]; then
                
                ((level6_checked++))
                
                # Perform deep frame analysis
                # No pre-filtering - Level 6 should run on ALL pairs to provide independent validation
                
                local frame1="${gif_frame_counts["$file1"]}}"
                local frame2="${gif_frame_counts["$file2"]}}"
                local dur1="${gif_durations["$file1"]}}"
                local dur2="${gif_durations["$file2"]}}"
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                
                # Only require basic data availability (not strict thresholds)
                if [[ $frame1 -gt 0 && $frame2 -gt 0 && $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    # Calculate differences for informational purposes
                    local frame_diff=$(( (frame1 > frame2 ? frame1 - frame2 : frame2 - frame1) * 100 / (frame1 > frame2 ? frame1 : frame2) ))
                    local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                    local size_diff=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    
                    # Relaxed pre-check: allow more differences (within 50% for size, 30% for frames/duration)
                    # This ensures Level 6 catches cases other layers missed
                    if [[ $frame_diff -lt 30 && $dur_diff -lt 30 && $size_diff -lt 50 ]]; then
                        
                        # =================================================================
                        # SMART CACHING: Check if this pair was already analyzed
                        # =================================================================
                        local cache_key="L6_COMPARE:$(basename "$file1"):$(basename "$file2")"
                        local cached_result=""
                        
                        # Try to load from cache
                        if [[ "$AI_CACHE_ENABLED" == "true" && -f "$AI_CACHE_INDEX" ]]; then
                            cached_result=$(grep "^$cache_key|" "$AI_CACHE_INDEX" 2>/dev/null | tail -1 | cut -d'|' -f5)
                        fi
                        
                        local frame_analysis=""
                        
                        if [[ -n "$cached_result" ]]; then
                            # Cache HIT! Use cached result
                            ((level6_cached++))
                            frame_analysis="$cached_result"
                            printf "\r\033[K"
                            echo -e "  ${GREEN}âš¡ Level 6: Using cached comparison result${NC}"
                        else
                            # Cache MISS - Need to perform analysis
                            # Show Level 6 analysis status (clear previous progress line)
                            printf "\r\033[K"
                            local name1="$(basename -- "$file1" .gif)"
                            local name2="$(basename -- "$file2" .gif)"
                            # Truncate long filenames
                            [[ ${#name1} -gt 20 ]] && name1="${name1:0:17}..."
                            [[ ${#name2} -gt 20 ]] && name2="${name2:0:17}..."
                            
                            echo ""
                            echo -e "  ${MAGENTA}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                            echo -e "  ${MAGENTA}${BOLD}ðŸ”¬ LEVEL 6 DEEP FRAME ANALYSIS RUNNING${NC}"
                            echo -e "  ${MAGENTA}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
                            echo -e "  ${YELLOW}âš ï¸  This is the SLOW deep analysis you enabled${NC}"
                            echo -e "  ${CYAN}ðŸ” Analyzing: ${BOLD}$name1${NC} ${YELLOW}â†”${NC} ${BOLD}$name2${NC}"
                            
                            # Show Level 6 progress bar
                            local l6_total_analyzed=$((level6_checked - level6_cached))
                            local l6_progress_pct=0
                            local estimated_l6_max=$((total_comparisons / 1000))  # ~0.1% estimate
                            [[ $estimated_l6_max -lt 1 ]] && estimated_l6_max=1
                            if [[ $estimated_l6_max -gt 0 ]]; then
                                l6_progress_pct=$((l6_total_analyzed * 100 / estimated_l6_max))
                                [[ $l6_progress_pct -gt 100 ]] && l6_progress_pct=100
                            fi
                            local l6_filled=$((l6_progress_pct * 30 / 100))
                            local l6_empty=$((30 - l6_filled))
                            
                            echo -e "  ${MAGENTA}L6 Progress [${NC}"
                            for ((k=0; k<l6_filled; k++)); do printf "${MAGENTA}â–ˆ${NC}"; done
                            for ((k=0; k<l6_empty; k++)); do printf "${GRAY}â–‘${NC}"; done
                            printf "${MAGENTA}] ${BOLD}%3d%%${NC}\n" "$l6_progress_pct"
                            echo -e "  ${GRAY}ðŸ“Š Level 6 comparisons: $l6_total_analyzed analyzed, $level6_cached cached${NC}"
                            
                            echo -ne "  ${BLUE}ðŸŽ¬ Extracting and comparing frames pixel-by-pixel...${NC}"
                            
                            # Perform advanced frame-by-frame comparison
                            frame_analysis=$(ai_advanced_frame_comparison "$file1" "$file2" "$temp_analysis_dir" "$AI_LEVEL6_FAST_MODE")
                            
                            # ðŸ›¡ï¸ BULLETPROOF CACHE SAVE: Atomic write + immediate backup + sync
                            if [[ "$AI_CACHE_ENABLED" == "true" && -n "$frame_analysis" && "$frame_analysis" != "0:0" ]]; then
                                local timestamp=$(date +%s)
                                local cache_entry="$cache_key|0|0|$timestamp|$frame_analysis"
                                
                                # Atomic write using temp file + mv (prevents corruption)
                                local temp_cache="$AI_CACHE_INDEX.tmp.$$"
                                
                                # Copy existing cache to temp (if exists)
                                if [[ -f "$AI_CACHE_INDEX" ]]; then
                                    cp "$AI_CACHE_INDEX" "$temp_cache" 2>/dev/null || touch "$temp_cache"
                                else
                                    touch "$temp_cache"
                                fi
                                
                                # Append new entry
                                echo "$cache_entry" >> "$temp_cache"
                                
                                # Atomic move (replaces old file)
                                mv -f "$temp_cache" "$AI_CACHE_INDEX" 2>/dev/null
                                
                                # Force immediate disk write (survive crashes)
                                sync "$AI_CACHE_INDEX" 2>/dev/null || true
                                
                                # Create backup every 10 entries for extra safety
                                if [[ $((level6_checked % 10)) -eq 0 ]]; then
                                    cp "$AI_CACHE_INDEX" "$AI_CACHE_INDEX.backup" 2>/dev/null || true
                                fi
                                
                                echo -e "  ${GREEN}âœ… Cached for future runs${NC}" >&2
                            fi
                        fi
                        
                        # Process the frame analysis result (whether cached or fresh)
                        if [[ "$frame_analysis" != "0:0" ]]; then
                            # Parse results: visual_match:color_match
                            local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                            local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                            
                            # STRICT CRITERIA for Level 6:
                            # Visual structure match >= 80% AND Color profile match >= 85%
                            if [[ $visual_match -ge 80 && $color_match -ge 85 ]]; then
                                # If already marked as duplicate by another layer, append Level 6 confirmation
                                if [[ "$is_duplicate" == "true" ]]; then
                                    similarity_reason="${similarity_reason}+L6_confirmed(V:${visual_match}%,C:${color_match}%)"
                                else
                                    # Level 6 found a NEW duplicate that other layers missed!
                                    is_duplicate=true
                                    similarity_reason="L6_frame_analysis(V:${visual_match}%,C:${color_match}%)"
                                    ((DUPLICATE_STATS_NEAR_IDENTICAL++))
                                fi
                            fi
                        fi
                    fi
                fi
            fi
            
            # Handle detected duplicates
            if [[ "$is_duplicate" == "true" ]]; then
                local size1="${gif_sizes["$file1"]}}"
                local size2="${gif_sizes["$file2"]}}"
                
                # Get file metadata for intelligent decision
                local mtime1=$(stat -c%Y -- "$file1" 2>/dev/null || echo "0")  # Modification time
                local mtime2=$(stat -c%Y -- "$file2" 2>/dev/null || echo "0")
                local ctime1=$(stat -c%Z "$file1" 2>/dev/null || echo "0")  # Change time (creation on some systems)
                local ctime2=$(stat -c%Z "$file2" 2>/dev/null || echo "0")
                local perms1=$(stat -c%a "$file1" 2>/dev/null || echo "0")  # File permissions
                local perms2=$(stat -c%a "$file2" 2>/dev/null || echo "0")
                
                # Get base filenames for similarity comparison
                local basename1=$(basename -- "$file1" .gif)
                local basename2=$(basename -- "$file2" .gif)
                
                # Check if corresponding MP4/video source files exist
                local has_source1=false
                local has_source2=false
                local source_file1=""
                local source_file2=""
                
                # Check for video source files for file1
                for ext in mp4 avi mov mkv webm MP4 AVI MOV MKV WEBM; do
                    if [[ -f "${basename1}.$ext" ]]; then
                        has_source1=true
                        source_file1="${basename1}.$ext"
                        break
                    fi
                done
                
                # Check for video source files for file2
                for ext in mp4 avi mov mkv webm MP4 AVI MOV MKV WEBM; do
                    if [[ -f "${basename2}.$ext" ]]; then
                        has_source2=true
                        source_file2="${basename2}.$ext"
                        break
                    fi
                done
                
                # Calculate filename similarity score (0-100)
                local name_similarity=0
                if [[ "$basename1" == "$basename2" ]]; then
                    name_similarity=100
                elif [[ "$basename1" == *"$basename2"* || "$basename2" == *"$basename1"* ]]; then
                    name_similarity=75  # Substring match
                elif [[ "${basename1:0:10}" == "${basename2:0:10}" ]]; then
                    name_similarity=50  # First 10 chars match
                else
                    # Check for common patterns like "copy", "(1)", etc.
                    if [[ "$basename1" =~ [[:space:]]?\(?[0-9]+\)? ]] || [[ "$basename2" =~ [[:space:]]?\(?[0-9]+\)? ]]; then
                        name_similarity=60  # Likely a copy with number
                    fi
                fi
                
                # Intelligent decision logic based on multiple factors
                local keep_file=""
                local remove_file=""
                local decision_reason=""
                
                # Rule 0 (PRIORITY): Prefer GIF that matches its source video filename
                # This is the most important rule - GIFs should match their source videos
                if [[ "$has_source1" == true && "$has_source2" == false ]]; then
                    # Only file1 has a matching source video - keep it
                    keep_file="$file1"
                    remove_file="$file2"
                    decision_reason="keeping GIF matching source video: $(basename -- "$source_file1")"
                elif [[ "$has_source2" == true && "$has_source1" == false ]]; then
                    # Only file2 has a matching source video - keep it
                    keep_file="$file2"
                    remove_file="$file1"
                    decision_reason="keeping GIF matching source video: $(basename -- "$source_file2")"
                elif [[ "$has_source1" == true && "$has_source2" == true ]]; then
                    # Both have matching source videos - this shouldn't happen normally
                    # Fall through to other rules but mark this special case
                    decision_reason="both match source videos"
                    # Continue to next rule without setting keep/remove yet
                fi
                
                # Only apply remaining rules if keep_file is not yet set
                if [[ -z "$keep_file" ]]; then
                
                # Rule 0: Prefer files in OUTPUT_DIRECTORY (keep organized files)
                local file1_in_output=false
                local file2_in_output=false
                
                # Check if files are in OUTPUT_DIRECTORY
                if [[ -d "$OUTPUT_DIRECTORY" ]]; then
                    local output_dir_abs="$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd)"
                    local file1_dir="$(cd "$(dirname "$file1")" 2>/dev/null && pwd)"
                    local file2_dir="$(cd "$(dirname "$file2")" 2>/dev/null && pwd)"
                    
                    [[ "$file1_dir" == "$output_dir_abs" ]] && file1_in_output=true
                    [[ "$file2_dir" == "$output_dir_abs" ]] && file2_in_output=true
                    
                    # If one is in OUTPUT_DIRECTORY and the other isn't, prefer the one in OUTPUT_DIRECTORY
                    if [[ "$file1_in_output" == true && "$file2_in_output" == false ]]; then
                        keep_file="$file1"
                        remove_file="$file2"
                        decision_reason="keeping file in output directory (organized)"
                    elif [[ "$file2_in_output" == true && "$file1_in_output" == false ]]; then
                        keep_file="$file2"
                        remove_file="$file1"
                        decision_reason="keeping file in output directory (organized)"
                    fi
                fi
                
                # Only continue to other rules if not yet decided
                if [[ -z "$keep_file" ]]; then
                # Rule 1: Prefer the file created first (older file)
                if [[ $ctime1 -lt $ctime2 && $((ctime2 - ctime1)) -gt 60 ]]; then
                    # file1 is at least 1 minute older
                    keep_file="$file1"
                    remove_file="$file2"
                    decision_reason="keeping older file (created first)"
                elif [[ $ctime2 -lt $ctime1 && $((ctime1 - ctime2)) -gt 60 ]]; then
                    # file2 is at least 1 minute older
                    keep_file="$file2"
                    remove_file="$file1"
                    decision_reason="keeping older file (created first)"
                # Rule 2: If no source match and creation times are similar, prefer file with better name
                elif [[ $name_similarity -ge 60 ]]; then
                    # Files have similar names, prefer the simpler/shorter one
                    local len1=${#basename1}
                    local len2=${#basename2}
                    
                    # Check if one is a numbered copy
                    if [[ "$basename2" =~ \([0-9]+\) && ! "$basename1" =~ \([0-9]+\) ]]; then
                        keep_file="$file1"
                        remove_file="$file2"
                        decision_reason="removing numbered copy"
                    elif [[ "$basename1" =~ \([0-9]+\) && ! "$basename2" =~ \([0-9]+\) ]]; then
                        keep_file="$file2"
                        remove_file="$file1"
                        decision_reason="removing numbered copy"
                    # Check for "copy" in filename
                    elif [[ "$basename2" =~ -?[Cc]opy && ! "$basename1" =~ -?[Cc]opy ]]; then
                        keep_file="$file1"
                        remove_file="$file2"
                        decision_reason="removing copy file"
                    elif [[ "$basename1" =~ -?[Cc]opy && ! "$basename2" =~ -?[Cc]opy ]]; then
                        keep_file="$file2"
                        remove_file="$file1"
                        decision_reason="removing copy file"
                    # Prefer shorter, cleaner name
                    elif [[ $len1 -lt $len2 ]]; then
                        keep_file="$file1"
                        remove_file="$file2"
                        decision_reason="keeping shorter filename"
                    else
                        keep_file="$file2"
                        remove_file="$file1"
                        decision_reason="keeping shorter filename"
                    fi
                # Rule 3: Prefer larger file size (better quality)
                elif [[ $size2 -gt $size1 && $((size2 - size1)) -gt 1024 ]]; then
                    # file2 is at least 1KB larger
                    keep_file="$file2"
                    remove_file="$file1"
                    decision_reason="keeping larger file (better quality)"
                elif [[ $size1 -gt $size2 && $((size1 - size2)) -gt 1024 ]]; then
                    # file1 is at least 1KB larger
                    keep_file="$file1"
                    remove_file="$file2"
                    decision_reason="keeping larger file (better quality)"
                # Rule 4: Prefer file modified more recently (if sizes are similar)
                elif [[ $mtime1 -gt $mtime2 ]]; then
                    keep_file="$file1"
                    remove_file="$file2"
                    decision_reason="keeping recently modified file"
                elif [[ $mtime2 -gt $mtime1 ]]; then
                    keep_file="$file2"
                    remove_file="$file1"
                    decision_reason="keeping recently modified file"
                # Rule 5: Fallback to alphabetical order
                elif [[ "$file1" < "$file2" ]]; then
                    keep_file="$file1"
                    remove_file="$file2"
                    decision_reason="${decision_reason:+$decision_reason, }alphabetical order"
                else
                    keep_file="$file2"
                    remove_file="$file1"
                    decision_reason="${decision_reason:+$decision_reason, }alphabetical order"
                fi
                fi  # End of: if [[ -z "$keep_file" ]] (inner check at line 6060)
                fi  # End of: if [[ -z "$keep_file" ]] (outer check at line 6032)
                
                # Safety check: make sure we have both files set
                if [[ -z "$keep_file" || -z "$remove_file" ]]; then
                    echo -e "    ${RED}âš ï¸  Warning: Could not determine which duplicate to keep, skipping pair${NC}" >&2
                    continue
                fi
                
                # Store the duplicate pair with enhanced metadata
                duplicate_pairs+=("$remove_file|$keep_file|$similarity_reason|$decision_reason")
                ((duplicate_count++))
            fi
        done
    done
    
    # Clear Stage 2 progress line and show completion
    if [[ $total_comparisons -gt 5 ]]; then
        printf "\r  ${GREEN}âœ“ Duplicate analysis complete! Compared $total_comparisons file pairs${NC}\n"
    fi
    
    # ðŸ’¾ Clear progress file on successful completion
    rm -f "$stage2_progress_file" 2>/dev/null
    
    # ðŸš€ Save file tracking database for next run (delta detection)
    : > "$file_tracking_db"
    echo "# File Tracking Database - Updated: $(date)" >> "$file_tracking_db"
    echo "# Format: filename|mtime|size" >> "$file_tracking_db"
    for gif_file in "${gif_files[@]}"; do
        local file_mtime=$(stat -c%Y -- "$gif_file" 2>/dev/null || echo "0")
        local file_size="${gif_sizes[$gif_file]}"
        echo "$gif_file|$file_mtime|$file_size" >> "$file_tracking_db"
    done
    
    if [[ $delta_mode_enabled == true && $skipped_comparisons -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ File tracking database updated for next run${NC}"
    fi
    
    # ========================================================================
    # COMPREHENSIVE LEVEL-BY-LEVEL PROGRESS SUMMARY
    # ========================================================================
    echo ""
    echo -e "  ${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "  ${CYAN}${BOLD}â•‘          ðŸ“Š 6-LEVEL DUPLICATE DETECTION SUMMARY                   â•‘${NC}"
    echo -e "  ${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Calculate total checks across all levels
    local total_level_checks=$((level1_checked + level2_checked + level3_checked + level4_checked + level5_checked + level6_checked))
    
    # Level 1 Progress Bar
    local level1_pct=0
    [[ $level1_checked -gt 0 && $total_comparisons -gt 0 ]] && level1_pct=$((level1_checked * 100 / total_comparisons))
    local level1_bar_filled=$((level1_pct * 40 / 100))
    echo -e "  ${BLUE}Level 1: Exact Binary Match (MD5)${NC}"
    printf "  ["
    for ((k=0; k<level1_bar_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((k=level1_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    printf "] ${BOLD}%3d%%${NC} ${GRAY}($level1_checked comparisons)${NC}\n" "$level1_pct"
    
    # Level 2 Progress Bar
    local level2_pct=0
    [[ $level2_checked -gt 0 && $total_comparisons -gt 0 ]] && level2_pct=$((level2_checked * 100 / total_comparisons))
    local level2_bar_filled=$((level2_pct * 40 / 100))
    echo -e "  ${BLUE}Level 2: Visual Hash Matching${NC}"
    printf "  ["
    for ((k=0; k<level2_bar_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((k=level2_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    printf "] ${BOLD}%3d%%${NC} ${GRAY}($level2_checked comparisons)${NC}\n" "$level2_pct"
    
    # Level 3 Progress Bar
    local level3_pct=0
    [[ $level3_checked -gt 0 && $total_comparisons -gt 0 ]] && level3_pct=$((level3_checked * 100 / total_comparisons))
    local level3_bar_filled=$((level3_pct * 40 / 100))
    echo -e "  ${BLUE}Level 3: Content Fingerprint${NC}"
    printf "  ["
    for ((k=0; k<level3_bar_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((k=level3_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    printf "] ${BOLD}%3d%%${NC} ${GRAY}($level3_checked comparisons)${NC}\n" "$level3_pct"
    
    # Level 4 Progress Bar
    local level4_pct=0
    [[ $level4_checked -gt 0 && $total_comparisons -gt 0 ]] && level4_pct=$((level4_checked * 100 / total_comparisons))
    local level4_bar_filled=$((level4_pct * 40 / 100))
    echo -e "  ${BLUE}Level 4: Near-Identical Detection${NC}"
    printf "  ["
    for ((k=0; k<level4_bar_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((k=level4_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    printf "] ${BOLD}%3d%%${NC} ${GRAY}($level4_checked comparisons)${NC}\n" "$level4_pct"
    
    # Level 5 Progress Bar
    local level5_pct=0
    [[ $level5_checked -gt 0 && $total_comparisons -gt 0 ]] && level5_pct=$((level5_checked * 100 / total_comparisons))
    local level5_bar_filled=$((level5_pct * 40 / 100))
    echo -e "  ${BLUE}Level 5: Filename Similarity${NC}"
    printf "  ["
    for ((k=0; k<level5_bar_filled; k++)); do printf "${GREEN}â–ˆ${NC}"; done
    for ((k=level5_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    printf "] ${BOLD}%3d%%${NC} ${GRAY}($level5_checked comparisons)${NC}\n" "$level5_pct"
    
    # Level 6 Progress Bar with Cache Info
    local level6_pct=0
    [[ $level6_checked -gt 0 && $total_comparisons -gt 0 ]] && level6_pct=$((level6_checked * 100 / total_comparisons))
    local level6_bar_filled=$((level6_pct * 40 / 100))
    local level6_analyzed=$((level6_checked - level6_cached))
    echo -e "  ${MAGENTA}Level 6: AI Frame-by-Frame Analysis${NC}"
    printf "  ["
    for ((k=0; k<level6_bar_filled; k++)); do printf "${MAGENTA}â–ˆ${NC}"; done
    for ((k=level6_bar_filled; k<40; k++)); do printf "${GRAY}â–‘${NC}"; done
    if [[ $level6_checked -gt 0 ]]; then
        printf "] ${BOLD}%3d%%${NC} ${GRAY}($level6_checked total: ${GREEN}$level6_cached cached${GRAY}, ${YELLOW}$level6_analyzed analyzed${GRAY})${NC}\n" "$level6_pct"
    else
        printf "] ${BOLD}%3d%%${NC} ${GRAY}(not triggered)${NC}\n" "$level6_pct"
    fi
    
    echo ""
    echo -e "  ${CYAN}${BOLD}ðŸ“ˆ DETECTION STATISTICS:${NC}"
    echo -e "    ${GREEN}âœ“${NC} Total Comparisons:     ${BOLD}$total_comparisons${NC} file pairs"
    echo -e "    ${GREEN}âœ“${NC} Duplicates Found:      ${BOLD}$duplicate_count${NC} duplicates"
    
    # Show detection breakdown
    if [[ $DUPLICATE_STATS_EXACT_BINARY -gt 0 ]]; then
        echo -e "    ${GREEN}  â”œâ”€${NC} Exact Binary:        ${BOLD}$DUPLICATE_STATS_EXACT_BINARY${NC}"
    fi
    if [[ $DUPLICATE_STATS_VISUAL_IDENTICAL -gt 0 ]]; then
        echo -e "    ${BLUE}  â”œâ”€${NC} Visual Identical:    ${BOLD}$DUPLICATE_STATS_VISUAL_IDENTICAL${NC}"
    fi
    if [[ $DUPLICATE_STATS_CONTENT_FINGERPRINT -gt 0 ]]; then
        echo -e "    ${CYAN}  â”œâ”€${NC} Content Fingerprint: ${BOLD}$DUPLICATE_STATS_CONTENT_FINGERPRINT${NC}"
    fi
    if [[ $DUPLICATE_STATS_NEAR_IDENTICAL -gt 0 ]]; then
        echo -e "    ${YELLOW}  â””â”€${NC} Near-Identical:      ${BOLD}$DUPLICATE_STATS_NEAR_IDENTICAL${NC}"
    fi
    
    # Level 6 specific stats with restored progress message
    if [[ $level6_checked -gt 0 ]]; then
        local level6_hit_rate=0
        [[ $level6_checked -gt 0 ]] && level6_hit_rate=$((level6_cached * 100 / level6_checked))
        echo -e "    ${MAGENTA}âš¡${NC} Level 6 Cache:        ${BOLD}${level6_hit_rate}%${NC} hit rate ${GRAY}($level6_cached/$level6_checked)${NC}"
        
        # Show restored progress message if we had cached results
        if [[ $level6_cached -gt 0 ]]; then
            echo -e "    ${GREEN}âœ…${NC} Restored Progress:   ${BOLD}$level6_cached${NC} comparisons loaded from previous runs"
            echo -e "      ${GRAY}â†’ Saved time by skipping already-analyzed pairs${NC}"
        fi
    fi
    
    echo ""
    
    # Stage 3: Results summary
    echo -e "  ${YELLOW}${BOLD}ðŸ“Š Stage 3: Analysis results and recommendations...${NC}"
    
    # Clean up temporary analysis directory
    rm -rf "$temp_analysis_dir"
    
    if [[ $total_gifs -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No existing GIF files found${NC}"
        return 0
    fi
    
    # Calculate unique duplicate GIFs
    declare -A all_duplicate_gifs
    declare -A gif_file_sizes
    for pair in "${duplicate_pairs[@]}"; do
        local remove_file="${pair%%|*}"
        local rest="${pair#*|}"
        local keep_file="${rest%%|*}"
        all_duplicate_gifs["$remove_file"]=1
        all_duplicate_gifs["$keep_file"]=1
        
        # Store file sizes for savings calculation
        gif_file_sizes["$remove_file"]=$(stat -c%s -- "$remove_file" 2>/dev/null || echo "0")
        gif_file_sizes["$keep_file"]=$(stat -c%s -- "$keep_file" 2>/dev/null || echo "0")
    done
    local unique_duplicate_gifs=${#all_duplicate_gifs[@]}
    
    if [[ $duplicate_count -eq 0 ]]; then
        echo -e "\n  ${GREEN}${BOLD}âœ¨ Excellent! No duplicate GIFs found (Levels 1-5)${NC}"
        echo -e "  ${GRAY}All $total_gifs GIF files are unique based on:
    â€¢ Binary comparison (MD5)
    â€¢ Visual hashing (perceptual hash)
    â€¢ Content fingerprinting
    â€¢ Metadata matching
    â€¢ Filename similarity${NC}"
        echo ""
        echo -e "${CYAN}${BOLD}ðŸ” Level 6: Deep Frame-by-Frame Analysis${NC}"
        echo -e "  ${GRAY}â€¢ Compares actual GIF frames for visual similarity${NC}"
        echo -e "  ${GRAY}â€¢ Can detect re-encoded or optimized duplicates${NC}"
        echo -e "  ${GRAY}â€¢ Much slower: ~20-40 seconds per pair${NC}"
        echo -e "  ${YELLOW}â€¢ For $total_gifs GIFs: $(( total_gifs * (total_gifs - 1) / 2 )) comparisons needed${NC}"
        echo ""
        echo -ne "${BOLD}Proceed with Level 6 frame-by-frame detection? (y/N): ${NC}"
        read -r level6_choice
        
        if [[ ! "$level6_choice" =~ ^[Yy]$ ]]; then
            echo -e "${GREEN}âœ“ Skipping Level 6 analysis${NC}"
            echo -e "  ${BLUE}ðŸš€ Your collection is already optimized!${NC}"
            return 0
        fi
        
        # Run Level 6 analysis with BULLETPROOF PRE-FILTERING
        echo -e "\n  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 3: Level 6 Deep Frame Analysis...${NC}"
        echo -e "  ${CYAN}ðŸ§  AI Pre-filtering: Only analyzing likely duplicate candidates...${NC}"
        echo -e "  ${YELLOW}âš ï¸  Press Ctrl+C to cancel at any time${NC}\n"
        
        # Track Level 6 results
        local level6_duplicate_count=0
        local level6_checked_here=0
        local level6_cached_here=0
        local level6_skipped=0
        
        # Build candidate pairs using bulletproof similarity detection
        echo -e "  ${BLUE}ðŸ” Stage 1: Building candidate pairs based on similarity indicators...${NC}"
        declare -a candidate_pairs
        local total_possible_pairs=$(( total_gifs * (total_gifs - 1) / 2 ))
        local pairs_evaluated=0
        
        for ((i=0; i<total_gifs; i++)); do
            local file1="${gif_files_list[$i]}"
            
            for ((j=i+1; j<total_gifs; j++)); do
                local file2="${gif_files_list[$j]}"
                ((pairs_evaluated++))
                
                # Show pre-filtering progress
                if [[ $((pairs_evaluated % 50)) -eq 0 || $pairs_evaluated -eq $total_possible_pairs ]]; then
                    local filter_pct=$((pairs_evaluated * 100 / total_possible_pairs))
                    printf "\r  ${CYAN}Pre-filter: [${NC}"
                    local filled=$((filter_pct * 30 / 100))
                    for ((k=0; k<filled; k++)); do printf "${CYAN}â–ˆ${NC}"; done
                    for ((k=filled; k<30; k++)); do printf "${GRAY}â–‘${NC}"; done
                    printf "${CYAN}] ${BOLD}%3d%%${NC} ${GRAY}(%d candidates)${NC}" "$filter_pct" "${#candidate_pairs[@]}"
                fi
                
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ðŸ›¡ï¸ BULLETPROOF SIMILARITY PRE-FILTER (10 Factors)
                # Only pairs passing this filter will undergo expensive Level 6 analysis
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                local similarity_score=0
                local should_analyze=false
                
                # Factor 1: Similar filenames (40 points max)
                local name1="$(basename -- "$file1" .gif)"
                local name2="$(basename -- "$file2" .gif)"
                if [[ "${name1:0:15}" == "${name2:0:15}" ]]; then
                    similarity_score=$((similarity_score + 40))
                elif [[ "${name1:0:10}" == "${name2:0:10}" ]]; then
                    similarity_score=$((similarity_score + 30))
                elif [[ "${name1:0:5}" == "${name2:0:5}" ]]; then
                    similarity_score=$((similarity_score + 15))
                fi
                
                # Factor 2: Similar file sizes (35 points max)
                local size1="${gif_sizes["$file1"]:-0}"
                local size2="${gif_sizes["$file2"]:-0}"
                if [[ $size1 -gt 0 && $size2 -gt 0 ]]; then
                    local size_diff_pct=$(( (size1 > size2 ? size1 - size2 : size2 - size1) * 100 / (size1 > size2 ? size1 : size2) ))
                    if [[ $size_diff_pct -lt 5 ]]; then
                        similarity_score=$((similarity_score + 35))
                    elif [[ $size_diff_pct -lt 15 ]]; then
                        similarity_score=$((similarity_score + 25))
                    elif [[ $size_diff_pct -lt 30 ]]; then
                        similarity_score=$((similarity_score + 15))
                    elif [[ $size_diff_pct -lt 50 ]]; then
                        similarity_score=$((similarity_score + 5))
                    fi
                fi
                
                # Factor 3: Frame count match (50 points max)
                local frame1="${gif_frame_counts["$file1"]:-0}"
                local frame2="${gif_frame_counts["$file2"]:-0}"
                if [[ $frame1 -gt 0 && $frame2 -gt 0 ]]; then
                    if [[ $frame1 -eq $frame2 ]]; then
                        similarity_score=$((similarity_score + 50))  # Exact match = very suspicious
                    else
                        local frame_diff=$(( (frame1 > frame2 ? frame1 - frame2 : frame2 - frame1) * 100 / (frame1 > frame2 ? frame1 : frame2) ))
                        if [[ $frame_diff -lt 5 ]]; then
                            similarity_score=$((similarity_score + 40))
                        elif [[ $frame_diff -lt 10 ]]; then
                            similarity_score=$((similarity_score + 25))
                        elif [[ $frame_diff -lt 20 ]]; then
                            similarity_score=$((similarity_score + 10))
                        fi
                    fi
                fi
                
                # Factor 4: Duration match (45 points max)
                local dur1="${gif_durations["$file1"]:-0}"
                local dur2="${gif_durations["$file2"]:-0}"
                if [[ $dur1 -gt 0 && $dur2 -gt 0 ]]; then
                    if [[ $dur1 -eq $dur2 ]]; then
                        similarity_score=$((similarity_score + 45))  # Exact match
                    else
                        local dur_diff=$(( (dur1 > dur2 ? dur1 - dur2 : dur2 - dur1) * 100 / (dur1 > dur2 ? dur1 : dur2) ))
                        if [[ $dur_diff -lt 5 ]]; then
                            similarity_score=$((similarity_score + 35))
                        elif [[ $dur_diff -lt 10 ]]; then
                            similarity_score=$((similarity_score + 20))
                        elif [[ $dur_diff -lt 20 ]]; then
                            similarity_score=$((similarity_score + 10))
                        fi
                    fi
                fi
                
                # Factor 5: Visual hash similarity (55 points max)
                local vhash1="${gif_visual_hashes["$file1"]:-0}"
                local vhash2="${gif_visual_hashes["$file2"]:-0}"
                if [[ -n "$vhash1" && -n "$vhash2" && "$vhash1" != "0" && "$vhash2" != "0" ]]; then
                    if [[ "$vhash1" == "$vhash2" ]]; then
                        similarity_score=$((similarity_score + 55))  # Identical hash
                    else
                        # Hamming distance check if available
                        local hash_proximity=$(( 100 - (vhash1 > vhash2 ? vhash1 - vhash2 : vhash2 - vhash1) * 100 / vhash1 ))
                        if [[ $hash_proximity -gt 90 ]]; then
                            similarity_score=$((similarity_score + 45))
                        elif [[ $hash_proximity -gt 80 ]]; then
                            similarity_score=$((similarity_score + 30))
                        elif [[ $hash_proximity -gt 70 ]]; then
                            similarity_score=$((similarity_score + 15))
                        fi
                    fi
                fi
                
                # Factor 6: Content fingerprint match (50 points max)
                local fp1="${gif_fingerprints["$file1"]:-}"
                local fp2="${gif_fingerprints["$file2"]:-}"
                if [[ -n "$fp1" && -n "$fp2" && "$fp1" == "$fp2" ]]; then
                    similarity_score=$((similarity_score + 50))
                fi
                
                # Factor 7: Resolution similarity (30 points max)
                if [[ -n "$fp1" && -n "$fp2" ]]; then
                    local res1=$(echo "$fp1" | cut -d':' -f2)
                    local res2=$(echo "$fp2" | cut -d':' -f2)
                    if [[ "$res1" == "$res2" ]]; then
                        similarity_score=$((similarity_score + 30))
                    fi
                fi
                
                # Factor 8: MD5 prefix similarity (35 points max)
                local hash1="${gif_checksums["$file1"]:-}"
                local hash2="${gif_checksums["$file2"]:-}"
                if [[ -n "$hash1" && -n "$hash2" && "$hash1" != "ERROR" && "$hash2" != "ERROR" ]]; then
                    if [[ "${hash1:0:8}" == "${hash2:0:8}" ]]; then
                        similarity_score=$((similarity_score + 35))
                    elif [[ "${hash1:0:4}" == "${hash2:0:4}" ]]; then
                        similarity_score=$((similarity_score + 20))
                    elif [[ "${hash1:0:2}" == "${hash2:0:2}" ]]; then
                        similarity_score=$((similarity_score + 10))
                    fi
                fi
                
                # Factor 9: Timestamp proximity (25 points max)
                local mtime1=$(stat -c%Y -- "$file1" 2>/dev/null || echo "0")
                local mtime2=$(stat -c%Y -- "$file2" 2>/dev/null || echo "0")
                if [[ $mtime1 -gt 0 && $mtime2 -gt 0 ]]; then
                    local time_diff=$((mtime1 > mtime2 ? mtime1 - mtime2 : mtime2 - mtime1))
                    if [[ $time_diff -lt 60 ]]; then
                        similarity_score=$((similarity_score + 25))  # Within 1 minute
                    elif [[ $time_diff -lt 300 ]]; then
                        similarity_score=$((similarity_score + 15))  # Within 5 minutes
                    elif [[ $time_diff -lt 3600 ]]; then
                        similarity_score=$((similarity_score + 5))   # Within 1 hour
                    fi
                fi
                
                # Factor 10: Same directory (15 points)
                local dir1=$(dirname -- "$file1")
                local dir2=$(dirname -- "$file2")
                if [[ "$dir1" == "$dir2" ]]; then
                    similarity_score=$((similarity_score + 15))
                fi
                
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # DECISION: Add to candidate list if similarity score >= 60
                # (Out of max 400 points, 60 = 15% threshold)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if [[ $similarity_score -ge 60 ]]; then
                    candidate_pairs+=("$file1|$file2|$similarity_score")
                fi
            done
        done
        
        printf "\r\033[K"
        echo -e "  ${GREEN}âœ“ Pre-filtering complete${NC}"
        echo -e "  ${CYAN}ðŸ“Š Candidates: ${BOLD}${#candidate_pairs[@]}${NC}${CYAN} pairs out of ${BOLD}$total_possible_pairs${NC}${CYAN} total${NC}"
        local reduction_pct=$(( (total_possible_pairs - ${#candidate_pairs[@]}) * 100 / total_possible_pairs ))
        echo -e "  ${GREEN}âš¡ Efficiency: ${BOLD}${reduction_pct}%${NC}${GREEN} of pairs filtered out (skipping unlikely matches)${NC}"
        echo ""
        
        # If no candidates, exit early
        if [[ ${#candidate_pairs[@]} -eq 0 ]]; then
            echo -e "  ${GREEN}${BOLD}âœ¨ No similar pairs detected - all files are unique!${NC}"
            echo -e "  ${BLUE}ðŸš€ Your collection is fully optimized!${NC}"
            return 0
        fi
        
        echo -e "  ${MAGENTA}${BOLD}ðŸŽ¬ Stage 2: Deep frame analysis on ${#candidate_pairs[@]} candidate pairs...${NC}\n"
        
        # Analyze only the candidate pairs
        for candidate_pair in "${candidate_pairs[@]}"; do
            local file1="${candidate_pair%%|*}"
            local rest="${candidate_pair#*|}"
            local file2="${rest%%|*}"
            local sim_score="${rest##*|}"
            
            ((level6_checked_here++))
            
            # Show progress
            local progress_pct=$((level6_checked_here * 100 / ${#candidate_pairs[@]}))
            printf "\r  ${MAGENTA}Progress: [${NC}"
            local filled=$((progress_pct * 30 / 100))
            for ((k=0; k<filled; k++)); do printf "${MAGENTA}â–ˆ${NC}"; done
            for ((k=filled; k<30; k++)); do printf "${GRAY}â–‘${NC}"; done
            printf "${MAGENTA}] ${BOLD}%3d%%${NC} ${GRAY}($level6_checked_here/${#candidate_pairs[@]} candidates, Sim: $sim_score)${NC}" "$progress_pct"
            
            # Check cache first
            local cache_key="L6_COMPARE:$(basename "$file1"):$(basename "$file2")"
            local cached_result=""
            
            if [[ "$AI_CACHE_ENABLED" == "true" && -f "$AI_CACHE_INDEX" ]]; then
                cached_result=$(grep "^$cache_key|" "$AI_CACHE_INDEX" 2>/dev/null | tail -1 | cut -d'|' -f5)
            fi
            
            local frame_analysis=""
            
            if [[ -n "$cached_result" ]]; then
                # Cache HIT
                ((level6_cached_here++))
                frame_analysis="$cached_result"
            else
                # Cache MISS - perform analysis
                frame_analysis=$(ai_advanced_frame_comparison "$file1" "$file2" "$temp_analysis_dir" "false")
                
                # Save to cache
                if [[ "$AI_CACHE_ENABLED" == "true" && -n "$frame_analysis" && "$frame_analysis" != "0:0" ]]; then
                    local timestamp=$(date +%s)
                    local cache_entry="$cache_key|0|0|$timestamp|$frame_analysis"
                    echo "$cache_entry" >> "$AI_CACHE_INDEX" 2>/dev/null
                fi
            fi
            
            # Check if frames match (duplicate detected)
            if [[ "$frame_analysis" != "0:0" ]]; then
                local visual_match=$(echo "$frame_analysis" | cut -d':' -f1)
                local color_match=$(echo "$frame_analysis" | cut -d':' -f2)
                
                # STRICT CRITERIA: Visual >= 80% AND Color >= 85%
                if [[ $visual_match -ge 80 && $color_match -ge 85 ]]; then
                    # Found a Level 6 duplicate!
                    ((level6_duplicate_count++))
                    
                    # Add to duplicate pairs
                    local size1="${gif_sizes["$file1"]:-0}"
                    local size2="${gif_sizes["$file2"]:-0}"
                    local keep_file="$file1"
                    local remove_file="$file2"
                    
                    # Keep larger file
                    if [[ $size2 -gt $size1 ]]; then
                        keep_file="$file2"
                        remove_file="$file1"
                    fi
                    
                    duplicate_pairs+=("$remove_file|$keep_file|L6_frame_analysis(V:${visual_match}%,C:${color_match}%)|$((size1 - size2))")
                    ((duplicate_count++))
                    
                    printf "\r\033[K"
                    echo -e "  ${GREEN}âœ“ Level 6 duplicate found!${NC} ${YELLOW}$(basename "$file1")${NC} â†” ${YELLOW}$(basename "$file2")${NC}"
                    echo -e "    ${CYAN}Visual: ${BOLD}${visual_match}%${NC} ${CYAN}| Color: ${BOLD}${color_match}%${NC}"
                fi
            fi
        done
        
        printf "\r\033[K"
        echo ""
        echo -e "  ${GREEN}${BOLD}âœ“ Level 6 Analysis Complete${NC}"
        echo -e "  ${GRAY}Analyzed: $level6_checked_here pairs${NC}"
        echo -e "  ${GRAY}Cached: $level6_cached_here pairs${NC}"
        echo -e "  ${GRAY}Duplicates found: ${BOLD}$level6_duplicate_count${NC}"
        echo ""
        
        # If Level 6 found duplicates, show results and deletion prompt
        if [[ $level6_duplicate_count -gt 0 ]]; then
            echo -e "${YELLOW}${BOLD}ðŸ“Š LEVEL 6 DUPLICATE DETECTION RESULTS${NC}\n"
            echo -e "${CYAN}ðŸ“ˆ Summary:${NC}"
            echo -e "  ${BOLD}â€¢ Total GIFs scanned:${NC} $total_gifs"
            echo -e "  ${BOLD}â€¢ Duplicate pairs found:${NC} ${YELLOW}$duplicate_count${NC}"
            echo ""
            
            # Calculate storage savings
            local potential_savings=0
            for pair in "${duplicate_pairs[@]}"; do
                local remove_file="${pair%%|*}"
                local remove_size=$(stat -c%s -- "$remove_file" 2>/dev/null || echo "0")
                [[ -n "$remove_size" && "$remove_size" -gt 0 ]] && potential_savings=$((potential_savings + remove_size))
            done
            
            if [[ $potential_savings -gt 0 ]]; then
                local savings_mb=$((potential_savings / 1024 / 1024))
                echo -e "${GREEN}ðŸ’¾ Potential storage savings: ${BOLD}${savings_mb}MB${NC}"
                echo ""
            fi
            
            # Deletion prompt
            echo -ne "${BOLD}Delete duplicate GIFs found by Level 6? (y/N): ${NC}"
            read -r delete_choice
            
            if [[ "$delete_choice" =~ ^[Yy]$ ]]; then
                echo -e "\n${CYAN}ðŸ—‘ï¸  Deleting Level 6 duplicates...${NC}\n"
                local deleted_count=0
                
                for pair in "${duplicate_pairs[@]}"; do
                    local remove_file="${pair%%|*}"
                    
                    if [[ -f "$remove_file" ]]; then
                        local keep_file="${pair#*|}"
                        keep_file="${keep_file%%|*}"
                        
                        rm -f "$remove_file"
                        if [[ $? -eq 0 ]]; then
                            ((deleted_count++))
                            echo -e "  ${GREEN}âœ“ Deleted:${NC} $(basename "$remove_file")"
                            
                            # ðŸ§  Train AI from Level 6 delete decision
                            train_ai_from_decision "$keep_file" "$remove_file" "95" "delete_file2" "LEVEL6"
                        fi
                    fi
                done
                
                echo ""
                echo -e "${GREEN}${BOLD}âœ“ Deleted $deleted_count duplicate files${NC}"
                
                # ðŸ§  Show AI learning progress
                show_ai_training_stats
            else
                echo -e "${GREEN}âœ“ Keeping all files - no changes made${NC}"
            fi
        else
            echo -e "  ${GREEN}${BOLD}âœ¨ Excellent! No duplicates found even with Level 6 deep analysis${NC}"
            echo -e "  ${BLUE}ðŸš€ Your collection is fully optimized!${NC}"
        fi
        
        return 0
    fi
    
    echo -e "\n${YELLOW}${BOLD}ðŸ“Š DUPLICATE GIF DETECTION RESULTS${NC}\n"
    
    # Main statistics
    echo -e "${CYAN}ðŸ“ˆ Summary:${NC}"
    echo -e "  ${BOLD}â€¢ Total GIFs scanned:${NC} $total_gifs"
    echo -e "  ${BOLD}â€¢ Duplicate pairs found:${NC} ${YELLOW}$duplicate_count${NC}"
    echo -e "  ${BOLD}â€¢ Duplicate files:${NC} ${YELLOW}$unique_duplicate_gifs${NC}"
    echo -e "  ${BOLD}â€¢ Unique GIFs:${NC} $((total_gifs - unique_duplicate_gifs))"
    echo ""
    
    # Count detection methods
    declare -A method_counts
    for pair in "${duplicate_pairs[@]}"; do
        local rest="${pair#*|}"
        rest="${rest#*|}"
        local similarity_reason="${rest%%|*}"
        ((method_counts["$similarity_reason"]++))
    done
    
    echo -e "${BLUE}ðŸ” Detection breakdown by method:${NC}"
    [[ -n "${method_counts[exact_binary]}" ]] && echo -e "  ${GREEN}â€¢ Exact Binary Match:${NC} ${method_counts[exact_binary]} pairs"
    [[ -n "${method_counts[visual_identical]}" ]] && echo -e "  ${BLUE}â€¢ Visual Identical:${NC} ${method_counts[visual_identical]} pairs"
    [[ -n "${method_counts[content_fingerprint]}" ]] && echo -e "  ${CYAN}â€¢ Content Fingerprint:${NC} ${method_counts[content_fingerprint]} pairs"
    [[ -n "${method_counts[near_identical]}" ]] && echo -e "  ${YELLOW}â€¢ Near-Identical:${NC} ${method_counts[near_identical]} pairs"
    [[ -n "${method_counts[filename_property_match]}" ]] && echo -e "  ${CYAN}â€¢ Filename/Property Match:${NC} ${method_counts[filename_property_match]} pairs"
    echo ""
    
    # Calculate potential storage savings
    local potential_savings=0
    for pair in "${duplicate_pairs[@]}"; do
        local remove_file="${pair%%|*}"
        local remove_size="${gif_file_sizes[$remove_file]:-0}"
        [[ -n "$remove_size" && "$remove_size" -gt 0 ]] && potential_savings=$((potential_savings + remove_size))
    done
    
    echo -e "${GREEN}ðŸ’¾ Potential storage savings:${NC}"
    if [[ $potential_savings -gt 0 ]]; then
        local savings_mb=$((potential_savings / 1024 / 1024))
        local savings_gb=$((savings_mb / 1024))
        
        if [[ $savings_gb -gt 0 ]]; then
            echo -e "  ${BOLD}â€¢ Space to recover:${NC} ${GREEN}${savings_gb}GB${NC} (${savings_mb}MB)"
        else
            echo -e "  ${BOLD}â€¢ Space to recover:${NC} ${GREEN}${savings_mb}MB${NC}"
        fi
        echo -e "  ${BOLD}â€¢ Files to remove:${NC} $duplicate_count"
    fi
    echo ""
    
    # Simple deletion prompt
    echo -ne "${BOLD}Delete duplicate GIFs? (y/N): ${NC}"
    
    local choice
    read -r choice
    
    # Default to 'no' if empty or anything other than y/Y
    if [[ ! "$choice" =~ ^[Yy]$ ]]; then
        echo -e "${GREEN}âœ“ Keeping all files - no changes made${NC}"
        return 0
    fi
    
    # User chose yes - delete duplicate GIF files
    echo -e "\n${CYAN}ðŸ—‘ï¸  Deleting duplicate GIF files...${NC}\n"
    local deleted_count=0
    local skipped_count=0
    local freed_space=0
    declare -A already_deleted  # Track files already deleted to avoid duplicate attempts
    
    for pair in "${duplicate_pairs[@]}"; do
        local remove_file="${pair%%|*}"
        local temp_pair="${pair#*|}"
        local keep_file="${temp_pair%%|*}"
        temp_pair="${temp_pair#*|}"
        local similarity_reason="${temp_pair%%|*}"
        
        # Skip if already deleted
        if [[ -n "${already_deleted[$remove_file]:-}" ]]; then
            continue
        fi
        
        # Safety check: only delete GIF files
        if [[ "${remove_file##*.}" != "gif" ]]; then
            echo -e "    ${RED}âŒ SAFETY: Refusing to delete non-GIF file: $remove_file${NC}"
            continue
        fi
        
        # Safety check: don't delete if it looks like a video file
        if [[ "$remove_file" =~ \.(mp4|avi|mov|mkv|webm)$ ]]; then
            echo -e "    ${RED}âŒ SAFETY: Refusing to delete video file: $remove_file${NC}"
            continue
        fi
        
        # Extract basename (without extension) from both GIF files
        local remove_basename="$(basename -- "${remove_file%.*}")"
        local keep_basename="$(basename -- "${keep_file%.*}")"
        
        # Check if corresponding MP4/video source exists for the file we're about to delete
        local has_source_remove=false
        local has_source_keep=false
        local remove_source=""
        local keep_source=""
        
        # Get directory of the remove_file
        local remove_dir="$(dirname "$remove_file")"
        local keep_dir="$(dirname "$keep_file")"
        
        # Check for video source for remove_file
        for ext in mp4 avi mov mkv webm MP4 AVI MOV MKV WEBM; do
            if [[ -f "${remove_dir}/${remove_basename}.${ext}" ]]; then
                has_source_remove=true
                remove_source="${remove_dir}/${remove_basename}.${ext}"
                break
            fi
        done
        
        # Check for video source for keep_file
        for ext in mp4 avi mov mkv webm MP4 AVI MOV MKV WEBM; do
            if [[ -f "${keep_dir}/${keep_basename}.${ext}" ]]; then
                has_source_keep=true
                keep_source="${keep_dir}/${keep_basename}.${ext}"
                break
            fi
        done
        
        # Validation logic:
        # - If keep_file has a matching source but remove_file doesn't, safe to delete
        # - If both have matching sources, safe to delete (they're truly duplicates)
        # - If remove_file has a matching source but keep_file doesn't, DON'T delete (might delete the correct one)
        # - If neither has a source, consider it safe (orphaned duplicates)
        
        if [[ "$has_source_remove" == true && "$has_source_keep" == false ]]; then
            # Remove file has source, keep file doesn't - this is dangerous, skip
            echo -e "    ${YELLOW}âš ï¸  SKIPPED: $remove_file has source ($(basename -- "$remove_source")) but $keep_file doesn't${NC}"
            ((skipped_count++))
            DUPLICATE_STATS_SKIPPED=$((DUPLICATE_STATS_SKIPPED + 1))
            already_deleted["$remove_file"]=1
            continue
        fi
        
        # Additional property validation: Compare GIF properties with source video properties
        # SKIP property validation for exact binary matches (100% identical files)
        local property_mismatch=false
        local property_warning=""
        
        # Get comprehensive file properties for both files
        local remove_file_size=$(stat -c%s -- "$remove_file" 2>/dev/null || echo "0")
        local keep_file_size=$(stat -c%s -- "$keep_file" 2>/dev/null || echo "0")
        local remove_file_mtime=$(stat -c%Y -- "$remove_file" 2>/dev/null || echo "0")
        local keep_file_mtime=$(stat -c%Y -- "$keep_file" 2>/dev/null || echo "0")
        local remove_file_ctime=$(stat -c%Z "$remove_file" 2>/dev/null || echo "0")
        local keep_file_ctime=$(stat -c%Z "$keep_file" 2>/dev/null || echo "0")
        local remove_file_perms=$(stat -c%a "$remove_file" 2>/dev/null || echo "0")
        local keep_file_perms=$(stat -c%a "$keep_file" 2>/dev/null || echo "0")
        
        # For exact binary matches, skip property validation entirely (they're 100% identical)
        if [[ "$similarity_reason" == "exact_binary" ]]; then
            # Files are binary identical - safe to delete regardless of source video properties
            property_mismatch=false
        elif [[ "$has_source_remove" == true ]]; then
            # Get properties of remove_file and its source
            local remove_gif_frames="${gif_frame_counts[$remove_file]:-0}"
            local remove_gif_duration="${gif_durations[$remove_file]:-0}"
            local remove_gif_size="${gif_sizes[$remove_file]:-0}"
            
            # Get source video file properties
            local remove_source_size=$(stat -c%s -- "$remove_source" 2>/dev/null || echo "0")
            local remove_source_mtime=$(stat -c%Y -- "$remove_source" 2>/dev/null || echo "0")
            local remove_source_ctime=$(stat -c%Z "$remove_source" 2>/dev/null || echo "0")
            
            # Get source video properties
            local source_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 -- "$remove_source" 2>/dev/null | cut -d'.' -f1 || echo "0")
            local source_frames=$(ffprobe -v error -select_streams v:0 -show_entries stream=nb_frames -of default=noprint_wrappers=1:nokey=1 -- "$remove_source" 2>/dev/null || echo "0")
            
            # If source frames not available, estimate from duration and fps
            if [[ "$source_frames" == "0" || "$source_frames" == "N/A" ]]; then
                local source_fps=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 -- "$remove_source" 2>/dev/null | head -1 || echo "0/1")
                if [[ "$source_fps" =~ ^([0-9]+)/([0-9]+)$ ]]; then
                    local fps_num="${BASH_REMATCH[1]}"
                    local fps_den="${BASH_REMATCH[2]}"
                    if [[ $fps_den -gt 0 && $source_duration -gt 0 ]]; then
                        source_frames=$((fps_num * source_duration / fps_den))
                    fi
                fi
            fi
            
            # Intelligent timestamp validation: GIF should be created AFTER source video
            # If GIF is older than source video, it can't be derived from it
            if [[ $remove_file_mtime -gt 0 && $remove_source_mtime -gt 0 ]]; then
                if [[ $remove_file_mtime -lt $remove_source_mtime ]]; then
                    # GIF was modified before the source video - suspicious
                    local time_diff=$((remove_source_mtime - remove_file_mtime))
                    if [[ $time_diff -gt 60 ]]; then  # More than 1 minute older
                        property_mismatch=true
                        property_warning="GIF is older than source video (by ${time_diff}s)"
                    fi
                fi
            fi
            
            # Check if GIF properties match source video (with tolerance)
            if [[ $remove_gif_duration -gt 0 && $source_duration -gt 0 ]]; then
                local duration_diff=$(( (remove_gif_duration > source_duration ? remove_gif_duration - source_duration : source_duration - remove_gif_duration) ))
                local duration_ratio=0
                if [[ $source_duration -gt 0 ]]; then
                    duration_ratio=$((duration_diff * 100 / source_duration))
                fi
                
                # If duration differs by more than 20%, flag it
                if [[ $duration_ratio -gt 20 ]]; then
                    property_mismatch=true
                    property_warning="${property_warning:+$property_warning; }Duration mismatch: GIF=${remove_gif_duration}s vs Source=${source_duration}s"
                fi
            fi
            
            # Intelligent size validation: GIF should be smaller than source video
            # If GIF is larger than source, something is wrong
            if [[ $remove_gif_size -gt 0 && $remove_source_size -gt 0 ]]; then
                if [[ $remove_gif_size -gt $remove_source_size ]]; then
                    property_mismatch=true
                    property_warning="${property_warning:+$property_warning; }GIF larger than source (GIF=$(numfmt --to=iec $remove_gif_size 2>/dev/null || echo ${remove_gif_size}) vs Source=$(numfmt --to=iec $remove_source_size 2>/dev/null || echo ${remove_source_size}))"
                fi
            fi
            
            # Check frame count similarity (more lenient, GIFs typically have fewer frames)
            if [[ $remove_gif_frames -gt 0 && $source_frames -gt 0 ]]; then
                # GIFs should have fewer frames than source (due to frame rate reduction)
                # Flag only if GIF has MORE frames than source (suspicious)
                if [[ $remove_gif_frames -gt $((source_frames * 120 / 100)) ]]; then
                    property_mismatch=true
                    property_warning="${property_warning:+$property_warning; }Frame count suspicious: GIF=${remove_gif_frames} vs Source=${source_frames}"
                fi
            fi
            
            # If properties don't match, it might not be derived from this source
            if [[ "$property_mismatch" == true ]]; then
                echo -e "    ${YELLOW}âš ï¸  SKIPPED: $remove_file properties don't match source $(basename -- "$remove_source")${NC}"
                echo -e "    ${GRAY}   $property_warning${NC}"
                ((skipped_count++))
                DUPLICATE_STATS_SKIPPED=$((DUPLICATE_STATS_SKIPPED + 1))
                already_deleted["$remove_file"]=1
                continue
            fi
        fi
        
        # Similar validation for keep_file if it has a source
        if [[ "$has_source_keep" == true ]]; then
            local keep_gif_frames="${gif_frame_counts[$keep_file]:-0}"
            local keep_gif_duration="${gif_durations[$keep_file]:-0}"
            local keep_gif_size="${gif_sizes[$keep_file]:-0}"
            
            # Get source video file properties
            local keep_source_size=$(stat -c%s -- "$keep_source" 2>/dev/null || echo "0")
            local keep_source_mtime=$(stat -c%Y -- "$keep_source" 2>/dev/null || echo "0")
            local keep_source_ctime=$(stat -c%Z "$keep_source" 2>/dev/null || echo "0")
            
            local keep_source_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 -- "$keep_source" 2>/dev/null | cut -d'.' -f1 || echo "0")
            local keep_source_frames=$(ffprobe -v error -select_streams v:0 -show_entries stream=nb_frames -of default=noprint_wrappers=1:nokey=1 -- "$keep_source" 2>/dev/null || echo "0")
            
            # Estimate frames if not available
            if [[ "$keep_source_frames" == "0" || "$keep_source_frames" == "N/A" ]]; then
                local keep_source_fps=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 -- "$keep_source" 2>/dev/null | head -1 || echo "0/1")
                if [[ "$keep_source_fps" =~ ^([0-9]+)/([0-9]+)$ ]]; then
                    local fps_num="${BASH_REMATCH[1]}"
                    local fps_den="${BASH_REMATCH[2]}"
                    if [[ $fps_den -gt 0 && $keep_source_duration -gt 0 ]]; then
                        keep_source_frames=$((fps_num * keep_source_duration / fps_den))
                    fi
                fi
            fi
            
            # Validate keep_file properties
            local keep_property_valid=true
            
            # Check timestamp relationship
            if [[ $keep_file_mtime -gt 0 && $keep_source_mtime -gt 0 ]]; then
                if [[ $keep_file_mtime -lt $keep_source_mtime ]]; then
                    local keep_time_diff=$((keep_source_mtime - keep_file_mtime))
                    if [[ $keep_time_diff -gt 60 ]]; then
                        keep_property_valid=false
                        echo -e "    ${YELLOW}âš ï¸  WARNING: Keep file $keep_file is older than source $(basename -- "$keep_source") (by ${keep_time_diff}s)${NC}"
                    fi
                fi
            fi
            
            # Check size relationship
            if [[ $keep_gif_size -gt 0 && $keep_source_size -gt 0 ]]; then
                if [[ $keep_gif_size -gt $keep_source_size ]]; then
                    keep_property_valid=false
                    echo -e "    ${YELLOW}âš ï¸  WARNING: Keep file $keep_file is larger than source $(basename -- "$keep_source")${NC}"
                    echo -e "    ${GRAY}   Size: GIF=$(numfmt --to=iec $keep_gif_size 2>/dev/null || echo $keep_gif_size) vs Source=$(numfmt --to=iec $keep_source_size 2>/dev/null || echo $keep_source_size)${NC}"
                fi
            fi
            
            if [[ $keep_gif_duration -gt 0 && $keep_source_duration -gt 0 ]]; then
                local keep_duration_diff=$(( (keep_gif_duration > keep_source_duration ? keep_gif_duration - keep_source_duration : keep_source_duration - keep_gif_duration) ))
                local keep_duration_ratio=0
                if [[ $keep_source_duration -gt 0 ]]; then
                    keep_duration_ratio=$((keep_duration_diff * 100 / keep_source_duration))
                fi
                
                if [[ $keep_duration_ratio -gt 20 ]]; then
                    keep_property_valid=false
                    echo -e "    ${YELLOW}âš ï¸  WARNING: Keep file $keep_file also has property mismatch with source $(basename -- "$keep_source")${NC}"
                    echo -e "    ${GRAY}   Duration: GIF=${keep_gif_duration}s vs Source=${keep_source_duration}s${NC}"
                fi
            fi
            
            # Check keep_file frame count
            if [[ $keep_gif_frames -gt 0 && $keep_source_frames -gt 0 ]]; then
                if [[ $keep_gif_frames -gt $((keep_source_frames * 120 / 100)) ]]; then
                    keep_property_valid=false
                    echo -e "    ${YELLOW}âš ï¸  WARNING: Keep file $keep_file has suspicious frame count${NC}"
                    echo -e "    ${GRAY}   Frames: GIF=${keep_gif_frames} vs Source=${keep_source_frames}${NC}"
                fi
            fi
        fi
        
        # Comparative quality analysis: Compare the two files intelligently
        local quality_info=""
        
        # Calculate quality indicators
        if [[ $remove_file_size -gt 0 && $keep_file_size -gt 0 ]]; then
            local size_diff=$((keep_file_size - remove_file_size))
            local size_diff_human=$(numfmt --to=iec $((size_diff > 0 ? size_diff : -size_diff)) 2>/dev/null || echo "${size_diff}B")
            
            if [[ $size_diff -gt 0 ]]; then
                quality_info="keep is ${size_diff_human} larger"
            elif [[ $size_diff -lt 0 ]]; then
                quality_info="remove was ${size_diff_human} larger"
            else
                quality_info="same size"
            fi
        fi
        
        # Add modification date comparison
        if [[ $remove_file_mtime -gt 0 && $keep_file_mtime -gt 0 ]]; then
            local time_diff=$((keep_file_mtime - remove_file_mtime))
            if [[ $time_diff -gt 0 ]]; then
                local days=$((time_diff / 86400))
                local hours=$(( (time_diff % 86400) / 3600 ))
                if [[ $days -gt 0 ]]; then
                    quality_info="${quality_info:+$quality_info, }keep is ${days}d ${hours}h newer"
                elif [[ $hours -gt 0 ]]; then
                    quality_info="${quality_info:+$quality_info, }keep is ${hours}h newer"
                else
                    quality_info="${quality_info:+$quality_info, }keep is ${time_diff}s newer"
                fi
            elif [[ $time_diff -lt 0 ]]; then
                local abs_time_diff=$((time_diff * -1))
                local days=$((abs_time_diff / 86400))
                local hours=$(( (abs_time_diff % 86400) / 3600 ))
                if [[ $days -gt 0 ]]; then
                    quality_info="${quality_info:+$quality_info, }remove was ${days}d ${hours}h newer"
                elif [[ $hours -gt 0 ]]; then
                    quality_info="${quality_info:+$quality_info, }remove was ${hours}h newer"
                else
                    quality_info="${quality_info:+$quality_info, }remove was ${abs_time_diff}s newer"
                fi
            else
                quality_info="${quality_info:+$quality_info, }same modification time"
            fi
        fi
        
        # Add permission comparison if different
        if [[ "$remove_file_perms" != "$keep_file_perms" ]]; then
            quality_info="${quality_info:+$quality_info, }perms: remove=$remove_file_perms keep=$keep_file_perms"
        fi
        
        if [[ -f "$remove_file" ]] && rm -f "$remove_file" 2>/dev/null; then
            # Track space saved
            DUPLICATE_STATS_SPACE_SAVED=$((DUPLICATE_STATS_SPACE_SAVED + remove_file_size))
            DUPLICATE_STATS_DELETED=$((DUPLICATE_STATS_DELETED + 1))
            freed_space=$((freed_space + remove_file_size))
            
            echo -e "  ${RED}âŒ Deleting: $(basename -- "$remove_file")${NC}"
            ((deleted_count++))
            already_deleted["$remove_file"]=1  # Mark as deleted
            
            # ðŸ§  Train AI from user's GIF delete decision
            local detection_level="LEVEL1"
            case "$similarity_reason" in
                "exact_binary") detection_level="LEVEL1" ;;
                "visual_identical") detection_level="LEVEL2" ;;
                "content_fingerprint") detection_level="LEVEL3" ;;
                "near_identical") detection_level="LEVEL4" ;;
                *) detection_level="LEVEL5" ;;
            esac
            train_ai_from_decision "$keep_file" "$remove_file" "90" "delete_file1" "$detection_level"
            
            # Log the deletion with comprehensive properties
            {
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] DUPLICATE GIF DELETED:"
                echo "  Removed: $remove_file"
                echo "    Size: $(numfmt --to=iec $remove_file_size 2>/dev/null || echo ${remove_file_size}B)"
                echo "    Modified: $(date -d @$remove_file_mtime '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown')"
                echo "    Created: $(date -d @$remove_file_ctime '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown')"
                echo "    Permissions: $remove_file_perms"
                echo "    Source: ${remove_source:-none}"
                echo "  Kept: $keep_file"
                echo "    Size: $(numfmt --to=iec $keep_file_size 2>/dev/null || echo ${keep_file_size}B)"
                echo "    Modified: $(date -d @$keep_file_mtime '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown')"
                echo "    Created: $(date -d @$keep_file_ctime '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo 'unknown')"
                echo "    Permissions: $keep_file_perms"
                echo "    Source: ${keep_source:-none}"
                echo "  Analysis: $quality_info"
                echo ""
            } >> "$CONVERSION_LOG" 2>/dev/null || true
        else
            echo -e "    ${RED}âŒ Failed to delete: $remove_file${NC}"
            already_deleted["$remove_file"]=1  # Mark as attempted to avoid repeated failures
        fi
    done
    
    # Show simple summary
    local freed_mb=$((freed_space / 1024 / 1024))
    echo -e "\n${GREEN}âœ“ Deletion complete${NC}"
    echo -e "  ${BOLD}Deleted: $deleted_count files${NC}"
    if [[ $skipped_count -gt 0 ]]; then
        echo -e "  ${BOLD}Skipped: $skipped_count files${NC} ${GRAY}(ambiguous source mapping)${NC}"
    fi
    echo -e "  ${BOLD}Space freed: ${freed_mb}MB${NC}"
    
    # ðŸ§  Show AI learning progress after GIF deletion
    [[ $deleted_count -gt 0 ]] && show_ai_training_stats
    
    fi  # End of if false - old GIF sequential code disabled
    
    # Show comprehensive statistical summary
    show_duplicate_detection_statistics
    
    echo ""
}

# ðŸ“Š Comprehensive Statistical Summary for Duplicate Detection
show_duplicate_detection_statistics() {
    echo -e "\n  ${CYAN}${BOLD}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
    echo -e "  ${CYAN}${BOLD}â”‚           ðŸ“Š DUPLICATE DETECTION STATISTICS           â”‚${NC}"
    echo -e "  ${CYAN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}\n"
    
    # Detection Method Breakdown
    echo -e "  ${BLUE}${BOLD}ðŸ” Detection Methods Used:${NC}"
    local total_detected=$((DUPLICATE_STATS_EXACT_BINARY + DUPLICATE_STATS_VISUAL_IDENTICAL + DUPLICATE_STATS_CONTENT_FINGERPRINT + DUPLICATE_STATS_NEAR_IDENTICAL))
    
    if [[ $total_detected -gt 0 ]]; then
        if [[ $DUPLICATE_STATS_EXACT_BINARY -gt 0 ]]; then
            local exact_pct=$((DUPLICATE_STATS_EXACT_BINARY * 100 / total_detected))
            echo -e "    ${GREEN}âœ“ Exact Binary Match:     ${BOLD}$DUPLICATE_STATS_EXACT_BINARY${NC} ${GREEN}duplicates (${exact_pct}%)${NC}"
        fi
        if [[ $DUPLICATE_STATS_VISUAL_IDENTICAL -gt 0 ]]; then
            local visual_pct=$((DUPLICATE_STATS_VISUAL_IDENTICAL * 100 / total_detected))
            echo -e "    ${BLUE}âœ“ Visual Identical:        ${BOLD}$DUPLICATE_STATS_VISUAL_IDENTICAL${NC} ${BLUE}duplicates (${visual_pct}%)${NC}"
        fi
        if [[ $DUPLICATE_STATS_CONTENT_FINGERPRINT -gt 0 ]]; then
            local content_pct=$((DUPLICATE_STATS_CONTENT_FINGERPRINT * 100 / total_detected))
            echo -e "    ${CYAN}âœ“ Content Fingerprint:     ${BOLD}$DUPLICATE_STATS_CONTENT_FINGERPRINT${NC} ${CYAN}duplicates (${content_pct}%)${NC}"
        fi
        if [[ $DUPLICATE_STATS_NEAR_IDENTICAL -gt 0 ]]; then
            local near_pct=$((DUPLICATE_STATS_NEAR_IDENTICAL * 100 / total_detected))
            echo -e "    ${YELLOW}âœ“ Near-Identical:          ${BOLD}$DUPLICATE_STATS_NEAR_IDENTICAL${NC} ${YELLOW}duplicates (${near_pct}%)${NC}"
        fi
    else
        echo -e "    ${GRAY}â€¢ No duplicates detected${NC}"
    fi
    
    # Space Savings
    echo -e "\n  ${MAGENTA}${BOLD}ðŸ’¾ Space Optimization:${NC}"
    if [[ $DUPLICATE_STATS_SPACE_SAVED -gt 0 ]]; then
        local space_mb=$((DUPLICATE_STATS_SPACE_SAVED / 1024 / 1024))
        local space_human=$(numfmt --to=iec $DUPLICATE_STATS_SPACE_SAVED 2>/dev/null || echo "${space_mb}MB")
        echo -e "    ${GREEN}âœ“ Space Saved:             ${BOLD}$space_human${NC} ${GREEN}freed${NC}"
        echo -e "    ${GREEN}âœ“ Files Deleted:           ${BOLD}$DUPLICATE_STATS_DELETED${NC} ${GREEN}duplicates${NC}"
        
        if [[ $DUPLICATE_STATS_DELETED -gt 0 ]]; then
            local avg_size=$((DUPLICATE_STATS_SPACE_SAVED / DUPLICATE_STATS_DELETED))
            local avg_human=$(numfmt --to=iec $avg_size 2>/dev/null || echo "${avg_size}B")
            echo -e "    ${GRAY}â€¢ Average file size:       ${avg_human} per duplicate${NC}"
        fi
    else
        echo -e "    ${GRAY}â€¢ No space saved (no duplicates deleted)${NC}"
    fi
    
    # Checksum Cache Performance
    echo -e "\n  ${CYAN}${BOLD}ðŸ” Checksum Cache Performance:${NC}"
    local total_lookups=$((DUPLICATE_STATS_CACHE_HITS + DUPLICATE_STATS_CACHE_MISSES))
    if [[ $total_lookups -gt 0 ]]; then
        local hit_rate=$((DUPLICATE_STATS_CACHE_HITS * 100 / total_lookups))
        echo -e "    ${GREEN}âœ“ Cache Hits:              ${BOLD}$DUPLICATE_STATS_CACHE_HITS${NC} ${GREEN}(${hit_rate}%)${NC}"
        echo -e "    ${YELLOW}â€¢ Cache Misses:            ${BOLD}$DUPLICATE_STATS_CACHE_MISSES${NC} ${YELLOW}(calculated)${NC}"
        echo -e "    ${BLUE}â€¢ Total Lookups:           ${BOLD}$total_lookups${NC}"
        
        # Calculate time saved (rough estimate: 500ms per cached checksum)
        local time_saved_ms=$((DUPLICATE_STATS_CACHE_HITS * 500))
        local time_saved_sec=$((time_saved_ms / 1000))
        if [[ $time_saved_sec -gt 60 ]]; then
            local time_saved_min=$((time_saved_sec / 60))
            echo -e "    ${MAGENTA}â€¢ Estimated time saved:    ~${time_saved_min} minutes${NC}"
        elif [[ $time_saved_sec -gt 0 ]]; then
            echo -e "    ${MAGENTA}â€¢ Estimated time saved:    ~${time_saved_sec} seconds${NC}"
        fi
    else
        echo -e "    ${GRAY}â€¢ No cache lookups performed${NC}"
    fi
    
    # Actions Taken
    echo -e "\n  ${YELLOW}${BOLD}ðŸŽ¯ Actions Summary:${NC}"
    if [[ $DUPLICATE_STATS_SKIPPED -gt 0 ]]; then
        echo -e "    ${YELLOW}âš ï¸  Skipped:                  ${BOLD}$DUPLICATE_STATS_SKIPPED${NC} ${YELLOW}files (ambiguous or property mismatch)${NC}"
    fi
    if [[ $DUPLICATE_STATS_DELETED -gt 0 ]]; then
        echo -e "    ${GREEN}âœ“ Deleted:                 ${BOLD}$DUPLICATE_STATS_DELETED${NC} ${GREEN}duplicate files${NC}"
    fi
    if [[ $DUPLICATE_STATS_DELETED -eq 0 && $DUPLICATE_STATS_SKIPPED -eq 0 && $total_detected -eq 0 ]]; then
        echo -e "    ${GREEN}âœ“ No duplicates found - collection is optimal!${NC}"
    fi
    
    # Duplicate Pattern Analysis
    if [[ $total_detected -gt 0 ]]; then
        echo -e "\n  ${BLUE}${BOLD}ðŸ§  Pattern Analysis:${NC}"
        if [[ $DUPLICATE_STATS_EXACT_BINARY -gt $((total_detected / 2)) ]]; then
            echo -e "    ${CYAN}â€¢ Most duplicates are exact copies${NC}"
            echo -e "    ${GRAY}  â†’ Recommendation: Check for copy/paste patterns in your workflow${NC}"
        fi
        if [[ $DUPLICATE_STATS_VISUAL_IDENTICAL -gt 0 ]]; then
            echo -e "    ${CYAN}â€¢ Some files have identical visual content but different binary data${NC}"
            echo -e "    ${GRAY}  â†’ Recommendation: These may be re-conversions of the same source${NC}"
        fi
        if [[ $DUPLICATE_STATS_NEAR_IDENTICAL -gt 0 ]]; then
            echo -e "    ${CYAN}â€¢ Near-identical files detected (may need manual review)${NC}"
            echo -e "    ${GRAY}  â†’ Recommendation: Consider consolidating similar content${NC}"
        fi
        if [[ $DUPLICATE_STATS_SKIPPED -gt $((DUPLICATE_STATS_DELETED / 2)) && $DUPLICATE_STATS_SKIPPED -gt 0 ]]; then
            echo -e "    ${YELLOW}â€¢ High skip rate suggests filename mismatches${NC}"
            echo -e "    ${GRAY}  â†’ Recommendation: Ensure GIFs match their source video filenames${NC}"
        fi
    fi
    
    # Tips for preventing future duplicates
    if [[ $total_detected -gt 2 ]]; then
        echo -e "\n  ${GREEN}${BOLD}ðŸ’¡ Tips to Prevent Future Duplicates:${NC}"
        echo -e "    ${GRAY}1. Always name GIFs to match source video filenames${NC}"
        echo -e "    ${GRAY}2. Use version control for your media files${NC}"
        echo -e "    ${GRAY}3. Run duplicate detection regularly (cache makes it fast!)${NC}"
        echo -e "    ${GRAY}4. Avoid manual file copying - use the converter instead${NC}"
    fi
    
    echo -e "\n  ${CYAN}${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
}

# ðŸ” Advanced pre-conversion validation with intelligent duplicate prevention
perform_pre_conversion_validation() {
    echo -e "${CYAN}${BOLD}ðŸ” ADVANCED PRE-CONVERSION VALIDATION${NC}\\\\n"
    
    # ðŸ“ STEP -1: Filename scan (runs first, fastest check)
    # This must run before everything else to ensure files can be processed
    local dummy_array=()
    fix_problematic_filenames dummy_array
    
    # Check for interrupt after filename scan
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        echo -e "\\\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
        return 1
    fi
    
    # âš ï¸ USER PROMPT 1: Ask about VIDEO duplicate detection
    if [[ -z "${VIDEO_DUPLICATE_DETECTION_CONFIRMED:-}" ]]; then
        echo ""
        echo -e "${YELLOW}${BOLD}âš ï¸  VIDEO DUPLICATE DETECTION${NC}"
        echo ""
        echo -e "${CYAN}ðŸ“Š What is Video Duplicate Detection?${NC}"
        echo -e "  Scan for duplicate MP4 videos ${BOLD}before${NC} conversion."
        echo -e "  This helps you:"
        echo -e "    ${GREEN}âœ“${NC} Avoid converting the same video multiple times"
        echo -e "    ${GREEN}âœ“${NC} Save disk space by removing duplicate source files"
        echo -e "    ${GREEN}âœ“${NC} Keep your video collection organized"
        echo ""
        echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
        echo -e "  â€¢ First run: ~2-5 minutes (builds analysis cache)"
        echo -e "  â€¢ Subsequent runs: ~30 seconds (uses cached data)"
        echo -e "  â€¢ Uses fast hash-based comparison (MD5 + metadata + visual)"
        echo ""
        echo -e "${CYAN}ðŸŽ¯ When to run:${NC}"
        echo -e "  ${GREEN}âœ“${NC} You suspect duplicate videos in your collection"
        echo -e "  ${GREEN}âœ“${NC} You've copied/moved video files and may have duplicates"
        echo -e "  ${GREEN}âœ“${NC} You want to optimize disk space before conversion"
        echo ""
        echo -e "${CYAN}âš¡ When to skip:${NC}"
        echo -e "  ${YELLOW}â†’${NC} You're certain you have no duplicate videos"
        echo -e "  ${YELLOW}â†’${NC} You're in a hurry and want to convert immediately"
        echo ""
        echo -ne "${BOLD}Scan for duplicate videos? (y/N): ${NC}"
        read -r video_dup_response
        
        if [[ "$video_dup_response" =~ ^[Yy]$ ]]; then
            VIDEO_DUPLICATE_DETECTION_CONFIRMED="yes"
            echo -e "${GREEN}âœ“ Video duplicate detection enabled${NC}"
            echo ""
        else
            VIDEO_DUPLICATE_DETECTION_CONFIRMED="no"
            echo -e "${YELLOW}â© Skipping video duplicate detection${NC}"
            echo ""
        fi
    fi
    
    # Run video duplicate detection if user confirmed
    if [[ "${VIDEO_DUPLICATE_DETECTION_CONFIRMED}" == "yes" ]]; then
        echo -e "${BLUE}Step 0: Duplicate MP4 Video Detection${NC}"
        detect_duplicate_videos
        echo ""
        
        # Check for interrupt after video detection
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\\\\\\\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
            return 1
        fi
        
        # Step 0.5: Check for corrupted videos
        echo -e "${BLUE}Step 0.5: Video Corruption Detection${NC}"
        detect_corrupted_videos
        echo ""
        
        # Check for interrupt after video corruption check
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\\\\\\\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
            return 1
        fi
        
        # After video detection completes, always ask about GIF detection
        # (Reset the flag to ensure prompt is shown)
        unset GIF_DUPLICATE_DETECTION_CONFIRMED
    fi
    
    # âš ï¸ USER PROMPT 2: Ask about GIF duplicate detection
    # This prompt shows after video detection OR if video detection was skipped
    if [[ -z "${GIF_DUPLICATE_DETECTION_CONFIRMED:-}" ]]; then
        echo ""
        echo -e "${YELLOW}${BOLD}âš ï¸  GIF DUPLICATE DETECTION${NC}"
        echo ""
        echo -e "${CYAN}ðŸ“Š What is GIF Duplicate Detection?${NC}"
        echo -e "  Scan for duplicate GIF files ${BOLD}already converted${NC}."
        echo -e "  This helps you:"
        echo -e "    ${GREEN}âœ“${NC} Remove duplicate converted files"
        echo -e "    ${GREEN}âœ“${NC} Save disk space by cleaning up redundant GIFs"
        echo -e "    ${GREEN}âœ“${NC} Keep your GIF collection organized"
        echo ""
        echo -e "${CYAN}â±ï¸  Time Investment:${NC}"
        echo -e "  â€¢ First run: ~1-3 minutes (builds analysis cache)"
        echo -e "  â€¢ Subsequent runs: ~15 seconds (uses cached data)"
        echo -e "  â€¢ Uses fast hash-based comparison (MD5 + visual fingerprints)"
        echo ""
        echo -e "${CYAN}ðŸŽ¯ When to run:${NC}"
        echo -e "  ${GREEN}âœ“${NC} You suspect duplicate GIFs in your collection"
        echo -e "  ${GREEN}âœ“${NC} You've converted the same videos multiple times"
        echo -e "  ${GREEN}âœ“${NC} You want to clean up your GIF library"
        echo ""
        echo -e "${CYAN}âš¡ When to skip:${NC}"
        echo -e "  ${YELLOW}â†’${NC} You're certain you have no duplicate GIFs"
        echo -e "  ${YELLOW}â†’${NC} You want to proceed directly to conversion"
        echo ""
        echo -ne "${BOLD}Scan for duplicate GIFs? (y/N): ${NC}"
        read -r gif_dup_response
        
        if [[ "$gif_dup_response" =~ ^[Yy]$ ]]; then
            GIF_DUPLICATE_DETECTION_CONFIRMED="yes"
            echo -e "${GREEN}âœ“ GIF duplicate detection enabled${NC}"
            echo ""
        else
            GIF_DUPLICATE_DETECTION_CONFIRMED="no"
            echo -e "${YELLOW}â© Skipping GIF duplicate detection${NC}"
            echo ""
        fi
    fi
    
    # Run GIF duplicate detection if user confirmed
    if [[ "${GIF_DUPLICATE_DETECTION_CONFIRMED}" == "yes" ]]; then
        echo -e "${BLUE}Step 1: Duplicate GIF Detection${NC}"
        detect_duplicate_gifs
        echo ""
        
        # Check for interrupt after GIF detection
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
            return 1
        fi
    fi
    
    # If both were skipped, go straight to conversion planning
    if [[ "${VIDEO_DUPLICATE_DETECTION_CONFIRMED}" == "no" && "${GIF_DUPLICATE_DETECTION_CONFIRMED}" == "no" ]]; then
        echo -e "${BLUE}Quick Validation: Video-to-GIF Mapping${NC}"
        analyze_video_gif_mapping
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            return 1
        fi
        echo -e "${BLUE}Conversion Planning${NC}"
        generate_conversion_plan
        return 0
    fi
    
    # Check for interrupt after Step 1
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        echo -e "\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
        return 1
    fi
    
    # Step 2: Check for corrupted GIFs and offer to fix them  
    echo -e "${BLUE}Step 2: Corruption Detection${NC}"
    detect_corrupted_gifs
    
    # Check for interrupt after Step 2
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        echo -e "\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
        return 1
    fi
    
    # Step 3: Advanced video-to-GIF mapping analysis
    echo -e "${BLUE}Step 3: Video-to-GIF Mapping Analysis${NC}"
    analyze_video_gif_mapping
    
    # Check for interrupt after Step 3
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        echo -e "\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
        return 1
    fi
    
    # Step 4: Show intelligent conversion recommendations
    echo -e "${BLUE}Step 4: Conversion Planning${NC}"
    generate_conversion_plan
    
    # Check for interrupt after Step 4
    if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
        echo -e "\\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
        return 1
    fi
    
    echo -e "\\n  ${GREEN}âœ“ Advanced validation completed${NC}\\n"
    return 0
}

# ðŸŽ¯ Analyze video-to-GIF mapping and detect existing conversions
analyze_video_gif_mapping() {
    declare -A video_files
    declare -A gif_files
    declare -A video_to_gif_map
    declare -A orphaned_gifs
    declare -gA conversion_needed  # Make global so other functions can access it
    
    local total_videos=0
    local total_gifs=0
    local already_converted=0
    local need_conversion=0
    local orphaned_count=0
    
    # Scan all video files with progress
    echo -e "  ${CYAN}ðŸ” Scanning video files...${NC}"
    shopt -s nullglob
    local video_list=(*.mp4 *.avi *.mov *.mkv *.webm)
    local video_count=${#video_list[@]}
    
    for video in "${video_list[@]}"; do
        [[ -f "$video" ]] || continue
        local basename="${video%.*}"
        video_files["$basename"]="$video"
        ((total_videos++))
        
        # Truncate filename if too long
        local display_name="$(basename -- "$video")"
        if [[ ${#display_name} -gt 50 ]]; then
            display_name="${display_name:0:47}..."
        fi
        
        # Show progress bar on first line
        local progress=$((total_videos * 100 / video_count))
        printf "\r\033[K  ${CYAN}["
        local filled=$((progress * 20 / 100))
        for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((i=filled; i<20; i++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}Scanned %d/%d${NC}" "$progress" "$total_videos" "$video_count"
        
        # Show current file on second line
        printf "\n  ${GRAY}ðŸ“„ %s${NC}" "$display_name"
        printf "\r\033[1A"  # Move cursor back up to progress bar line
    done
    printf "\r\033[K  ${CYAN}["
    for ((i=0; i<20; i++)); do printf "${GREEN}â–ˆ${NC}"; done
    printf "${CYAN}] ${BOLD}100%%${NC} ${BLUE}Scanned %d videos${NC}\n" "$total_videos"
    printf "\033[K\n"  # Clear the file name line
    
    # Scan GIF files - ONLY in OUTPUT_DIRECTORY if configured
    echo -e "  ${CYAN}ðŸ” Scanning GIF files...${NC}"
    shopt -s nullglob
    
    # Determine where to scan for GIFs
    if [[ -d "$OUTPUT_DIRECTORY" && "$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd)" != "$(pwd)" ]]; then
        # OUTPUT_DIRECTORY is configured and different - scan ONLY there
        echo -e "  ${BLUE}ðŸ“‚ Scanning output directory: $OUTPUT_DIRECTORY${NC}"
        for gif in "$OUTPUT_DIRECTORY"/*.gif; do
            [[ -f "$gif" ]] || continue
            local basename="$(basename -- "${gif%.*}")"
            gif_files["$basename"]="$gif"
            ((total_gifs++))
        done
    else
        # No separate output directory - scan current dir
        echo -e "  ${GRAY}ðŸ“‚ Scanning current directory${NC}"
        for gif in *.gif; do
            [[ -f "$gif" ]] || continue
            local basename="${gif%.*}"
            gif_files["$basename"]="$gif"
            ((total_gifs++))
        done
    fi
    shopt -u nullglob
    
    if [[ $total_videos -eq 0 ]]; then
        echo -e "  ${RED}âŒ No video files found${NC}"
        return 1
    fi
    
    # Analyze mappings with progress
    echo -e "  ${CYAN}ðŸ” Analyzing video-GIF mappings...${NC}"
    local analyzed=0
    local total_to_analyze=$total_videos
    
    for basename in "${!video_files[@]}"; do
        local video_file="${video_files[$basename]}"
        local expected_gif="${basename}.gif"
        ((analyzed++))
        
        # Truncate filename if too long
        local display_name="$(basename -- "$video_file")"
        if [[ ${#display_name} -gt 50 ]]; then
            display_name="${display_name:0:47}..."
        fi
        
        # Show progress bar on first line
        local progress=$((analyzed * 100 / total_to_analyze))
        printf "\r\033[K  ${CYAN}["
        local filled=$((progress * 20 / 100))
        for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
        for ((i=filled; i<20; i++)); do printf "${GRAY}â–‘${NC}"; done
        printf "${CYAN}] ${BOLD}%3d%%${NC} ${BLUE}Analyzed %d/%d${NC}" "$progress" "$analyzed" "$total_to_analyze"
        
        # Show current file on second line
        printf "\n  ${GRAY}ðŸ” %s${NC}" "$display_name"
        printf "\r\033[1A"  # Move cursor back up to progress bar line
        
        if [[ -n "${gif_files[$basename]:-}" ]]; then
            # Found corresponding GIF
            local gif_file="${gif_files[$basename]}"
            video_to_gif_map["$video_file"]="$gif_file"
            
            # Check if GIF is up-to-date
            local video_time=$(stat -c %Y -- "$video_file" 2>/dev/null || echo "0")
            local gif_time=$(stat -c %Y -- "$gif_file" 2>/dev/null || echo "0")
            
            if [[ $video_time -gt $gif_time ]]; then
                # Video is newer, needs re-conversion
                conversion_needed["$video_file"]="outdated"
                ((need_conversion++))
            else
                # GIF is up-to-date
                ((already_converted++))
            fi
        else
            # No corresponding GIF found
            conversion_needed["$video_file"]="missing"
            ((need_conversion++))
        fi
    done
    printf "\n"
    
    # Find orphaned GIFs (GIFs without corresponding video files)
    for basename in "${!gif_files[@]}"; do
        if [[ -z "${video_files[$basename]:-}" ]]; then
            local gif_file="${gif_files[$basename]}"
            orphaned_gifs["$gif_file"]="orphan"
            ((orphaned_count++))
        fi
    done
    
    # Display analysis results
    echo -e "  ${GREEN}âœ“ Analysis Results:${NC}"
    echo -e "    ${YELLOW}ðŸ“¹ Total video files: ${BOLD}$total_videos${NC}"
    echo -e "    ${BLUE}ðŸŽ¨ Total GIF files: ${BOLD}$total_gifs${NC}"
    echo -e "    ${GREEN}âœ… Already converted: ${BOLD}$already_converted${NC}"
    echo -e "    ${CYAN}ðŸ”„ Need conversion: ${BOLD}$need_conversion${NC}"
    
    if [[ $orphaned_count -gt 0 ]]; then
        echo -e "    ${YELLOW}ðŸ” Orphaned GIFs: ${BOLD}$orphaned_count${NC}"
    fi
    
    # Only show summary - no verbose file listings
    echo ""
    
    if [[ $orphaned_count -gt 0 ]]; then
        echo -e "\n  ${YELLOW}ðŸ” Orphaned GIFs (no matching video):${NC}"
        for gif_file in "${!orphaned_gifs[@]}"; do
            local gif_size=$(stat -c%s -- "$gif_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "?")
            echo -e "    ${YELLOW}ðŸŽ¨ $(basename -- "$gif_file") ($gif_size) â†’ ${GRAY}[no video]${NC}"
        done
        
        if [[ $orphaned_count -gt 2 ]]; then
            echo -ne "\n  ${MAGENTA}Clean up orphaned GIFs? [y/N]: ${NC}"
            local cleanup_orphans
            read -r cleanup_orphans
            if [[ "$cleanup_orphans" =~ ^[Yy]$ ]]; then
                cleanup_orphaned_gifs
            fi
        fi
    fi
    
    # Store results for use in conversion planning
    VALIDATION_TOTAL_VIDEOS=$total_videos
    VALIDATION_ALREADY_CONVERTED=$already_converted
    VALIDATION_NEED_CONVERSION=$need_conversion
    VALIDATION_ORPHANED_COUNT=$orphaned_count
    
    return 0
}

# ðŸ§¹ Clean up orphaned GIF files
cleanup_orphaned_gifs() {
    echo -e "\n  ${YELLOW}ðŸ§¹ Cleaning up orphaned GIF files...${NC}"
    
    local orphaned_dir="$LOG_DIR/orphaned_gifs"
    mkdir -p "$orphaned_dir" 2>/dev/null || {
        echo -e "    ${RED}âŒ Cannot create orphaned directory${NC}"
        return 1
    }
    
    local moved_count=0
    shopt -s nullglob
    for gif_file in *.gif; do
        [[ -f "$gif_file" ]] || continue
        local basename="${gif_file%.*}"
        local has_video=false
        
        # Check if corresponding video exists
        for ext in mp4 avi mov mkv webm; do
            if [[ -f "${basename}.${ext}" ]]; then
                has_video=true
                break
            fi
        done
        
        if [[ "$has_video" == false ]]; then
            local backup_file="$orphaned_dir/$(basename -- "$gif_file").$(date +%s).orphaned"
            if mv "$gif_file" "$backup_file" 2>/dev/null; then
                echo -e "    ${GREEN}âœ“ Moved: $(basename -- "$gif_file") â†’ orphaned_gifs/$(basename -- "$backup_file")${NC}"
                ((moved_count++))
                # Log the move
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ORPHANED GIF MOVED: $gif_file -> $backup_file"
                } >> "$CONVERSION_LOG" 2>/dev/null || true
            else
                echo -e "    ${RED}âŒ Failed to move: $gif_file${NC}"
            fi
        fi
    done
    shopt -u nullglob
    
    echo -e "  ${GREEN}âœ“ Moved $moved_count orphaned GIF(s) to: $orphaned_dir${NC}"
}

# ðŸ“‹ Generate intelligent conversion plan
generate_conversion_plan() {
    local total_videos=${VALIDATION_TOTAL_VIDEOS:-0}
    local already_converted=${VALIDATION_ALREADY_CONVERTED:-0}
    local need_conversion=${VALIDATION_NEED_CONVERSION:-0}
    local orphaned_count=${VALIDATION_ORPHANED_COUNT:-0}
    
    echo -e "  ${GREEN}âœ“ Conversion Plan:${NC}"
    
    if [[ $need_conversion -eq 0 ]]; then
        if [[ $already_converted -gt 0 ]]; then
            echo -e "    ${GREEN}ðŸŽ‰ All videos already converted! ($already_converted/$total_videos)${NC}"
            if [[ "$FORCE_CONVERSION" != "true" ]]; then
                echo -e "    ${CYAN}ðŸ’¡ Use --force to re-convert existing files${NC}"
                echo -e "    ${YELLOW}â­ï¸  Skipping conversion process${NC}"
                return 1  # Skip conversion
            else
                echo -e "    ${YELLOW}ðŸ”„ Force re-conversion enabled${NC}"
            fi
        else
            echo -e "    ${YELLOW}âš ï¸  No videos found that need conversion${NC}"
            return 1
        fi
    else
        echo -e "    ${CYAN}ðŸŽ¬ Will convert: ${BOLD}$need_conversion${NC} ${CYAN}video(s)${NC}"
        if [[ $already_converted -gt 0 ]]; then
            echo -e "    ${GREEN}âœ… Already done: ${BOLD}$already_converted${NC} ${GREEN}video(s)${NC}"
        fi
        
        # Estimate conversion time and space
        estimate_conversion_requirements
    fi
    
    if [[ $orphaned_count -gt 0 ]]; then
        echo -e "    ${YELLOW}ðŸ“ Cleanup recommended: $orphaned_count orphaned GIF(s)${NC}"
    fi
    
    return 0
}

# â±ï¸ Estimate conversion requirements
estimate_conversion_requirements() {
    local total_size=0
    local file_count=0
    
    # Calculate total size of videos that need conversion
    shopt -s nullglob
    for video in *.mp4 *.avi *.mov *.mkv *.webm; do
        [[ -f "$video" ]] || continue
        local basename="${video%.*}"
        local expected_gif="${basename}.gif"
        
        # Check if conversion is needed
        if [[ ! -f "$expected_gif" ]] || [[ "$FORCE_CONVERSION" == "true" ]]; then
            local size=$(stat -c%s -- "$video" 2>/dev/null || echo "0")
            total_size=$((total_size + size))
            ((file_count++))
        fi
    done
    shopt -u nullglob
    
    if [[ $file_count -gt 0 ]]; then
        local size_readable=$(numfmt --to=iec $total_size 2>/dev/null || echo "unknown")
        local estimated_time=$((file_count * 30))  # Rough estimate: 30 seconds per file
        local time_readable="${estimated_time}s"
        
        if [[ $estimated_time -gt 60 ]]; then
            time_readable="$((estimated_time / 60))m $((estimated_time % 60))s"
        fi
        
        echo -e "    ${BLUE}ðŸ“Š Estimated: ${size_readable} input â†’ ~${time_readable} conversion time${NC}"
        
        # Disk space warning if needed
        local available_space=$(df . | awk 'NR==2 {print $4}' 2>/dev/null || echo "0")
        local available_readable=$(echo "$available_space * 1024" | bc 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
        
        if [[ $available_space -gt 0 ]] && [[ $total_size -gt $((available_space * 1024 / 2)) ]]; then
            echo -e "    ${YELLOW}âš ï¸  Disk space: ${available_readable} available (may need more space for large GIFs)${NC}"
        fi
    fi
}

# ðŸ•µï¸ Detect and remove corrupted GIFs safely
detect_corrupted_gifs() {
    echo -e "${BLUE}ðŸ” Checking for corrupted GIF files...${NC}"
    
    local corrupted_count=0
    local total_gifs=0
    local corrupted_files=()
    declare -A corruption_reasons  # Track why each GIF is corrupted
    
    # First pass: count total GIF files - scan only OUTPUT_DIRECTORY if configured
    shopt -s nullglob
    local all_gifs=()
    
    if [[ -d "$OUTPUT_DIRECTORY" && "$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd)" != "$(pwd)" ]]; then
        # OUTPUT_DIRECTORY is configured and different - scan ONLY there
        echo -e "  ${BLUE}ðŸ“‚ Scanning output directory: $OUTPUT_DIRECTORY${NC}"
        all_gifs=("$OUTPUT_DIRECTORY"/*.gif)
    else
        # No separate output directory - scan current dir
        all_gifs=(*.gif)
    fi
    
    local total_to_check=${#all_gifs[@]}
    shopt -u nullglob
    
    if [[ $total_to_check -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No existing GIF files found${NC}"
        return 0
    fi
    
    echo -e "  ${CYAN}ðŸ“Š Found $total_to_check GIF files - validating with ${BOLD}5-layer checks${NC}${CYAN}...${NC}"
    
    # Check if GNU parallel is available for fast validation
    if command -v parallel >/dev/null 2>&1 && [[ $total_to_check -gt 10 ]]; then
        # PARALLEL MODE: Process all GIFs at once using all CPU cores
        local temp_validation_dir="$(mktemp -d)"
        local validation_script="$temp_validation_dir/validate_gif.sh"
        local validation_results="$temp_validation_dir/results.txt"
        local progress_counter="$temp_validation_dir/progress.txt"
        echo "0" > "$progress_counter"
        
        # Create validation script
        cat > "$validation_script" << 'VALIDATION_EOF'
#!/bin/bash
validate_single_gif() {
    local gif_file="$1"
    local progress_file="$2"
    
    local failed_checks=0
    local failure_reasons=()
    local needs_fixing=false
    local corruption_type="unknown"
    local corrected_name=""
    local basename_file="$(basename -- "$gif_file")"
    
    # LAYER 0: Extension/Filename corruption detection
    if [[ "$basename_file" =~ \.gif\.gif ]]; then
        needs_fixing=true
        corruption_type="multiple_gif_extensions"
    elif [[ "$basename_file" =~ \.gif[0-9]+\.?gif ]]; then
        needs_fixing=true
        corruption_type="corrupted_numbered_extension"
    elif [[ "$basename_file" =~ \.gif[a-z]*gif ]]; then
        needs_fixing=true
        corruption_type="concatenated_gif_extension"
    elif [[ "$basename_file" =~ \.[Gg][Ii][Ff][a-zA-Z0-9]+ ]] && [[ ! "$basename_file" =~ \.gif$ ]]; then
        needs_fixing=true
        corruption_type="malformed_gif_extension"
    fi
    
    # Layer 1: File size check
    local file_size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
    if [[ $file_size -lt 100 ]]; then
        ((failed_checks++))
        failure_reasons+=("File too small")
    fi
    
    # Layer 2: Check GIF magic bytes
    local magic_bytes=$(head -c 6 "$gif_file" 2>/dev/null)
    if [[ "$magic_bytes" != "GIF89a" && "$magic_bytes" != "GIF87a" ]]; then
        ((failed_checks++))
        failure_reasons+=("Invalid header")
    fi
    
    # Layer 3: Test with ffprobe
    if command -v ffprobe >/dev/null 2>&1; then
        if ! timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=nb_frames \
            -of csv=p=0 "$gif_file" >/dev/null 2>&1; then
            ((failed_checks++))
            failure_reasons+=("Cannot read frames")
        fi
    fi
    
    # Layer 4: Try to extract first frame
    if command -v ffmpeg >/dev/null 2>&1; then
        if ! timeout 5 ffmpeg -i "$gif_file" -vframes 1 -f null - >/dev/null 2>&1; then
            ((failed_checks++))
            failure_reasons+=("Frame extraction failed")
        fi
    fi
    
    # Layer 5: Gifsicle validation
    if command -v gifsicle >/dev/null 2>&1; then
        if ! timeout 5 gifsicle --info "$gif_file" >/dev/null 2>&1; then
            ((failed_checks++))
            failure_reasons+=("Gifsicle validation failed")
        fi
    fi
    
    # Update progress
    if [[ -n "$progress_file" ]]; then
        flock -x "$progress_file" bash -c 'echo $(($(cat "$1" 2>/dev/null || echo 0) + 1)) > "$1"' _ "$progress_file" 2>/dev/null || true
    fi
    
    # Output result if corrupted (2+ failures)
    if [[ $failed_checks -ge 2 ]]; then
        local reasons_str=$(IFS=','; echo "${failure_reasons[*]}")
        echo "CORRUPTED|$gif_file|$failed_checks|$reasons_str"
    elif [[ "$needs_fixing" == "true" ]]; then
        echo "NEEDS_FIX|$gif_file|0|$corruption_type"
    fi
}
export -f validate_single_gif
VALIDATION_EOF
        chmod +x "$validation_script"
        
        # Start parallel validation in background
        source "$validation_script"
        (
            printf '%s\n' "${all_gifs[@]}" | parallel -j "${AI_DUPLICATE_THREADS:-4}" \
                "validate_single_gif {} '$progress_counter'" > "$validation_results" 2>/dev/null
        ) &
        local parallel_pid=$!
        
        # Monitor progress with live progress bar
        local last_count=0
        while kill -0 $parallel_pid 2>/dev/null; do
            local current_count=$(cat "$progress_counter" 2>/dev/null || echo "0")
            
            if [[ $current_count -ne $last_count || $current_count -eq 0 ]]; then
                local percent=$((current_count * 100 / total_to_check))
                [[ $percent -gt 100 ]] && percent=100
                local filled=$((percent * 50 / 100))
                local empty=$((50 - filled))
                
                printf "\r  ${BLUE}ðŸ” ["
                for ((i=0; i<filled; i++)); do printf "${GREEN}â–ˆ${NC}"; done
                for ((i=0; i<empty; i++)); do printf "${GRAY}â–‘${NC}"; done
                printf "${BLUE}] ${YELLOW}%3d%%${NC} ${GRAY}(%d/%d)${NC}" "$percent" "$current_count" "$total_to_check"
                
                last_count=$current_count
            fi
            
            sleep 0.2
        done
        
        # Wait for completion
        wait $parallel_pid 2>/dev/null
        
        # Show final 100%
        printf "\r  ${BLUE}ðŸ” ["
        for ((i=0; i<50; i++)); do printf "${GREEN}â–ˆ${NC}"; done
        printf "${BLUE}] ${YELLOW}100%%${NC} ${GRAY}(%d/%d)${NC}\n" "$total_to_check" "$total_to_check"
        
        # Process results
        while IFS='|' read -r status filepath check_count reasons; do
            if [[ "$status" == "CORRUPTED" ]]; then
                corrupted_files+=("$filepath")
                corruption_reasons["$filepath"]="$reasons"
                ((corrupted_count++))
            elif [[ "$status" == "NEEDS_FIX" ]]; then
                # Handle auto-fix cases
                local base_name="${filepath%%.*}"
                local corrected_name="$(dirname "$filepath")/${base_name}.gif"
                if [[ ! -f "$corrected_name" && -f "$filepath" ]]; then
                    if mv "$filepath" "$corrected_name" 2>/dev/null; then
                        echo -e "  ${GREEN}âœ“ Auto-fixed:${NC} $(basename -- "$filepath") â†’ $(basename -- "$corrected_name") ${GRAY}($reasons)${NC}"
                    fi
                fi
            fi
        done < "$validation_results"
        
        # Cleanup
        rm -rf "$temp_validation_dir" 2>/dev/null
        
    else
        # SEQUENTIAL MODE: For small file counts or when parallel not available
    # Second pass: check each file with progress bar
    local checked=0
    shopt -s nullglob
    for gif_file in "${all_gifs[@]}"; do
        # Check for interrupt
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            printf "\r\033[K"
            echo -e "  ${YELLOW}â¸ï¸  Corruption check interrupted by user${NC}"
            shopt -u nullglob
            return 0
        fi
        
        [[ -f "$gif_file" ]] || continue
        ((total_gifs++))
        ((checked++))
        
        # Show progress bar
        local percent=$((checked * 100 / total_to_check))
        local filled=$((checked * 50 / total_to_check))
        local empty=$((50 - filled))
        
        # Build progress bar
        local bar=""
        for ((i=0; i<filled; i++)); do bar+="â–ˆ"; done
        for ((i=0; i<empty; i++)); do bar+="â–‘"; done
        
        # Truncate filename if too long (max 35 chars)
        local display_file="$(basename -- "$gif_file")"
        if [[ ${#display_file} -gt 35 ]]; then
            display_file="${display_file:0:32}..."
        fi
        
        # Single-line progress with filename
        printf "\r\033[K  ${BLUE}ðŸ” [${GREEN}%s${GRAY}%s${BLUE}] ${YELLOW}%3d%%${NC} ${GRAY}(%d/%d)${NC} ${CYAN}%s${NC}" "${bar:0:filled}" "${bar:filled:empty}" "$percent" "$checked" "$total_to_check" "$display_file"
        
        # ==================================================================
        # ðŸ”§ COMPREHENSIVE GIF CORRUPTION VALIDATION (ALL CHECKS MOVED HERE)
        # Previously, some filename/extension fixes ran during duplicate detection.
        # They are now consolidated here to keep Step 1 fast.
        # ==================================================================
        local failed_checks=0
        local failure_reasons=()
        local needs_fixing=false
        local corruption_type="unknown"
        local corrected_name=""
        local basename_file="$(basename -- "$gif_file")"
        
        # LAYER 0: Extension/Filename corruption detection (Auto-fix)
        # Pattern 1: Multiple .gif extensions (.gif.gif, .gif.gif.gif, etc.)
        if [[ "$basename_file" =~ \.gif\.gif ]]; then
            needs_fixing=true
            corruption_type="multiple_gif_extensions"
            local base_name="${basename_file%%.*}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 2: Corrupted mixed extensions (.gif9.gifgif, .gif5.gif, etc.)
        elif [[ "$basename_file" =~ \.gif[0-9]+\.?gif ]]; then
            needs_fixing=true
            corruption_type="corrupted_numbered_extension"
            local base_name="${basename_file%%.*}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 3: Multiple 'gif' in extension without dots (.gifgif, .gifgifgif)
        elif [[ "$basename_file" =~ \.gif[a-z]*gif ]]; then
            needs_fixing=true
            corruption_type="concatenated_gif_extension"
            local base_name="${basename_file%%.*}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 4: Extension has 'gif' followed by other characters (.giff, .gift, .gifx)
        elif [[ "$basename_file" =~ \.[Gg][Ii][Ff][a-zA-Z0-9]+ ]] && [[ ! "$basename_file" =~ \.gif$ ]]; then
            needs_fixing=true
            corruption_type="malformed_gif_extension"
            local base_name="${basename_file%%.*}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 5: No extension but filename contains 'gif' at end (filegif, somegif)
        elif [[ ! "$basename_file" =~ \. ]] && [[ "$basename_file" =~ gif$ ]]; then
            needs_fixing=true
            corruption_type="missing_dot_before_gif"
            local base_name="${basename_file%gif}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 6: Filename contains [cached], [temp], [backup] or other bracket text
        elif [[ "$basename_file" =~ \[.*\] ]]; then
            needs_fixing=true
            corruption_type="unwanted_bracket_text"
            local clean_name=$(echo "$basename_file" | sed 's/\[.*\]//g' | sed 's/\.\+/./g')
            local base_name="${clean_name%%.*}"
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        # Pattern 7: Filename contains common corruption markers (temp, backup, copy, old)
        elif [[ "$basename_file" =~ \.(temp|tmp|backup|bak|copy|old|~)\.gif$ ]]; then
            needs_fixing=true
            corruption_type="unwanted_suffix_in_extension"
            local base_name=$(echo "$basename_file" | sed -E 's/\.(temp|tmp|backup|bak|copy|old|~)\.gif$//g')
            corrected_name="$(dirname "$gif_file")/${base_name}.gif"
        fi
        
        # Apply auto-fix if extension corruption detected
        if [[ "$needs_fixing" == "true" && -n "$corrected_name" ]]; then
            if [[ ! -f "$corrected_name" ]]; then
                if mv "$gif_file" "$corrected_name" 2>/dev/null; then
                    printf "\r\033[K  ${GREEN}âœ“ Auto-fixed:${NC} %s â†’ %s (${GRAY}%s${NC})\n" "$(basename -- "$gif_file")" "$(basename -- "$corrected_name")" "$corruption_type"
                    log_conversion "AUTO_FIXED" "$gif_file" "$corrected_name" "Extension corruption ($corruption_type) â†’ .gif"
                    # Update file reference for remaining checks
                    gif_file="$corrected_name"
                    basename_file="$(basename -- "$gif_file")"
                else
                    ((failed_checks++))
                    failure_reasons+=("Cannot fix extension: $corruption_type")
                fi
            else
                # Corrected version exists - mark original as problematic
                corrupted_files+=("$gif_file")
                corruption_reasons["$gif_file"]=
                    "Duplicate extension (corrected version exists)"
                ((corrupted_count++))
                continue  # Skip remaining checks for this file
            fi
        fi
        
        # Layer 1: File size check (suspiciously small)
        local file_size=$(stat -c%s -- "$gif_file" 2>/dev/null || echo "0")
        if [[ $file_size -lt 100 ]]; then
            # File less than 100 bytes is almost certainly corrupted
            ((failed_checks++))
            failure_reasons+=("File too small (<100 bytes)")
        fi
        
        # Layer 2: Check GIF magic bytes (GIF89a or GIF87a)
        local magic_bytes=$(head -c 6 "$gif_file" 2>/dev/null)
        if [[ "$magic_bytes" != "GIF89a" && "$magic_bytes" != "GIF87a" ]]; then
            ((failed_checks++))
            failure_reasons+=("Invalid GIF header")
        fi
        
        # Layer 3: Test with ffprobe (frame count)
        if command -v ffprobe >/dev/null 2>&1; then
            if ! timeout 5 ffprobe -v error -select_streams v:0 -show_entries stream=nb_frames \
                -of csv=p=0 "$gif_file" >/dev/null 2>&1; then
                ((failed_checks++))
                failure_reasons+=("Cannot read frames")
            fi
        fi
        
        # Layer 4: Try to extract first frame with ffmpeg
        if command -v ffmpeg >/dev/null 2>&1; then
            local test_frame="/tmp/gif_test_${RANDOM}.png"
            if ! timeout 5 ffmpeg -i "$gif_file" -vframes 1 -f image2 "$test_frame" >/dev/null 2>&1; then
                ((failed_checks++))
                failure_reasons+=("Frame extraction failed")
            fi
            rm -f "$test_frame" 2>/dev/null
        fi
        
        # Layer 5: If gifsicle is available, use it for validation
        if command -v gifsicle >/dev/null 2>&1; then
            if ! timeout 5 gifsicle --info "$gif_file" >/dev/null 2>&1; then
                ((failed_checks++))
                failure_reasons+=("Gifsicle validation failed")
            fi
        fi
        
        # Mark as corrupted only if multiple checks failed (at least 2)
        if [[ $failed_checks -ge 2 ]]; then
            corrupted_files+=("$gif_file")
            # Store reasons as comma-separated string
            local reasons_str=$(IFS=', '; echo "${failure_reasons[*]}")
            corruption_reasons["$gif_file"]="$reasons_str"
            ((corrupted_count++))
        fi
    done
    shopt -u nullglob
    
    # Clear progress bar
    printf "\r\033[K"
    
    fi  # End of parallel/sequential GIF validation if-else
    
    if [[ $total_gifs -eq 0 ]]; then
        echo -e "  ${CYAN}â„¹ï¸  No existing GIF files found${NC}"
        return 0
    fi
    
    echo -e "  ${GREEN}âœ“ Scanned $total_gifs GIF files${NC}"
    
    if [[ $corrupted_count -eq 0 ]]; then
        echo -e "  ${GREEN}âœ“ All existing GIFs are healthy${NC}"
        return 0
    fi
    
    # Handle corrupted files with detailed reasons
    echo -e "\n  ${RED}${BOLD}âš ï¸  Found $corrupted_count corrupted GIF file(s):${NC}\n"
    
    for corrupted_file in "${corrupted_files[@]}"; do
        local file_size=$(stat -c%s -- "$corrupted_file" 2>/dev/null || echo "0")
        local file_size_kb=$((file_size / 1024))
        local reasons="${corruption_reasons[$corrupted_file]}"
        
        echo -e "    ${RED}âŒ${NC} $(basename -- "$corrupted_file") ${GRAY}(${file_size_kb}KB)${NC}"
        echo -e "       ${YELLOW}Reason: ${reasons}${NC}"
    done
    
    echo ""
    echo -e "${YELLOW}${BOLD}âš ï¸  CORRUPTED GIFS DETECTED${NC}"
    echo ""
    echo -e "${CYAN}These GIF files failed multiple validation tests:${NC}"
    echo -e "${CYAN}  â€¢ Invalid file format or headers${NC}"
    echo -e "${CYAN}  â€¢ Cannot extract frames${NC}"
    echo -e "${CYAN}  â€¢ Likely truncated during creation/transfer${NC}"
    echo ""
    echo -e "${RED}${BOLD}âš ï¸  DELETE these $corrupted_count corrupted GIF file(s)?${NC}"
    echo -e "${GRAY}(Pressing Enter or 'n' will keep them)${NC}"
    echo ""
    echo -ne "${BOLD}Delete corrupted GIFs? (y/N): ${NC}"
    
    local delete_choice
    if [[ "${INTERACTIVE_MODE:-true}" == "false" ]]; then
        delete_choice="n"
        echo "n (auto-selected: keep)"
    else
        read -r delete_choice
    fi
    
    if [[ "$delete_choice" =~ ^[Yy]$ ]]; then
        echo -e "\n${RED}Deleting corrupted GIF files...${NC}"
        local deleted=0
        for corrupted_file in "${corrupted_files[@]}"; do
            if rm -f "$corrupted_file" 2>/dev/null; then
                echo -e "  ${RED}âŒ Deleted: $(basename -- "$corrupted_file")${NC}"
                ((deleted++))
                # Log the deletion
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CORRUPTED GIF DELETED: $corrupted_file"
                } >> "$ERROR_LOG" 2>/dev/null || true
            else
                echo -e "  ${YELLOW}âš ï¸  Failed to delete: $(basename -- "$corrupted_file")${NC}"
            fi
        done
        echo -e "\n${GREEN}âœ“ Deleted $deleted corrupted GIF(s)${NC}"
    else
        echo -e "\n${GREEN}âœ“ Keeping all files - no changes made${NC}"
    fi
    
    echo ""
}

# âš¡ AI Speed Optimization Engine
ai_speed_optimizer() {
    local video_file="$1"
    local video_complexity="$2"
    local ai_results="$3"
    
    echo -e "${BLUE}âš¡ AI Speed Optimizer analyzing: $(basename -- "$video_file")${NC}"
    
    # Initialize speed optimization variables
    local speed_preset="medium"
    local threads_optimal="auto"
    local gpu_encoder=""
    local memory_optimization=""
    local parallel_strategy="sequential"
    
    # Hardware detection for speed optimization
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    local available_memory=$(free -m 2>/dev/null | awk '/^Mem:/ {print $7}' || echo "2048")
    
    # AI-driven complexity analysis for speed optimization - maximize CPU usage
    case "$video_complexity" in
        "static"|"slideshow")
            speed_preset="ultrafast"
            threads_optimal="$cpu_cores"  # Use all cores even for static content
            echo -e "  ${GREEN}ðŸŽ¯ Static content detected - ultrafast with all cores${NC}"
            ;;
        "low")
            speed_preset="veryfast"
            threads_optimal="$cpu_cores"  # Use all cores for better throughput
            echo -e "  ${GREEN}ðŸŽ¯ Low motion detected - veryfast with all cores${NC}"
            ;;
        "medium")
            speed_preset="fast"
            threads_optimal="$cpu_cores"
            echo -e "  ${YELLOW}ðŸŽ¯ Medium complexity - fast with all cores${NC}"
            ;;
        "high"|"animation")
            speed_preset="medium"
            threads_optimal="$cpu_cores"  # Still use all cores for maximum performance
            echo -e "  ${RED}ðŸŽ¯ High complexity - medium with all cores${NC}"
            ;;
    esac
    
    # GPU acceleration optimization
    if detect_gpu_for_speed; then
        gpu_encoder=$(get_optimal_gpu_encoder)
        if [[ -n "$gpu_encoder" ]]; then
            echo -e "  ${GREEN}ðŸš€ GPU acceleration enabled: $gpu_encoder${NC}"
            speed_preset="fast"  # GPU can handle faster presets
        fi
    fi
    
    # Memory-based optimizations
    if [[ $available_memory -lt 1024 ]]; then
        echo -e "  ${YELLOW}âš ï¸ Low memory detected - enabling memory conservation${NC}"
        memory_optimization="-threads 2 -filter_threads 1"
        threads_optimal="2"
    elif [[ $available_memory -gt 8192 ]]; then
        echo -e "  ${GREEN}ðŸ’ª High memory available - enabling aggressive caching${NC}"
        memory_optimization="-filter_complex_threads $cpu_cores"
    fi
    
    # Parallel processing strategy - more aggressive with multiple cores
    local video_count=$(find . -maxdepth 1 \( -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" \) | wc -l)
    if [[ $video_count -gt 1 && $cpu_cores -ge 2 ]]; then
        parallel_strategy="parallel"
        echo -e "  ${CYAN}ðŸ”„ Multiple videos + ðŸ’ª ${cpu_cores} cores - aggressive parallel processing${NC}"
    elif [[ $cpu_cores -ge 8 ]]; then
        parallel_strategy="parallel"
        echo -e "  ${CYAN}ðŸš€ High-core system (${cpu_cores} cores) - enabling parallel optimization${NC}"
    fi
    
    # Export optimized settings
    export AI_SPEED_PRESET="$speed_preset"
    export AI_THREADS_OPTIMAL="$threads_optimal"
    export AI_GPU_ENCODER="$gpu_encoder"
    export AI_MEMORY_OPT="$memory_optimization"
    export AI_PARALLEL_STRATEGY="$parallel_strategy"
    
    echo -e "  ${GREEN}âœ“ Speed optimization complete${NC}"
    echo -e "    ${CYAN}Preset: $speed_preset | Threads: $threads_optimal${NC}"
    if [[ -n "$gpu_encoder" ]]; then
        echo -e "    ${CYAN}GPU: $gpu_encoder${NC}"
    fi
}

# ðŸƒ Detect GPU capabilities for speed optimization
detect_gpu_for_speed() {
    # Quick GPU detection focused on speed capabilities
    if command -v nvidia-smi >/dev/null 2>&1 && nvidia-smi >/dev/null 2>&1; then
        return 0  # NVIDIA GPU available
    elif [[ -d /sys/class/drm ]] && ls /sys/class/drm/card*/device/vendor 2>/dev/null | xargs cat | grep -q "0x1002\|0x8086"; then
        return 0  # AMD or Intel GPU available
    fi
    return 1
}

# ðŸŽ¯ Get optimal GPU encoder for current hardware
get_optimal_gpu_encoder() {
    local encoders=("h264_nvenc" "h264_vaapi" "h264_videotoolbox" "h264_qsv")
    
    for encoder in "${encoders[@]}"; do
        if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "$encoder"; then
            echo "$encoder"
            return 0
        fi
    done
    
    return 1
}

# ðŸ“Š AI Performance Analysis
ai_performance_analysis() {
    local video_file="$1"
    
    echo -e "${BLUE}ðŸ“Š AI Performance Analysis for: $(basename -- "$video_file")${NC}"
    
    # Get video properties for performance prediction
    local duration=$(ffprobe -v quiet -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null | cut -d. -f1)
    local resolution=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 "$video_file" 2>/dev/null)
    local fps=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null | bc -l 2>/dev/null | cut -d. -f1)
    
    # Calculate complexity score
    local width=$(echo "$resolution" | cut -d'x' -f1)
    local height=$(echo "$resolution" | cut -d'x' -f2)
    local pixel_count=$((width * height))
    local complexity_score=1
    
    # Adjust complexity based on resolution
    if [[ $pixel_count -gt 2073600 ]]; then  # > 1080p
        complexity_score=$((complexity_score + 3))
    elif [[ $pixel_count -gt 921600 ]]; then  # > 720p
        complexity_score=$((complexity_score + 2))
    elif [[ $pixel_count -gt 307200 ]]; then  # > 480p
        complexity_score=$((complexity_score + 1))
    fi
    
    # Adjust for frame rate
    if [[ ${fps:-15} -gt 30 ]]; then
        complexity_score=$((complexity_score + 2))
    elif [[ ${fps:-15} -gt 24 ]]; then
        complexity_score=$((complexity_score + 1))
    fi
    
    # Predict processing time
    local estimated_time=$((duration * complexity_score / 10))
    if [[ $estimated_time -lt 5 ]]; then
        estimated_time=5
    fi
    
    echo -e "  ${YELLOW}ðŸ“ Resolution: ${width}x${height} (${pixel_count} pixels)${NC}"
    echo -e "  ${YELLOW}â±ï¸ Duration: ${duration}s | FPS: ${fps:-"unknown"}${NC}"
    echo -e "  ${CYAN}ðŸ§® Complexity Score: ${complexity_score}/10${NC}"
    echo -e "  ${GREEN}âš¡ Estimated Processing: ~${estimated_time}s${NC}"
    
    # Export performance data
    export AI_PERF_COMPLEXITY="$complexity_score"
    export AI_PERF_ESTIMATED_TIME="$estimated_time"
    export AI_PERF_RESOLUTION="$resolution"
}

# ðŸš€ GPU acceleration detection and setup
detect_gpu_acceleration() {
    echo -e "${BLUE}ðŸ” Detecting GPU acceleration capabilities...${NC}"
    
    # GPU encoders by vendor (will be filtered based on detected GPU)
    local available_encoders=()
    
    # Detect GPU hardware with better AMD/NVIDIA detection
    local gpu_info=""
    
    # First, check for VFIO-bound GPUs and skip them
    local vfio_gpus=()
    if [[ -d /sys/bus/pci/drivers/vfio-pci ]]; then
        for vfio_device in /sys/bus/pci/drivers/vfio-pci/*; do
            if [[ -L "$vfio_device" ]]; then
                local pci_id=$(basename -- "$vfio_device")
                local device_info=$(lspci -s "$pci_id" 2>/dev/null | grep -i -E "(vga|3d|display)")
                if [[ -n "$device_info" ]]; then
                    vfio_gpus+=("$pci_id: $device_info")
                fi
            fi
        done
    fi
    
    # Show VFIO-bound GPUs info
    if [[ ${#vfio_gpus[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}âš ï¸  Found ${#vfio_gpus[@]} GPU(s) bound to VFIO (passthrough):${NC}"
        for vfio_gpu in "${vfio_gpus[@]}"; do
            echo -e "    ${GRAY}ðŸ”’ $vfio_gpu (skipped)${NC}"
        done
    fi
    
    # Check for available (non-VFIO) NVIDIA GPUs
    if command -v nvidia-smi >/dev/null 2>&1; then
        # Get all NVIDIA GPUs from lspci
        local all_nvidia_gpus=($(lspci 2>/dev/null | grep -i -E "(vga|3d|display).*nvidia" | cut -d' ' -f1))
        local available_nvidia_gpus=()
        
        # Filter out VFIO-bound NVIDIA GPUs
        for nvidia_pci in "${all_nvidia_gpus[@]}"; do
            local is_vfio_bound=false
            for vfio_gpu in "${vfio_gpus[@]}"; do
                if [[ "$vfio_gpu" == *"$nvidia_pci"* ]]; then
                    is_vfio_bound=true
                    break
                fi
            done
            
            if [[ "$is_vfio_bound" == false ]]; then
                available_nvidia_gpus+=("$nvidia_pci")
            fi
        done
        
        # Check if nvidia-smi can see available GPUs
        if [[ ${#available_nvidia_gpus[@]} -gt 0 ]] && nvidia-smi >/dev/null 2>&1; then
            local nvidia_gpu=$(nvidia-smi --query-gpu=name --format=csv,noheader,nounits 2>/dev/null | head -1)
            gpu_info="NVIDIA GPU detected: ${nvidia_gpu:-Unknown NVIDIA GPU} (${#available_nvidia_gpus[@]} available)"
            GPU_TYPE="nvidia"
            # For NVIDIA, prioritize NVENC encoder
            if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_nvenc"; then
                available_encoders+=("h264_nvenc")
            fi
            if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_nvenc"; then
                available_encoders+=("hevc_nvenc")
            fi
        elif [[ ${#available_nvidia_gpus[@]} -gt 0 ]]; then
            # NVIDIA GPUs exist but nvidia-smi can't see them (driver issues or VFIO)
            local nvidia_gpu=$(lspci -s "${available_nvidia_gpus[0]}" 2>/dev/null | sed 's/.*: //')
            gpu_info="NVIDIA GPU detected but driver unavailable: ${nvidia_gpu:-Unknown NVIDIA GPU}"
            GPU_TYPE="none"
        else
            gpu_info="NVIDIA GPUs detected but all bound to VFIO (passthrough)"
            GPU_TYPE="none"
        fi
    # Check for available AMD GPUs (excluding VFIO-bound)
    elif lspci 2>/dev/null | grep -i -E "(vga|3d|display).*amd|vga.*radeon|3d.*radeon" >/dev/null; then
        # Get all AMD GPUs
        local all_amd_gpus=($(lspci 2>/dev/null | grep -i -E "(vga|3d|display).*amd|vga.*radeon|3d.*radeon" | cut -d' ' -f1))
        local available_amd_gpus=()
        
        # Filter out VFIO-bound AMD GPUs
        for amd_pci in "${all_amd_gpus[@]}"; do
            local is_vfio_bound=false
            for vfio_gpu in "${vfio_gpus[@]}"; do
                if [[ "$vfio_gpu" == *"$amd_pci"* ]]; then
                    is_vfio_bound=true
                    break
                fi
            done
            
            if [[ "$is_vfio_bound" == false ]]; then
                available_amd_gpus+=("$amd_pci")
            fi
        done
        
        if [[ ${#available_amd_gpus[@]} -gt 0 ]]; then
            local amd_gpu=$(lspci -s "${available_amd_gpus[0]}" 2>/dev/null | sed 's/.*: //')
            gpu_info="AMD GPU detected: ${amd_gpu:-Unknown AMD GPU} (${#available_amd_gpus[@]} available)"
            # For AMD, prioritize VAAPI encoder
            if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_vaapi"; then
                available_encoders+=("h264_vaapi")
            fi
            if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_vaapi"; then
                available_encoders+=("hevc_vaapi")
            fi
            GPU_TYPE="amd"
            
            # Additional AMD detection methods
            if [[ -z "$amd_gpu" ]] && command -v rocm-smi >/dev/null 2>&1; then
                local rocm_gpu=$(rocm-smi --showproductname 2>/dev/null | grep -v "=" | head -1 | xargs)
                [[ -n "$rocm_gpu" ]] && gpu_info="AMD GPU detected: $rocm_gpu (${#available_amd_gpus[@]} available)"
            fi
        else
            gpu_info="AMD GPUs detected but all bound to VFIO (passthrough)"
            GPU_TYPE="none"
        fi
    # Check for Intel GPU (usually not VFIO-bound)
    elif lspci 2>/dev/null | grep -i -E "vga.*intel|3d.*intel|display.*intel" >/dev/null; then
        local intel_gpu=$(lspci 2>/dev/null | grep -i -E "vga.*intel|3d.*intel|display.*intel" | head -1 | sed 's/.*: //')
        gpu_info="Intel GPU detected: ${intel_gpu:-Unknown Intel GPU}"
        GPU_TYPE="intel"
        # For Intel, check for QSV or VAAPI
        if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_qsv"; then
            available_encoders+=("h264_qsv")
        elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_vaapi"; then
            available_encoders+=("h264_vaapi")
        fi
    else
        if [[ ${#vfio_gpus[@]} -gt 0 ]]; then
            gpu_info="Only VFIO-bound GPUs detected (all in passthrough mode)"
        else
            gpu_info="No supported GPU detected"
        fi
        GPU_TYPE="none"
    fi
    
    # Set GPU acceleration based on detection
    if [[ "$GPU_ACCELERATION" == "auto" ]]; then
        if [[ ${#available_encoders[@]} -gt 0 ]]; then
            GPU_ENCODER="${available_encoders[0]}"
            GPU_ACCELERATION="true"
            echo -e "  ${GREEN}âœ“ $gpu_info - Using $GPU_ENCODER${NC}"
        else
            GPU_ACCELERATION="false"
            echo -e "  ${YELLOW}âš ï¸  $gpu_info - No hardware encoders available${NC}"
        fi
    elif [[ "$GPU_ACCELERATION" == "true" ]]; then
        if [[ ${#available_encoders[@]} -gt 0 ]]; then
            GPU_ENCODER="${available_encoders[0]}"
            echo -e "  ${GREEN}âœ“ $gpu_info - Forced GPU acceleration with $GPU_ENCODER${NC}"
        else
            echo -e "  ${RED}âŒ GPU acceleration forced but no encoders available - falling back to CPU${NC}"
            GPU_ACCELERATION="false"
        fi
    else
        echo -e "  ${CYAN}ðŸ’» CPU-only mode (GPU acceleration disabled)${NC}"
    fi
    
    # Advanced CPU optimization
    optimize_cpu_usage
    
    # Advanced RAM optimization
    optimize_ram_usage
    
    echo ""
}

# ðŸ§® Advanced CPU optimization and detection system
optimize_cpu_usage() {
    echo -e "  ${BLUE}ðŸ§® Analyzing CPU architecture for optimal performance...${NC}"
    
    # Detect CPU information
    local cpu_info=$(detect_cpu_architecture)
    local physical_cores=$(get_physical_cores)
    local logical_cores=$(get_logical_cores)
    local cpu_threads_per_core=$(get_threads_per_core)
    local memory_gb=$(get_available_memory_gb)
    local cpu_frequency=$(get_cpu_frequency)
    
    # Display CPU analysis
    echo -e "  ${GREEN}âœ“ CPU Analysis:${NC}"
    echo -e "    ${YELLOW}ðŸ“Š Architecture: ${BOLD}$cpu_info${NC}"
    echo -e "    ${YELLOW}âš™ï¸ Physical cores: ${BOLD}$physical_cores${NC}"
    echo -e "    ${YELLOW}ðŸ§  Logical cores: ${BOLD}$logical_cores${NC}"
    echo -e "    ${YELLOW}ðŸ”„ Threads per core: ${BOLD}$cpu_threads_per_core${NC}"
    echo -e "    ${YELLOW}ðŸ“¦ Available RAM: ${BOLD}${memory_gb}GB${NC}"
    [[ -n "$cpu_frequency" ]] && echo -e "    ${YELLOW}âš¡ Base frequency: ${BOLD}${cpu_frequency}${NC}"
    
    # Performance mode optimization
    optimize_for_performance_mode
    
    # Set optimal FFmpeg thread count
    if [[ "$FFMPEG_THREADS" == "auto" ]]; then
        if [[ "$CPU_BENCHMARK" == "true" ]]; then
            echo -e "  ${BLUE}ðŸ† Running performance benchmark...${NC}"
            benchmark_cpu_performance
        else
            FFMPEG_THREADS=$(calculate_optimal_ffmpeg_threads "$logical_cores" "$memory_gb")
            echo -e "  ${GREEN}âœ“ FFmpeg threads: ${BOLD}$FFMPEG_THREADS${NC} ${GRAY}(optimized for your CPU)${NC}"
        fi
    else
        echo -e "  ${CYAN}ðŸ”§ FFmpeg threads: ${BOLD}$FFMPEG_THREADS${NC} ${GRAY}(manually set)${NC}"
    fi
}

# ðŸ” Detect CPU architecture and capabilities
detect_cpu_architecture() {
    local cpu_info="Unknown"
    
    if [[ -f /proc/cpuinfo ]]; then
        local cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs)
        local cpu_vendor=$(grep "vendor_id" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs)
        
        if [[ -n "$cpu_model" ]]; then
            cpu_info="$cpu_model"
            # Detect specific optimizations
            if [[ "$cpu_model" == *"Intel"* ]]; then
                cpu_info+="  ðŸ”µ Intel optimized"
            elif [[ "$cpu_model" == *"AMD"* ]]; then
                cpu_info+="  ðŸ”´ AMD optimized"
            fi
            
            # Detect performance tier
            if [[ "$cpu_model" == *"i9"* ]] || [[ "$cpu_model" == *"Ryzen 9"* ]] || [[ "$cpu_model" == *"Threadripper"* ]]; then
                cpu_info+="  ðŸš€ High-end"
            elif [[ "$cpu_model" == *"i7"* ]] || [[ "$cpu_model" == *"Ryzen 7"* ]]; then
                cpu_info+="  ðŸ’ª Performance"
            elif [[ "$cpu_model" == *"i5"* ]] || [[ "$cpu_model" == *"Ryzen 5"* ]]; then
                cpu_info+="  âš™ï¸ Mainstream"
            fi
        elif [[ -n "$cpu_vendor" ]]; then
            cpu_info="$cpu_vendor CPU"
        fi
    fi
    
    # Detect architecture features
    if [[ -f /proc/cpuinfo ]]; then
        local flags=$(grep "^flags" /proc/cpuinfo | head -1 | cut -d':' -f2)
        local features=()
        
        [[ "$flags" == *"avx2"* ]] && features+=("AVX2")
        [[ "$flags" == *"avx512"* ]] && features+=("AVX-512")
        [[ "$flags" == *"sse4_2"* ]] && features+=("SSE4.2")
        
        if [[ ${#features[@]} -gt 0 ]]; then
            cpu_info+=" ($(IFS=,; echo "${features[*]}"))"
        fi
    fi
    
    echo "$cpu_info"
}

# ðŸ’ª Get physical CPU cores
get_physical_cores() {
    local physical_cores=1
    
    if [[ -f /proc/cpuinfo ]]; then
        physical_cores=$(grep "^cpu cores" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs 2>/dev/null || echo "1")
        
        # Fallback method
        if [[ $physical_cores -eq 1 ]]; then
            physical_cores=$(grep -c "^processor" /proc/cpuinfo 2>/dev/null || echo "1")
            # If hyperthreading is detected, divide by 2
            local threads_per_core=$(get_threads_per_core)
            if [[ $threads_per_core -gt 1 ]]; then
                physical_cores=$((physical_cores / threads_per_core))
            fi
        fi
    else
        physical_cores=$(nproc --all 2>/dev/null || echo "1")
    fi
    
    [[ $physical_cores -lt 1 ]] && physical_cores=1
    echo "$physical_cores"
}

# ðŸ§  Get logical CPU cores (including hyperthreading)
get_logical_cores() {
    local logical_cores=$(nproc --all 2>/dev/null || echo "1")
    [[ $logical_cores -lt 1 ]] && logical_cores=1
    echo "$logical_cores"
}

# ðŸ”„ Get threads per core (detect hyperthreading)
get_threads_per_core() {
    local threads_per_core=1
    
    if [[ -f /proc/cpuinfo ]]; then
        local siblings=$(grep "^siblings" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs 2>/dev/null || echo "1")
        local cpu_cores=$(grep "^cpu cores" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs 2>/dev/null || echo "1")
        
        if [[ $siblings -gt 0 && $cpu_cores -gt 0 ]]; then
            threads_per_core=$((siblings / cpu_cores))
        fi
    fi
    
    [[ $threads_per_core -lt 1 ]] && threads_per_core=1
    echo "$threads_per_core"
}

# ðŸ“¦ Get available memory in GB
get_available_memory_gb() {
    local memory_gb=1
    
    if command -v free >/dev/null 2>&1; then
        local memory_kb=$(free | awk '/^Mem:/ {print $7}' 2>/dev/null)
        if [[ -n "$memory_kb" && $memory_kb -gt 0 ]]; then
            memory_gb=$((memory_kb / 1024 / 1024))
        else
            # Fallback to total memory
            memory_kb=$(free | awk '/^Mem:/ {print $2}' 2>/dev/null)
            [[ -n "$memory_kb" && $memory_kb -gt 0 ]] && memory_gb=$((memory_kb / 1024 / 1024))
        fi
    elif [[ -f /proc/meminfo ]]; then
        local memory_kb=$(grep "MemAvailable" /proc/meminfo | awk '{print $2}' 2>/dev/null)
        if [[ -n "$memory_kb" && $memory_kb -gt 0 ]]; then
            memory_gb=$((memory_kb / 1024))
        fi
    fi
    
    [[ $memory_gb -lt 1 ]] && memory_gb=1
    echo "$memory_gb"
}

# âš¡ Get CPU frequency information
get_cpu_frequency() {
    local frequency=""
    
    if [[ -f /proc/cpuinfo ]]; then
        frequency=$(grep "cpu MHz" /proc/cpuinfo | head -1 | cut -d':' -f2 | xargs 2>/dev/null)
        if [[ -n "$frequency" ]]; then
            local ghz=$(echo "scale=2; $frequency / 1000" | bc 2>/dev/null || echo "")
            [[ -n "$ghz" ]] && frequency="${ghz}GHz"
        fi
    fi
    
    echo "$frequency"
}

# ðŸŽ¯ Calculate optimal FFmpeg thread count
calculate_optimal_ffmpeg_threads() {
    local logical_cores="$1"
    local memory_gb="$2"
    local optimal_threads=$logical_cores
    
    # Memory-based adjustment
    if [[ $memory_gb -lt 4 ]]; then
        # Low memory: reduce threads to prevent OOM
        optimal_threads=$((logical_cores * 75 / 100))
    elif [[ $memory_gb -lt 8 ]]; then
        # Medium memory: slight reduction
        optimal_threads=$((logical_cores * 90 / 100))
    else
        # High memory: use all cores
        optimal_threads=$logical_cores
    fi
    
    # Architecture-based adjustment
    local cpu_model=$(grep "model name" /proc/cpuinfo 2>/dev/null | head -1 | cut -d':' -f2 | xargs)
    if [[ "$cpu_model" == *"Ryzen"* ]] || [[ "$cpu_model" == *"Threadripper"* ]]; then
        # AMD CPUs often benefit from using all threads
        optimal_threads=$logical_cores
    elif [[ "$cpu_model" == *"Intel"* ]]; then
        # Intel CPUs sometimes perform better with physical cores + 50%
        local physical_cores=$(get_physical_cores)
        local intel_optimal=$((physical_cores + physical_cores / 2))
        [[ $intel_optimal -lt $optimal_threads ]] && optimal_threads=$intel_optimal
    fi
    
    # Minimum and maximum bounds
    [[ $optimal_threads -lt 1 ]] && optimal_threads=1
    [[ $optimal_threads -gt $logical_cores ]] && optimal_threads=$logical_cores
    
    echo "$optimal_threads"
}

# ðŸš€ Advanced multi-threading setup for parallel processing
setup_parallel_processing() {
    local logical_cores=$(get_logical_cores)
    local physical_cores=$(get_physical_cores)
    local memory_gb=$(get_available_memory_gb)
    
    if [[ "$PARALLEL_JOBS" == "auto" ]]; then
        PARALLEL_JOBS=$(calculate_optimal_parallel_jobs "$logical_cores" "$physical_cores" "$memory_gb")
        
        echo -e "${GREEN}ðŸš€ Advanced parallel processing optimized:${NC}"
        echo -e "  ${CYAN}âš™ï¸ Concurrent jobs: ${BOLD}$PARALLEL_JOBS${NC}"
        echo -e "  ${CYAN}ðŸ§  Per-job threads: ${BOLD}$FFMPEG_THREADS${NC}"
        echo -e "  ${CYAN}ðŸ“Š Total thread utilization: ${BOLD}$((PARALLEL_JOBS * FFMPEG_THREADS))/${logical_cores}${NC}"
        
        # Performance recommendations
        if [[ $logical_cores -ge 16 ]]; then
            echo -e "  ${GREEN}ðŸš€ High-performance CPU detected - maximum efficiency mode enabled${NC}"
        elif [[ $logical_cores -ge 8 ]]; then
            echo -e "  ${BLUE}ðŸ’ª Performance CPU detected - optimal processing enabled${NC}"
        elif [[ $logical_cores -ge 4 ]]; then
            echo -e "  ${YELLOW}âš™ï¸ Mainstream CPU detected - balanced processing enabled${NC}"
        else
            echo -e "  ${CYAN}ðŸ’» Entry-level CPU detected - conservative processing enabled${NC}"
        fi
        
        echo ""
    elif [[ "$PARALLEL_JOBS" -eq 1 ]]; then
        echo -e "${CYAN}ðŸ’» Single-threaded mode: Using all $FFMPEG_THREADS threads per conversion${NC}"
    else
        echo -e "${GREEN}ðŸ”§ Manual configuration: $PARALLEL_JOBS jobs Ã— $FFMPEG_THREADS threads = $((PARALLEL_JOBS * FFMPEG_THREADS)) total threads${NC}"
    fi
}

# ðŸŽ¯ Calculate optimal number of parallel conversion jobs
calculate_optimal_parallel_jobs() {
    local logical_cores="$1"
    local physical_cores="$2"
    local memory_gb="$3"
    local optimal_jobs=1
    
    # Base calculation on physical cores
    if [[ $physical_cores -ge 16 ]]; then
        optimal_jobs=6  # High-end workstation
    elif [[ $physical_cores -ge 12 ]]; then
        optimal_jobs=5  # High-end desktop
    elif [[ $physical_cores -ge 8 ]]; then
        optimal_jobs=4  # Performance desktop
    elif [[ $physical_cores -ge 6 ]]; then
        optimal_jobs=3  # Mid-range desktop
    elif [[ $physical_cores -ge 4 ]]; then
        optimal_jobs=2  # Quad-core
    else
        optimal_jobs=1  # Dual-core or less
    fi
    
    # Memory constraint adjustment
    local memory_per_job=$((memory_gb / optimal_jobs))
    if [[ $memory_per_job -lt 2 ]]; then
        # Each conversion job needs at least 2GB
        optimal_jobs=$((memory_gb / 2))
        [[ $optimal_jobs -lt 1 ]] && optimal_jobs=1
    fi
    
    # Don't exceed 75% of logical cores to leave room for system
    local max_jobs_by_cores=$((logical_cores * 75 / 100))
    [[ $optimal_jobs -gt $max_jobs_by_cores ]] && optimal_jobs=$max_jobs_by_cores
    
    # Final bounds check
    [[ $optimal_jobs -lt 1 ]] && optimal_jobs=1
    [[ $optimal_jobs -gt 8 ]] && optimal_jobs=8  # Reasonable maximum
    
    echo "$optimal_jobs"
}

# ðŸ“ˆ Monitor CPU performance during conversion
monitor_cpu_performance() {
    local duration="${1:-5}"  # Default 5 second sample
    
    if command -v vmstat >/dev/null 2>&1; then
        # Use vmstat for CPU utilization
        local cpu_stats=$(vmstat 1 $duration | tail -1)
        local cpu_idle=$(echo $cpu_stats | awk '{print $15}')
        local cpu_usage=$((100 - cpu_idle))
        
        echo "CPU: ${cpu_usage}%"
    elif [[ -f /proc/stat ]]; then
        # Fallback to /proc/stat parsing
        local cpu_usage=$(awk '/^cpu / {usage=($2+$4)*100/($2+$3+$4)} END {printf "%.0f", usage}' /proc/stat 2>/dev/null || echo "0")
        echo "CPU: ${cpu_usage}%"
    else
        echo "CPU: monitoring unavailable"
    fi
}

# ðŸŽ›ï¸ Dynamic CPU scaling detection
detect_cpu_scaling() {
    local scaling_governor="unknown"
    local current_freq="unknown"
    
    # Check CPU frequency scaling governor
    if [[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor ]]; then
        scaling_governor=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || echo "unknown")
    fi
    
    # Check current CPU frequency
    if [[ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq ]]; then
        local freq_khz=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq 2>/dev/null || echo "0")
        if [[ $freq_khz -gt 0 ]]; then
            local freq_mhz=$((freq_khz / 1000))
            local freq_ghz=$(echo "scale=2; $freq_mhz / 1000" | bc 2>/dev/null || echo "0")
            current_freq="${freq_ghz}GHz"
        fi
    fi
    
    echo "governor:$scaling_governor,freq:$current_freq"
}

# ðŸ† CPU Performance Benchmarking
benchmark_cpu_performance() {
    echo -e "${CYAN}${BOLD}ðŸ† CPU PERFORMANCE BENCHMARK${NC}\n"
    echo -e "${YELLOW}Running quick performance test to optimize settings...${NC}"
    
    local logical_cores=$(get_logical_cores)
    local physical_cores=$(get_physical_cores)
    local memory_gb=$(get_available_memory_gb)
    
    # Test different thread configurations
    local test_configs=()
    test_configs+=("$((physical_cores))")
    test_configs+=("$((logical_cores))")
    test_configs+=("$((logical_cores * 75 / 100))")
    test_configs+=("$((physical_cores + physical_cores / 2))")
    
    local best_threads=0
    local best_time=999999
    
    echo -e "${BLUE}Testing thread configurations:${NC}"
    
    for threads in "${test_configs[@]}"; do
        [[ $threads -lt 1 ]] && continue
        [[ $threads -gt $logical_cores ]] && continue
        
        echo -e "  ${CYAN}Testing $threads threads...${NC}"
        
        # Create a small test video
        local test_input="/tmp/cpu_test_$$_input.mp4"
        local test_output="/tmp/cpu_test_$$_output.gif"
        
        # Generate test video (2 seconds, 320x240)
        ffmpeg -f lavfi -i testsrc=duration=2:size=320x240:rate=10 -c:v libx264 -y "$test_input" 2>/dev/null &
        local gen_pid=$!
        wait $gen_pid 2>/dev/null
        
        if [[ -f "$test_input" ]]; then
            # Time the conversion
            local start_time=$(date +%s.%N)
            
            ffmpeg -i "$test_input" -vf "fps=10,scale=160:120:flags=lanczos,palettegen=max_colors=64" -threads $threads -y "/tmp/palette_$$.png" 2>/dev/null &&
            ffmpeg -i "$test_input" -i "/tmp/palette_$$.png" -lavfi "fps=10,scale=160:120:flags=lanczos[x];[x][1:v]paletteuse=dither=bayer" -threads $threads -y "$test_output" 2>/dev/null
            
            local end_time=$(date +%s.%N)
            local duration=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "999")
            
            if [[ -f "$test_output" ]] && [[ $(stat -c%s -- "$test_output" 2>/dev/null || echo "0") -gt 100 ]]; then
                echo -e "    ${GREEN}âœ“ $threads threads: ${duration}s${NC}"
                
                # Check if this is the best time
                local is_better=$(echo "$duration < $best_time" | bc 2>/dev/null || echo "0")
                if [[ $is_better -eq 1 ]]; then
                    best_time=$duration
                    best_threads=$threads
                fi
            else
                echo -e "    ${RED}âŒ $threads threads: failed${NC}"
            fi
            
            # Cleanup test files
            rm -f "$test_output" "/tmp/palette_$$.png" 2>/dev/null
        fi
        
        rm -f "$test_input" 2>/dev/null
        sleep 0.5  # Brief pause between tests
    done
    
    if [[ $best_threads -gt 0 ]]; then
        echo -e "\n${GREEN}ðŸ† Benchmark Results:${NC}"
        echo -e "  ${YELLOW}Optimal thread count: ${BOLD}$best_threads${NC} ${GRAY}(${best_time}s test time)${NC}"
        
        # Update global settings with benchmark results
        FFMPEG_THREADS=$best_threads
        
        # Recalculate parallel jobs based on optimal threads
        local optimal_jobs=$(calculate_optimal_parallel_jobs "$logical_cores" "$physical_cores" "$memory_gb")
        PARALLEL_JOBS=$optimal_jobs
        
        echo -e "  ${YELLOW}Recommended parallel jobs: ${BOLD}$optimal_jobs${NC}"
        echo -e "  ${CYAN}Settings automatically optimized for your CPU!${NC}"
    else
        echo -e "\n${YELLOW}âš ï¸  Benchmark failed, using default settings${NC}"
    fi
    
    echo ""
}

# ðŸ”¥ Performance mode detection and optimization
optimize_for_performance_mode() {
    local cpu_info=$(detect_cpu_architecture)
    local logical_cores=$(get_logical_cores)
    local memory_gb=$(get_available_memory_gb)
    
    echo -e "  ${GREEN}ðŸ”¥ Performance mode optimization:${NC}"
    
    # Check if running in high-performance mode
    local governor=$(detect_cpu_scaling | cut -d',' -f1 | cut -d':' -f2)
    
    if [[ "$governor" == "performance" ]]; then
        echo -e "    ${GREEN}âœ“ Performance governor active${NC}"
        # Slightly increase thread utilization in performance mode
        if [[ "$FFMPEG_THREADS" == "auto" ]]; then
            FFMPEG_THREADS=$logical_cores
        fi
    elif [[ "$governor" == "powersave" ]]; then
        echo -e "    ${YELLOW}âš¡ Power-save mode detected - conservative settings applied${NC}"
        # Use fewer threads in power-save mode
        if [[ "$FFMPEG_THREADS" == "auto" ]]; then
            FFMPEG_THREADS=$((logical_cores * 75 / 100))
            [[ $FFMPEG_THREADS -lt 1 ]] && FFMPEG_THREADS=1
        fi
    else
        echo -e "    ${CYAN}âš™ï¸ Balanced mode detected - optimal settings applied${NC}"
    fi
    
    # Memory-based performance adjustments
    if [[ $memory_gb -ge 32 ]]; then
        echo -e "    ${GREEN}âœ“ High memory system - maximum performance enabled${NC}"
    elif [[ $memory_gb -ge 16 ]]; then
        echo -e "    ${BLUE}âœ“ Good memory available - performance optimized${NC}"
    elif [[ $memory_gb -ge 8 ]]; then
        echo -e "    ${YELLOW}âœ“ Adequate memory - balanced performance${NC}"
    else
        echo -e "    ${YELLOW}âš ï¸  Limited memory - conservative settings applied${NC}"
    fi
}

# ðŸ“¦ Advanced RAM Optimization System
optimize_ram_usage() {
    echo -e "  ${BLUE}ðŸ“¦ Analyzing RAM for conversion acceleration...${NC}"
    
    local memory_gb=$(get_available_memory_gb)
    local total_memory_gb=$(get_total_memory_gb)
    
    echo -e "  ${GREEN}âœ“ Memory Analysis:${NC}"
    echo -e "    ${YELLOW}ðŸ“¦ Total RAM: ${BOLD}${total_memory_gb}GB${NC}"
    echo -e "    ${YELLOW}ðŸ”„ Available RAM: ${BOLD}${memory_gb}GB${NC}"
    
    # Setup RAM disk for temporary files if enough memory
    setup_ram_disk
    
    # Configure FFmpeg memory optimizations
    configure_ffmpeg_memory_options
    
    # Setup intelligent caching
    setup_memory_caching
    
    echo ""
}

# ðŸ“¦ Get total system memory
get_total_memory_gb() {
    local total_memory_gb=1
    
    if command -v free >/dev/null 2>&1; then
        local memory_kb=$(free | awk '/^Mem:/ {print $2}' 2>/dev/null)
        if [[ -n "$memory_kb" && $memory_kb -gt 0 ]]; then
            total_memory_gb=$((memory_kb / 1024 / 1024))
        fi
    elif [[ -f /proc/meminfo ]]; then
        local memory_kb=$(grep "MemTotal" /proc/meminfo | awk '{print $2}' 2>/dev/null)
        if [[ -n "$memory_kb" && $memory_kb -gt 0 ]]; then
            total_memory_gb=$((memory_kb / 1024))
        fi
    fi
    
    [[ $total_memory_gb -lt 1 ]] && total_memory_gb=1
    echo "$total_memory_gb"
}

# ðŸ’¿ Setup RAM disk for ultra-fast temporary storage
setup_ram_disk() {
    local memory_gb=$(get_available_memory_gb)
    local total_memory_gb=$(get_total_memory_gb)
    
    # Only setup RAM disk if we have sufficient memory (8GB+ total, 4GB+ available)
    if [[ $total_memory_gb -ge 8 && $memory_gb -ge 4 && "$RAM_OPTIMIZATION" == "true" ]]; then
        
        # Calculate optimal RAM disk size (10-25% of available RAM)
        local ram_disk_size_mb=0
        if [[ $memory_gb -ge 32 ]]; then
            ram_disk_size_mb=$((memory_gb * 1024 * 25 / 100))  # 25% for high-memory systems
        elif [[ $memory_gb -ge 16 ]]; then
            ram_disk_size_mb=$((memory_gb * 1024 * 20 / 100))  # 20% for good-memory systems
        elif [[ $memory_gb -ge 8 ]]; then
            ram_disk_size_mb=$((memory_gb * 1024 * 15 / 100))  # 15% for adequate-memory systems
        else
            ram_disk_size_mb=$((memory_gb * 1024 * 10 / 100))  # 10% for limited-memory systems
        fi
        
        # Minimum 512MB, maximum 8GB for RAM disk
        [[ $ram_disk_size_mb -lt 512 ]] && ram_disk_size_mb=512
        [[ $ram_disk_size_mb -gt 8192 ]] && ram_disk_size_mb=8192
        
        # Create RAM disk mount point
        RAM_DISK_PATH="$LOG_DIR/ram_cache"
        
        if [[ ! -d "$RAM_DISK_PATH" ]]; then
            mkdir -p "$RAM_DISK_PATH" 2>/dev/null || {
                echo -e "    ${YELLOW}âš ï¸  Cannot create RAM disk directory${NC}"
                return 1
            }
        fi
        
        # Check if already mounted
        if ! mountpoint -q "$RAM_DISK_PATH" 2>/dev/null; then
            # Try to mount RAM disk (tmpfs)
            if mount -t tmpfs -o size=${ram_disk_size_mb}M,mode=0755 tmpfs "$RAM_DISK_PATH" 2>/dev/null; then
                RAM_DISK_ENABLED=true
                echo -e "    ${GREEN}âœ“ RAM disk created: ${BOLD}${ram_disk_size_mb}MB${NC} at $RAM_DISK_PATH"
                echo -e "    ${CYAN}ðŸš€ Temporary files will use ultra-fast RAM storage${NC}"
                
                # Update temp work directory to use RAM disk
                TEMP_WORK_DIR="$RAM_DISK_PATH/work"
                mkdir -p "$TEMP_WORK_DIR" 2>/dev/null
            else
                echo -e "    ${YELLOW}âš ï¸  Cannot mount RAM disk - requires sudo privileges${NC}"
                echo -e "    ${CYAN}ðŸ’¡ Tip: Run 'sudo mount -t tmpfs' or disable RAM_OPTIMIZATION in settings${NC}"
                RAM_DISK_ENABLED=false
            fi
        else
            RAM_DISK_ENABLED=true
            echo -e "    ${GREEN}âœ“ RAM disk already mounted: ${BOLD}${ram_disk_size_mb}MB${NC}"
        fi
    else
        if [[ $total_memory_gb -lt 8 ]]; then
            echo -e "    ${CYAN}ðŸ’» RAM disk disabled: Insufficient memory (${total_memory_gb}GB total)${NC}"
        else
            echo -e "    ${CYAN}ðŸ’» RAM disk disabled: Manual configuration${NC}"
        fi
    fi
}

# ðŸ§® Configure FFmpeg memory optimizations
configure_ffmpeg_memory_options() {
    local memory_gb=$(get_available_memory_gb)
    
    echo -e "  ${GREEN}ðŸ§® FFmpeg memory optimization:${NC}"
    
    # Calculate optimal buffer sizes based on available memory
    if [[ $memory_gb -ge 32 ]]; then
        # High-memory system: Large buffers for maximum performance
        FFMPEG_BUFFER_SIZE="64M"
        FFMPEG_MAX_MUXING_QUEUE="2048"
        echo -e "    ${GREEN}âœ“ High-memory profile: 64MB buffers, 2048 queue${NC}"
    elif [[ $memory_gb -ge 16 ]]; then
        # Good-memory system: Large buffers
        FFMPEG_BUFFER_SIZE="32M"
        FFMPEG_MAX_MUXING_QUEUE="1024"
        echo -e "    ${BLUE}âœ“ Performance profile: 32MB buffers, 1024 queue${NC}"
    elif [[ $memory_gb -ge 8 ]]; then
        # Adequate memory: Moderate buffers
        FFMPEG_BUFFER_SIZE="16M"
        FFMPEG_MAX_MUXING_QUEUE="512"
        echo -e "    ${YELLOW}âœ“ Balanced profile: 16MB buffers, 512 queue${NC}"
    else
        # Limited memory: Small buffers
        FFMPEG_BUFFER_SIZE="8M"
        FFMPEG_MAX_MUXING_QUEUE="256"
        echo -e "    ${CYAN}âœ“ Conservative profile: 8MB buffers, 256 queue${NC}"
    fi
    
    # Set memory-related FFmpeg options
    FFMPEG_MEMORY_OPTS="-max_muxing_queue_size $FFMPEG_MAX_MUXING_QUEUE"
    
    # Set input-specific options (for placement before input files)
    FFMPEG_INPUT_OPTS=""
    if [[ $memory_gb -ge 8 ]]; then
        # Check if readrate_initial_burst is supported (FFmpeg 5.0+)
        if ffmpeg -h full 2>&1 | grep -q "readrate_initial_burst"; then
            FFMPEG_INPUT_OPTS="-readrate_initial_burst 2.0"
        fi
    fi
}

# ðŸ“Š Setup intelligent memory caching
setup_memory_caching() {
    local memory_gb=$(get_available_memory_gb)
    
    echo -e "  ${GREEN}ðŸ“Š Memory caching optimization:${NC}"
    
    # Configure system cache behavior
    if command -v sysctl >/dev/null 2>&1; then
        # Check current cache settings
        local vm_swappiness=$(sysctl -n vm.swappiness 2>/dev/null || echo "60")
        local vm_cache_pressure=$(sysctl -n vm.vfs_cache_pressure 2>/dev/null || echo "100")
        
        if [[ $memory_gb -ge 8 ]]; then
            echo -e "    ${CYAN}âš™ï¸  Current cache settings: swappiness=$vm_swappiness, cache_pressure=$vm_cache_pressure${NC}"
            
            # Recommend optimal settings for video processing
            if [[ $vm_swappiness -gt 20 ]]; then
                echo -e "    ${YELLOW}ðŸ’¡ Tip: Lower swappiness recommended for better performance${NC}"
                echo -e "    ${GRAY}      sudo sysctl vm.swappiness=10${NC}"
            fi
            
            if [[ $vm_cache_pressure -gt 50 ]]; then
                echo -e "    ${YELLOW}ðŸ’¡ Tip: Lower cache pressure can improve file I/O${NC}"
                echo -e "    ${GRAY}      sudo sysctl vm.vfs_cache_pressure=50${NC}"
            fi
        fi
    fi
    
    # Setup file system cache hints
    if [[ $memory_gb -ge 16 ]]; then
        echo -e "    ${GREEN}âœ“ Large file caching enabled${NC}"
        USE_CACHE_HINTS=true
    else
        echo -e "    ${CYAN}âœ“ Standard caching profile${NC}"
        USE_CACHE_HINTS=false
    fi
}

# ðŸš€ Get optimized temporary file path
get_temp_file_path() {
    local base_name="$1"
    local extension="$2"
    
    if [[ "$RAM_DISK_ENABLED" == "true" && -d "$TEMP_WORK_DIR" ]]; then
        # Use ultra-fast RAM disk for temporary files
        echo "$TEMP_WORK_DIR/${base_name}.${extension}"
    else
        # Fall back to regular temp directory
        echo "$TEMP_WORK_DIR/${base_name}.${extension}"
    fi
}

# ðŸ§¹ Cleanup RAM disk on exit
cleanup_ram_disk() {
    if [[ "$RAM_DISK_ENABLED" == "true" && -n "$RAM_DISK_PATH" ]]; then
        echo -e "${BLUE}ðŸ§¹ Cleaning up RAM disk...${NC}"
        
        # Remove all files from RAM disk
        if [[ -d "$RAM_DISK_PATH" ]]; then
            rm -rf "$RAM_DISK_PATH"/* 2>/dev/null || true
            
            # Unmount RAM disk
            if mountpoint -q "$RAM_DISK_PATH" 2>/dev/null; then
                umount "$RAM_DISK_PATH" 2>/dev/null && echo -e "  ${GREEN}âœ“ RAM disk unmounted${NC}" || echo -e "  ${YELLOW}âš ï¸  RAM disk unmount failed${NC}"
            fi
        fi
    fi
}

# ðŸ“ˆ Monitor memory usage during conversion
monitor_memory_usage() {
    if command -v free >/dev/null 2>&1; then
        local mem_info=$(free -h | awk '/^Mem:/ {printf "Used: %s/%s (%.0f%%), Available: %s", $3, $2, $3*100/$2, $7}')
        echo "RAM: $mem_info"
    else
        echo "RAM: monitoring unavailable"
    fi
}

# ðŸ”¥ Preload files into memory cache (for multiple conversions)
preload_files_to_cache() {
    local files=("$@")
    local memory_gb=$(get_available_memory_gb)
    
    # Only preload if we have sufficient memory
    if [[ $memory_gb -ge 8 && ${#files[@]} -gt 1 ]]; then
        echo -e "${CYAN}ðŸ”¥ Preloading files into memory cache...${NC}"
        
        local total_size=0
        local preload_count=0
        
        for file in "${files[@]}"; do
            if [[ -f "$file" ]]; then
                local file_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
                local file_size_mb=$((file_size / 1024 / 1024))
                
                # Only preload files smaller than 500MB each and total < 2GB
                if [[ $file_size_mb -lt 500 && $total_size -lt 2048 ]]; then
                    # Use dd to read file into cache without outputting
                    dd if="$file" of=/dev/null bs=1M 2>/dev/null &
                    local dd_pid=$!
                    
                    # Don't wait too long for each file
                    sleep 0.1
                    
                    if kill -0 $dd_pid 2>/dev/null; then
                        # Still running, let it continue in background
                        echo -e "  ${GREEN}âœ“ Caching: $(basename -- "$file") (${file_size_mb}MB)${NC}"
                    fi
                    
                    total_size=$((total_size + file_size_mb))
                    ((preload_count++))
                fi
            fi
        done
        
        if [[ $preload_count -gt 0 ]]; then
            echo -e "  ${GREEN}âœ“ Preloaded $preload_count files (${total_size}MB) into memory cache${NC}"
        fi
    fi
}

# ðŸ” Detect Linux distribution and package manager
detect_distro() {
    local distro="unknown"
    local package_manager="unknown"
    local install_cmd=""
    
    # Check /etc/os-release first (most reliable)
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        local distro_id="${ID,,}"  # Lowercase for comparison
        local distro_id_like="${ID_LIKE,,}"
        
        case "$distro_id" in
            ubuntu|debian|linuxmint|pop|elementary|neon|zorin|mx|raspbian|kali)
                distro="debian-based"
                package_manager="apt"
                install_cmd="sudo apt update && sudo apt install -y"
                ;;
            fedora|rhel|centos|rocky|almalinux|oraclelinux)
                distro="redhat-based"
                package_manager="dnf"
                install_cmd="sudo dnf install -y"
                ;;
            arch|manjaro|endeavouros|garuda|cachyos|artix|parabola|blackarch|arcolinux)
                distro="arch-based"
                package_manager="pacman"
                install_cmd="sudo pacman -S --needed"
                ;;
            opensuse*|sles|suse)
                distro="suse-based"
                package_manager="zypper"
                install_cmd="sudo zypper install -y"
                ;;
            alpine)
                distro="alpine"
                package_manager="apk"
                install_cmd="sudo apk add"
                ;;
            gentoo)
                distro="gentoo"
                package_manager="emerge"
                install_cmd="sudo emerge -av"
                ;;
            void)
                distro="void"
                package_manager="xbps"
                install_cmd="sudo xbps-install -y"
                ;;
            *)
                # Check ID_LIKE for derivative distributions
                if [[ "$distro_id_like" == *"debian"* ]] || [[ "$distro_id_like" == *"ubuntu"* ]]; then
                    distro="debian-based"
                    package_manager="apt"
                    install_cmd="sudo apt update && sudo apt install -y"
                elif [[ "$distro_id_like" == *"fedora"* ]] || [[ "$distro_id_like" == *"rhel"* ]]; then
                    distro="redhat-based"
                    package_manager="dnf"
                    install_cmd="sudo dnf install -y"
                elif [[ "$distro_id_like" == *"arch"* ]]; then
                    distro="arch-based"
                    package_manager="pacman"
                    install_cmd="sudo pacman -S --needed"
                elif [[ "$distro_id_like" == *"suse"* ]]; then
                    distro="suse-based"
                    package_manager="zypper"
                    install_cmd="sudo zypper install -y"
                else
                    distro="$ID"
                fi
                ;;
        esac
    fi
    
    # Fallback detection methods
    if [[ "$distro" == "unknown" ]]; then
        if command -v apt >/dev/null 2>&1; then
            distro="debian-based"
            package_manager="apt"
            install_cmd="sudo apt update && sudo apt install -y"
        elif command -v dnf >/dev/null 2>&1; then
            distro="redhat-based"
            package_manager="dnf"
            install_cmd="sudo dnf install -y"
        elif command -v yum >/dev/null 2>&1; then
            distro="redhat-based"
            package_manager="yum"
            install_cmd="sudo yum install -y"
        elif command -v pacman >/dev/null 2>&1; then
            distro="arch-based"
            package_manager="pacman"
            install_cmd="sudo pacman -S --needed"
        elif command -v zypper >/dev/null 2>&1; then
            distro="suse-based"
            package_manager="zypper"
            install_cmd="sudo zypper install -y"
        elif command -v apk >/dev/null 2>&1; then
            distro="alpine"
            package_manager="apk"
            install_cmd="sudo apk add"
        fi
    fi
    
    echo "$distro|$package_manager|$install_cmd"
}

# ðŸ› ï¸ Get package names for different distributions
get_package_names() {
    local tool="$1"
    local distro="$2"
    
    case "$tool" in
        "ffmpeg")
            case "$distro" in
                "debian-based") echo "ffmpeg" ;;
                "redhat-based") echo "ffmpeg" ;;
                "arch-based") echo "ffmpeg" ;;
                "suse-based") echo "ffmpeg-4" ;;
                "alpine") echo "ffmpeg" ;;
                "gentoo") echo "media-video/ffmpeg" ;;
                "void") echo "ffmpeg" ;;
                *) echo "ffmpeg" ;;
            esac
            ;;
        "gifsicle")
            case "$distro" in
                "debian-based") echo "gifsicle" ;;
                "redhat-based") echo "gifsicle" ;;
                "arch-based") echo "gifsicle" ;;
                "suse-based") echo "gifsicle" ;;
                "alpine") echo "gifsicle" ;;
                "gentoo") echo "media-gfx/gifsicle" ;;
                "void") echo "gifsicle" ;;
                *) echo "gifsicle" ;;
            esac
            ;;
        "jq")
            case "$distro" in
                "debian-based") echo "jq" ;;
                "redhat-based") echo "jq" ;;
                "arch-based") echo "jq" ;;
                "suse-based") echo "jq" ;;
                "alpine") echo "jq" ;;
                "gentoo") echo "app-misc/jq" ;;
                "void") echo "jq" ;;
                *) echo "jq" ;;
            esac
            ;;
        "convert")
            # ImageMagick (convert command)
            case "$distro" in
                "debian-based") echo "imagemagick" ;;
                "redhat-based") echo "ImageMagick" ;;
                "arch-based") echo "imagemagick" ;;
                "suse-based") echo "ImageMagick" ;;
                "alpine") echo "imagemagick" ;;
                "gentoo") echo "media-gfx/imagemagick" ;;
                "void") echo "ImageMagick" ;;
                *) echo "imagemagick" ;;
            esac
            ;;
        "xxhsum")
            # xxhash CLI (accept any variant; package names below)
            case "$distro" in
                "debian-based") echo "xxhash" ;;
                "redhat-based") echo "xxhash" ;;
                "arch-based") echo "xxhash" ;;
                "suse-based") echo "xxhash" ;;
                "alpine") echo "xxhash" ;;
                "gentoo") echo "app-crypt/xxhash" ;;
                "void") echo "xxHash" ;;
                *) echo "xxhash" ;;
            esac
            ;;
        "git")
            case "$distro" in
                "debian-based") echo "git" ;;
                "redhat-based") echo "git" ;;
                "arch-based") echo "git" ;;
                "suse-based") echo "git" ;;
                "alpine") echo "git" ;;
                "gentoo") echo "dev-vcs/git" ;;
                "void") echo "git" ;;
                *) echo "git" ;;
            esac
            ;;
        "curl")
            case "$distro" in
                "debian-based") echo "curl" ;;
                "redhat-based") echo "curl" ;;
                "arch-based") echo "curl" ;;
                "suse-based") echo "curl" ;;
                "alpine") echo "curl" ;;
                "gentoo") echo "net-misc/curl" ;;
                "void") echo "curl" ;;
                *) echo "curl" ;;
            esac
            ;;
        "tmux")
            case "$distro" in
                "debian-based") echo "tmux" ;;
                "redhat-based") echo "tmux" ;;
                "arch-based") echo "tmux" ;;
                "suse-based") echo "tmux" ;;
                "alpine") echo "tmux" ;;
                "gentoo") echo "app-misc/tmux" ;;
                "void") echo "tmux" ;;
                *) echo "tmux" ;;
            esac
            ;;
        "notify-send")
            case "$distro" in
                "debian-based") echo "libnotify-bin" ;;
                "redhat-based") echo "libnotify" ;;
                "arch-based") echo "libnotify" ;;
                "suse-based") echo "libnotify-tools" ;;
                "alpine") echo "libnotify" ;;
                "gentoo") echo "x11-libs/libnotify" ;;
                "void") echo "libnotify" ;;
                *) echo "libnotify" ;;
            esac
            ;;
        "parallel")
            case "$distro" in
                "debian-based") echo "parallel" ;;
                "redhat-based") echo "parallel" ;;
                "arch-based") echo "parallel" ;;
                "suse-based") echo "gnu_parallel" ;;
                "alpine") echo "parallel" ;;
                "gentoo") echo "sys-process/parallel" ;;
                "void") echo "parallel" ;;
                *) echo "parallel" ;;
            esac
            ;;
    esac
}

# ðŸ“ Show manual installation instructions
show_manual_install_instructions() {
    local missing_tools=("$@")
    
    echo -e "${YELLOW}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YELLOW}${BOLD}â•‘          ðŸ“ MANUAL INSTALLATION REQUIRED                   â•‘${NC}"
    echo -e "${YELLOW}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${RED}Missing dependencies:${NC}"
    for tool in "${missing_tools[@]}"; do
        echo -e "  ${RED}â€¢ $tool${NC}"
    done
    echo ""
    echo -e "${CYAN}${BOLD}Installation commands by distribution:${NC}"
    echo ""
    
    # Debian/Ubuntu
    echo -e "${GREEN}Debian/Ubuntu/Linux Mint/Pop!_OS:${NC}"
    echo -e "  ${CYAN}sudo apt update && sudo apt install -y"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " imagemagick" ;;
            "notify-send") echo -n " libnotify-bin" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # Fedora/RHEL/CentOS
    echo -e "${GREEN}Fedora/RHEL/CentOS/Rocky/AlmaLinux:${NC}"
    echo -e "  ${CYAN}sudo dnf install -y"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " ImageMagick" ;;
            "notify-send") echo -n " libnotify" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # Arch Linux
    echo -e "${GREEN}Arch Linux/Manjaro/EndeavourOS:${NC}"
    echo -e "  ${CYAN}sudo pacman -S --needed"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " imagemagick" ;;
            "notify-send") echo -n " libnotify" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # openSUSE
    echo -e "${GREEN}openSUSE Tumbleweed/Leap:${NC}"
    echo -e "  ${CYAN}sudo zypper install -y"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg-4" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " ImageMagick" ;;
            "notify-send") echo -n " libnotify-tools" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " gnu_parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # Alpine
    echo -e "${GREEN}Alpine Linux:${NC}"
    echo -e "  ${CYAN}sudo apk add"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " imagemagick" ;;
            "notify-send") echo -n " libnotify" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # Gentoo
    echo -e "${GREEN}Gentoo:${NC}"
    echo -e "  ${CYAN}sudo emerge -av"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " media-video/ffmpeg" ;;
            "git") echo -n " dev-vcs/git" ;;
            "curl") echo -n " net-misc/curl" ;;
            "tmux") echo -n " app-misc/tmux" ;;
            "gifsicle") echo -n " media-gfx/gifsicle" ;;
            "jq") echo -n " app-misc/jq" ;;
            "convert") echo -n " media-gfx/imagemagick" ;;
            "notify-send") echo -n " x11-libs/libnotify" ;;
            "xxhsum") echo -n " app-crypt/xxhash" ;;
            "parallel") echo -n " sys-process/parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # Void Linux
    echo -e "${GREEN}Void Linux:${NC}"
    echo -e "  ${CYAN}sudo xbps-install -y"
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n " ffmpeg" ;;
            "git") echo -n " git" ;;
            "curl") echo -n " curl" ;;
            "tmux") echo -n " tmux" ;;
            "gifsicle") echo -n " gifsicle" ;;
            "jq") echo -n " jq" ;;
            "convert") echo -n " ImageMagick" ;;
            "notify-send") echo -n " libnotify" ;;
            "xxhsum") echo -n " xxhash" ;;
            "parallel") echo -n " parallel" ;;
        esac
    done
    echo -e "${NC}"
    echo ""
    
    # NixOS (special case)
    echo -e "${GREEN}NixOS:${NC}"
    echo -e "  ${CYAN}nix-env -iA nixos."
    for tool in "${missing_tools[@]}"; do
        case "$tool" in
            "ffmpeg") echo -n "ffmpeg " ;;
            "git") echo -n "git " ;;
            "curl") echo -n "curl " ;;
            "tmux") echo -n "tmux " ;;
            "gifsicle") echo -n "gifsicle " ;;
            "jq") echo -n "jq " ;;
            "convert") echo -n "imagemagick " ;;
            "notify-send") echo -n "libnotify " ;;
            "parallel") echo -n "parallel " ;;
        esac
    done
    echo -e "${NC}"
    echo -e "  ${GRAY}Or add to configuration.nix: environment.systemPackages${NC}"
    echo ""
    
    echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "${BLUE}ðŸ’¡ After installing, restart your terminal or run: ${CYAN}hash -r${NC}"
    echo -e "${BLUE}ðŸ”— Official package search:${NC}"
    echo -e "  ${GRAY}- Debian/Ubuntu: ${CYAN}https://packages.debian.org/ or https://packages.ubuntu.com/${NC}"
    echo -e "  ${GRAY}- Arch: ${CYAN}https://archlinux.org/packages/${NC}"
    echo -e "  ${GRAY}- Fedora: ${CYAN}https://packages.fedoraproject.org/${NC}"
    echo -e "  ${GRAY}- openSUSE: ${CYAN}https://software.opensuse.org/${NC}"
    echo ""
}

# ðŸš€ Auto-install dependencies with user confirmation
auto_install_dependencies() {
    local missing_tools=("$@")
    local distro_info=$(detect_distro)
    local distro=$(echo "$distro_info" | cut -d'|' -f1)
    local package_manager=$(echo "$distro_info" | cut -d'|' -f2)
    local install_cmd=$(echo "$distro_info" | cut -d'|' -f3)
    
    if [[ "$package_manager" == "unknown" ]]; then
        echo -e "${RED}âŒ Cannot detect package manager for auto-installation${NC}"
        show_manual_install_instructions "${missing_tools[@]}"
        return 1
    fi
    
    echo -e "\n${CYAN}${BOLD}ðŸ”§ DEPENDENCY INSTALLER${NC}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}Detected OS:${NC} $distro"
    echo -e "${GREEN}Package Manager:${NC} $package_manager"
    echo -e "${GREEN}Missing Tools:${NC} ${missing_tools[*]}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    # Build package list
    local packages_to_install=()
    for tool in "${missing_tools[@]}"; do
        local package_name=$(get_package_names "$tool" "$distro")
        if [[ -n "$package_name" ]]; then
            packages_to_install+=("$package_name")
        fi
    done
    
    if [[ ${#packages_to_install[@]} -eq 0 ]]; then
        echo -e "${RED}âŒ No packages found for installation${NC}"
        return 1
    fi
    
    echo -e "\n${YELLOW}The following packages will be installed:${NC}"
    for package in "${packages_to_install[@]}"; do
        echo -e "  ${GREEN}â€¢ $package${NC}"
    done
    
    echo -e "\n${MAGENTA}Install command:${NC}"
    echo -e "  ${CYAN}$install_cmd ${packages_to_install[*]}${NC}"
    
    echo -ne "\n${YELLOW}Would you like to install these dependencies now? [Y/n]:${NC} "
    read -r install_choice
    
    if [[ "$install_choice" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Installation cancelled. Please install dependencies manually.${NC}"
        return 1
    fi
    
    echo -e "\n${BLUE}ðŸš€ Installing dependencies...${NC}"
    
    # Execute installation command
    if eval "$install_cmd ${packages_to_install[*]}"; then
        echo -e "\n${GREEN}âœ… Dependencies installed successfully!${NC}"
        
        # Verify installation
        echo -e "\n${CYAN}ðŸ” Verifying installation...${NC}"
        local verification_failed=false
        for tool in "${missing_tools[@]}"; do
            if command -v "$tool" >/dev/null 2>&1; then
                local version=$("$tool" --version 2>/dev/null | head -1 | cut -d' ' -f1-3 || echo "unknown version")
                echo -e "  ${GREEN}âœ“ $tool: $version${NC}"
            else
                echo -e "  ${RED}âŒ $tool: still not found${NC}"
                verification_failed=true
            fi
        done
        
        if [[ "$verification_failed" == "true" ]]; then
            echo -e "\n${YELLOW}âš ï¸  Some dependencies may require a shell restart or PATH update${NC}"
            echo -e "${CYAN}Try running: hash -r${NC}"
            return 1
        else
            echo -e "\n${GREEN}ðŸŽ‰ All dependencies are now available!${NC}"
            return 0
        fi
    else
        echo -e "\n${RED}âŒ Installation failed!${NC}"
        echo -e "${YELLOW}âš ï¸  This could be due to:${NC}"
        echo -e "  ${GRAY}â€¢ Insufficient permissions (try with sudo)${NC}"
        echo -e "  ${GRAY}â€¢ Network issues${NC}"
        echo -e "  ${GRAY}â€¢ Package not available in your repositories${NC}"
        echo -e "  ${GRAY}â€¢ Repository needs to be updated first${NC}"
        echo ""
        show_manual_install_instructions "${missing_tools[@]}"
        return 1
    fi
}

# ðŸ”„ Dynamic file detection during conversion
monitor_new_files() {
    local initial_files=("$@")
    local monitoring_enabled="$DYNAMIC_FILE_DETECTION"
    local check_interval="$FILE_MONITOR_INTERVAL"
    
    [[ "$monitoring_enabled" != "true" ]] && return 0
    
    echo -e "${CYAN}ðŸ” Dynamic file monitoring enabled (checking every ${check_interval}s)${NC}"
    
    # Run in background to avoid blocking main conversion
    (
        local last_check_files=("${initial_files[@]}")
        
        while true; do
            sleep "$check_interval"
            
            # Check if main conversion process is still running
            if ! kill -0 "$$" 2>/dev/null; then
                break
            fi
            
            # Scan for new video files
            local current_files=()
            shopt -s nullglob
            for file in *.mp4 *.avi *.mov *.mkv *.webm; do
                [[ -f "$file" && -r "$file" ]] && current_files+=("$file")
            done
            shopt -u nullglob
            
            # Find new files by comparing with previous scan
            local new_files=()
            for current_file in "${current_files[@]}"; do
                local is_new=true
                for last_file in "${last_check_files[@]}"; do
                    if [[ "$current_file" == "$last_file" ]]; then
                        is_new=false
                        break
                    fi
                done
                
                if [[ "$is_new" == "true" ]]; then
                    # Verify it's a valid video file and not being written
                    local file_size1=$(stat -c%s -- "$current_file" 2>/dev/null || echo "0")
                    sleep 1
                    local file_size2=$(stat -c%s -- "$current_file" 2>/dev/null || echo "0")
                    
                    # Only add if file size is stable (not being written)
                    if [[ $file_size1 -eq $file_size2 && $file_size1 -gt 1024 ]]; then
                        new_files+=("$current_file")
                    fi
                fi
            done
            
            # Notify about new files if found
            if [[ ${#new_files[@]} -gt 0 ]]; then
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DYNAMIC SCAN: Found ${#new_files[@]} new file(s)"
                    for new_file in "${new_files[@]}"; do
                        local file_size=$(stat -c%s -- "$new_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] NEW FILE DETECTED: $(basename -- "$new_file") ($file_size)"
                    done
                } >> "$CONVERSION_LOG" 2>/dev/null || true
                
                # Create notification file for main process
                echo "${new_files[*]}" > "/tmp/smart_gif_converter_new_files_$$" 2>/dev/null || true
            fi
            
            last_check_files=("${current_files[@]}")
        done
    ) &
    
    local monitor_pid=$!
    echo "$monitor_pid" > "/tmp/smart_gif_converter_monitor_pid_$$" 2>/dev/null || true
    
    # Add to script cleanup
    SCRIPT_FFMPEG_PIDS+=("$monitor_pid")
}

# ðŸ“¥ Check for newly detected files during conversion
check_for_new_files() {
    [[ "$DYNAMIC_FILE_DETECTION" != "true" ]] && return 0
    
    local new_files_file="/tmp/smart_gif_converter_new_files_$$"
    
    if [[ -f "$new_files_file" ]]; then
        local new_files_content=$(cat "$new_files_file" 2>/dev/null || true)
        
        if [[ -n "$new_files_content" ]]; then
            echo -e "\n${YELLOW}ðŸ†• New video files detected during conversion!${NC}"
            
            # Parse the new files
            local new_files_array=($new_files_content)
            
            for new_file in "${new_files_array[@]}"; do
                if [[ -f "$new_file" ]]; then
                    local file_size=$(stat -c%s -- "$new_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
                    echo -e "  ${CYAN}ðŸ“„ $(basename -- "$new_file") (${file_size})${NC}"
                fi
            done
            
            echo -e "\n${MAGENTA}These files will be available for the next conversion run.${NC}"
            echo -e "${BLUE}ðŸ’¡ Tip: Run the script again to convert the new files${NC}"
            
            # Clean up notification file
            rm -f "$new_files_file" 2>/dev/null || true
        fi
    fi
}

# ðŸ›‘ Stop file monitoring
stop_file_monitoring() {
    local monitor_pid_file="/tmp/smart_gif_converter_monitor_pid_$$"
    
    if [[ -f "$monitor_pid_file" ]]; then
        local monitor_pid=$(cat "$monitor_pid_file" 2>/dev/null || true)
        
        if [[ -n "$monitor_pid" ]]; then
            kill "$monitor_pid" 2>/dev/null || true
            wait "$monitor_pid" 2>/dev/null || true
        fi
        
        rm -f "$monitor_pid_file" 2>/dev/null || true
    fi
    
    # Clean up any notification files
    rm -f "/tmp/smart_gif_converter_new_files_$$" 2>/dev/null || true
}

# ðŸ” Detect package manager and distro
detect_package_manager() {
    if command -v zypper >/dev/null 2>&1; then
        echo "zypper"
    elif command -v apt >/dev/null 2>&1; then
        echo "apt"
    elif command -v dnf >/dev/null 2>&1; then
        echo "dnf"
    elif command -v yum >/dev/null 2>&1; then
        echo "yum"
    elif command -v pacman >/dev/null 2>&1; then
        echo "pacman"
    elif command -v apk >/dev/null 2>&1; then
        echo "apk"
    elif command -v emerge >/dev/null 2>&1; then
        echo "emerge"
    elif command -v xbps-install >/dev/null 2>&1; then
        echo "xbps"
    else
        echo "unknown"
    fi
}

# ðŸ“¦ Map tool name to package name per distro
get_package_name() {
    local tool="$1"
    local pkg_manager="$2"
    
    case "$tool" in
        "ffmpeg")
            case "$pkg_manager" in
                "zypper") echo "ffmpeg-7" ;;
                "apt") echo "ffmpeg" ;;
                "dnf"|"yum") echo "ffmpeg" ;;
                "pacman") echo "ffmpeg" ;;
                "apk") echo "ffmpeg" ;;
                "emerge") echo "media-video/ffmpeg" ;;
                "xbps") echo "ffmpeg" ;;
                *) echo "ffmpeg" ;;
            esac
            ;;
        "gifsicle")
            echo "gifsicle"
            ;;
        "jq")
            echo "jq"
            ;;
        "convert")
            case "$pkg_manager" in
                "zypper") echo "ImageMagick" ;;
                "apt") echo "imagemagick" ;;
                "dnf"|"yum") echo "ImageMagick" ;;
                "pacman") echo "imagemagick" ;;
                "apk") echo "imagemagick" ;;
                "emerge") echo "media-gfx/imagemagick" ;;
                "xbps") echo "ImageMagick" ;;
                *) echo "imagemagick" ;;
            esac
            ;;
        "git")
            echo "git"
            ;;
        "curl")
            echo "curl"
            ;;
        "tmux")
            echo "tmux"
            ;;
        "notify-send")
            case "$pkg_manager" in
                "zypper") echo "libnotify-tools" ;;
                "apt") echo "libnotify-bin" ;;
                "dnf"|"yum") echo "libnotify" ;;
                "pacman") echo "libnotify" ;;
                "apk") echo "libnotify" ;;
                "emerge") echo "libnotify" ;;
                "xbps") echo "libnotify" ;;
                *) echo "libnotify" ;;
            esac
            ;;
        "xxhsum"|"xxh64sum"|"xxh128sum")
            case "$pkg_manager" in
                "zypper") echo "xxhash" ;;
                "apt") echo "xxhash" ;;
                "dnf"|"yum") echo "xxhash" ;;
                "pacman") echo "xxhash" ;;
                "apk") echo "xxhash" ;;
                "emerge") echo "app-crypt/xxhash" ;;
                "xbps") echo "xxHash" ;;
                *) echo "xxhash" ;;
            esac
            ;;
        *)
            echo "$tool"
            ;;
    esac
}

# ðŸ”„ Check if a package update is available
check_package_update_available() {
    local tool="$1"
    local pkg_manager=$(detect_package_manager)
    local package_name=$(get_package_name "$tool" "$pkg_manager")
    local update_available=false
    local installed_version=""
    local available_version=""
    local update_command=""
    
    case "$pkg_manager" in
        "zypper")
            # Special handling for FFmpeg versioning on openSUSE
            if [[ "$tool" == "ffmpeg" ]]; then
                local installed_pkg=$(rpm -qa | grep -E '^ffmpeg-[0-9]' | head -1)
                if [[ -n "$installed_pkg" ]]; then
                    installed_version=$(echo "$installed_pkg" | grep -oP 'ffmpeg-\K[0-9]+')
                    # Check if ffmpeg-7 is available
                    if zypper search -s ffmpeg-7 2>/dev/null | grep -q "^i.*ffmpeg-7"; then
                        # Already on ffmpeg-7
                        return 0
                    elif zypper search -s ffmpeg-7 2>/dev/null | grep -q "ffmpeg-7"; then
                        if [[ "$installed_version" -lt 7 ]]; then
                            update_available=true
                            available_version="7"
                            update_command="sudo zypper install --allow-vendor-change ffmpeg-7"
                        fi
                    fi
                fi
            else
                # Check if update available using zypper
                if zypper list-updates 2>/dev/null | grep -q "^v.*$package_name"; then
                    update_available=true
                    update_command="sudo zypper update $package_name"
                fi
            fi
            ;;
        "apt")
            # Check with apt
            apt list --upgradable 2>/dev/null | grep -q "^$package_name/" && {
                update_available=true
                update_command="sudo apt update && sudo apt upgrade $package_name"
            }
            ;;
        "dnf")
            # Check with dnf
            dnf check-update "$package_name" >/dev/null 2>&1 && {
                update_available=true
                update_command="sudo dnf update $package_name"
            }
            ;;
        "yum")
            # Check with yum
            yum check-update "$package_name" >/dev/null 2>&1 && {
                update_available=true
                update_command="sudo yum update $package_name"
            }
            ;;
        "pacman")
            # Check with pacman
            pacman -Qu 2>/dev/null | grep -q "^$package_name " && {
                update_available=true
                update_command="sudo pacman -Syu $package_name"
            }
            ;;
    esac
    
    if [[ "$update_available" == true ]]; then
        if [[ "$tool" == "ffmpeg" && -n "$available_version" ]]; then
            echo -e "    ${YELLOW}âš ï¸  Newer version available: ffmpeg-$available_version (you have ffmpeg-$installed_version)${NC}"
        else
            echo -e "    ${YELLOW}âš ï¸  Update available for $tool${NC}"
        fi
        echo -e "    ${CYAN}ðŸ’¡ Update: $update_command${NC}"
        
        # Store for batch update prompt
        OUTDATED_PACKAGES+=("$tool:$update_command")
        return 1
    fi
    
    return 0
}

# ðŸ” Enhanced system requirements check with intelligent caching
check_dependencies() {
    local cache_file="$LOG_DIR/.dependency_cache"
    local cache_validity_hours=24  # Cache valid for 24 hours
    local force_check=false
    
    # Check if cache exists and is recent
    if [[ -f "$cache_file" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y -- "$cache_file" 2>/dev/null || echo 0)))
        local cache_max_age=$((cache_validity_hours * 3600))
        
        if [[ $cache_age -lt $cache_max_age ]]; then
            # Cache is still valid - load cached results, but sanity-check presence of required tools
            if source "$cache_file" 2>/dev/null; then
                local sanity_missing=()
                local sanity_required=("ffmpeg" "git" "curl" "tmux" "notify-send" "gifsicle" "jq" "convert" "xxhsum" "parallel")
                for t in "${sanity_required[@]}"; do
                    if [[ "$t" == "xxhsum" ]]; then
                        if ! command -v xxh128sum >/dev/null 2>&1 && \
                           ! command -v xxh64sum  >/dev/null 2>&1 && \
                           ! command -v xxhsum    >/dev/null 2>&1; then
                            sanity_missing+=("xxhsum")
                        fi
                    else
                        command -v "$t" >/dev/null 2>&1 || sanity_missing+=("$t")
                    fi
                done
                if [[ ${#sanity_missing[@]} -eq 0 ]]; then
                    echo -e "${GREEN}âœ“ Dependencies verified (cached)${NC}"
                    return 0
                else
                    force_check=true
                fi
            else
                force_check=true
            fi
        else
            force_check=true
        fi
    else
        force_check=true
    fi
    
    # Perform full check if needed
    echo -e "${CYAN}ðŸ” Checking system dependencies...${NC}"
    
    # Promote all former optional tools to required
    local required_tools=("ffmpeg" "git" "curl" "tmux" "notify-send" "gifsicle" "jq" "convert" "xxhsum" "parallel")
    local optional_tools=()  # none
    local missing_required=()
    local missing_optional=()
    local outdated_tools=()
    
    # Initialize global array for outdated packages
    OUTDATED_PACKAGES=()
    
    # Check required tools
    for tool in "${required_tools[@]}"; do
        # Special handling for xxhash: accept any variant, require if none present
        if [[ "$tool" == "xxhsum" ]]; then
            if ! command -v xxh128sum >/dev/null 2>&1 && \
               ! command -v xxh64sum  >/dev/null 2>&1 && \
               ! command -v xxhsum    >/dev/null 2>&1; then
                # Require xxhash via its CLI alias; package resolver maps it per distro
                missing_required+=("xxhsum")
                continue
            fi
            # Show version for whichever variant exists
            local version=""
            if command -v xxh128sum >/dev/null 2>&1; then
                version=$(xxh128sum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
            elif command -v xxh64sum >/dev/null 2>&1; then
                version=$(xxh64sum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
            else
                version=$(xxhsum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
            fi
            echo -e "  ${GREEN}âœ“ xxhash: $version${NC}"
            # Use the logical tool name for update checks (maps to package name via get_package_name)
            check_package_update_available "xxhsum" 2>/dev/null
            continue
        fi
        
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_required+=("$tool")
        else
            # Get version info based on tool-specific flags
            local version=""
            case "$tool" in
                "git")
                    version=$(git --version 2>/dev/null | head -1 || echo "unknown version")
                    ;;
                "curl")
                    version=$(curl --version 2>/dev/null | head -1 || echo "unknown version")
                    ;;
                "ffmpeg")
                    version=$(ffmpeg -version 2>/dev/null | head -1 | cut -d' ' -f1-3 || echo "unknown version")
                    ;;
                "tmux")
                    version=$(tmux -V 2>/dev/null || echo "unknown version")
                    ;;
                "notify-send")
                    version=$(notify-send --version 2>/dev/null | head -1 || echo "available")
                    ;;
                "gifsicle")
                    version=$(gifsicle --version 2>/dev/null | head -1 || echo "available")
                    ;;
                "jq")
                    version=$(jq --version 2>/dev/null || echo "available")
                    ;;
                "convert")
                    version=$(convert -version 2>/dev/null | head -1 | sed 's/Version: ImageMagick /ImageMagick /' || echo "available")
                    ;;
                "parallel")
                    version=$(parallel --version 2>/dev/null | head -1 || echo "available")
                    ;;
                *)
                    # Fall back to common flags
                    version=$("$tool" --version 2>/dev/null | head -1 2>/dev/null || "$tool" -version 2>/dev/null | head -1 2>/dev/null || echo "available")
                    ;;
            esac
            echo -e "  ${GREEN}âœ“ $tool: $version${NC}"
            
            # Check if package is up-to-date (all distros)
            check_package_update_available "$tool" 2>/dev/null
        fi
    done
    
    # Check optional tools
    for tool in "${optional_tools[@]}"; do
        # Special handling for xxhash - check for ANY variant
        if [[ "$tool" == "xxhsum" ]]; then
            if ! command -v xxh128sum >/dev/null 2>&1 && \
               ! command -v xxh64sum >/dev/null 2>&1 && \
               ! command -v xxhsum >/dev/null 2>&1; then
                missing_optional+=("$tool")
                continue
            fi
        elif ! command -v "$tool" >/dev/null 2>&1; then
            missing_optional+=("$tool")
            continue
        fi
        
        # Tool is installed - show version
        # Get version info for optional tools
        local version=""
        case "$tool" in
            "gifsicle")
                version=$(gifsicle --version 2>/dev/null | head -1 || echo "available")
                ;;
            "jq")
                version=$(jq --version 2>/dev/null || echo "available")
                ;;
            "convert")
                version=$(convert -version 2>/dev/null | head -1 | sed 's/Version: ImageMagick /ImageMagick /' || echo "available")
                ;;
            "xxhsum"|"xxh64sum"|"xxh128sum")
                # Check for any xxhash variant
                if command -v xxh128sum >/dev/null 2>&1; then
                    version=$(xxh128sum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
                elif command -v xxh64sum >/dev/null 2>&1; then
                    version=$(xxh64sum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
                elif command -v xxhsum >/dev/null 2>&1; then
                    version=$(xxhsum --version 2>&1 | head -1 | awk '{print "xxHash " $2}' || echo "xxHash available")
                else
                    version="not found"
                fi
                ;;
            *)
                version=$("$tool" --version 2>/dev/null | head -1 2>/dev/null || echo "available")
                ;;
        esac
        echo -e "  ${GREEN}âœ“ $tool: $version${NC}"
        
        # Check if package is up-to-date (all distros)
        check_package_update_available "$tool" 2>/dev/null
    done
    
    # EARLY handling for missing required dependencies (prompt before expensive HW checks)
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        echo -e "\n${RED}âŒ Missing required dependencies:${NC}"
        for dep in "${missing_required[@]}"; do
            echo -e "  ${RED}â€¢ $dep${NC}"
        done
        
        # Attempt auto-installation
        if auto_install_dependencies "${missing_required[@]}"; then
            echo -e "${GREEN}âœ… Required dependencies installed successfully!${NC}"
        else
            echo -e "\n${RED}âŒ Cannot proceed without required dependencies${NC}"
            echo -e "${YELLOW}Please install them manually and try again.${NC}"
            exit 1
        fi
    fi
    
    # Check hardware acceleration support
    echo -e "\n${CYAN}ðŸŽ® Checking hardware acceleration support...${NC}"
    local hw_support_found=false
    local hw_codecs_available=()
    local hw_drivers_missing=()
    
    # Check FFmpeg hardware encoder support
    if command -v ffmpeg >/dev/null 2>&1; then
        local ffmpeg_encoders=$(ffmpeg -hide_banner -encoders 2>/dev/null)
        
        # NVIDIA NVENC
        if echo "$ffmpeg_encoders" | grep -q "h264_nvenc"; then
            hw_codecs_available+=("NVENC (NVIDIA)")
            hw_support_found=true
            echo -e "  ${GREEN}âœ“ NVENC encoder available${NC}"
            
            # Only warn about drivers if an NVIDIA GPU is actually present
            if [[ "$has_nvidia_gpu" == true ]]; then
                # Check for nvidia-smi (driver)
                if ! command -v nvidia-smi >/dev/null 2>&1; then
                    hw_drivers_missing+=("nvidia-driver (for NVENC)")
                    echo -e "  ${YELLOW}âš ï¸  NVIDIA drivers not detected - NVENC may not work${NC}"
                else
                    local nvidia_driver_version=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -1)
                    echo -e "  ${GREEN}âœ“ NVIDIA driver: ${nvidia_driver_version:-installed}${NC}"
                fi
            fi
        fi
        
        # AMD VAAPI
        if echo "$ffmpeg_encoders" | grep -q "h264_vaapi"; then
            hw_codecs_available+=("VAAPI (AMD/Intel)")
            hw_support_found=true
            echo -e "  ${GREEN}âœ“ VAAPI encoder available${NC}"
            
            # Check for VAAPI drivers
            local vaapi_driver_found=false
            if [[ -d /dev/dri ]]; then
                echo -e "  ${GREEN}âœ“ DRI devices found: $(ls -1 /dev/dri/ 2>/dev/null | grep -c renderD)${NC}"
                vaapi_driver_found=true
            fi
            
            # Check for AMD-specific drivers
            if lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                if command -v vainfo >/dev/null 2>&1; then
                    echo -e "  ${GREEN}âœ“ vainfo available for AMD driver validation${NC}"
                else
                    hw_drivers_missing+=("libva-utils (for AMD VAAPI validation)")
                    echo -e "  ${YELLOW}âš ï¸  libva-utils not installed - install for VAAPI validation${NC}"
                fi
                
                # Check for Mesa VAAPI drivers
                # Prefer runtime validation via vainfo when available (more reliable across distros)
                if command -v vainfo >/dev/null 2>&1; then
                    if ! vainfo >/dev/null 2>&1; then
                        hw_drivers_missing+=("mesa-va-drivers (for AMD VAAPI)")
                        echo -e "  ${YELLOW}âš ï¸  Mesa VAAPI drivers may not be installed (vainfo failed)${NC}"
                    fi
                else
                    # Fallback heuristic for systems without vainfo
                    if ! ldconfig -p 2>/dev/null | grep -q "libva-mesa"; then
                        hw_drivers_missing+=("mesa-va-drivers (for AMD VAAPI)")
                        echo -e "  ${YELLOW}âš ï¸  Mesa VAAPI drivers may not be installed${NC}"
                    fi
                fi
            fi
            
            if [[ "$vaapi_driver_found" == false ]]; then
                echo -e "  ${YELLOW}âš ï¸  No DRI devices found - VAAPI may not work${NC}"
            fi
        fi
        
        # Intel QSV
        if echo "$ffmpeg_encoders" | grep -q "h264_qsv"; then
            hw_codecs_available+=("QSV (Intel Quick Sync)")
            hw_support_found=true
            echo -e "  ${GREEN}âœ“ QSV encoder available${NC}"
            
            # Check for Intel media driver
            if lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                if ! ldconfig -p 2>/dev/null | grep -q "libmfx\|intel-media-driver"; then
                    hw_drivers_missing+=("intel-media-driver (for QSV)")
                    echo -e "  ${YELLOW}âš ï¸  Intel Media Driver may not be installed${NC}"
                fi
            fi
        fi
        
        # VideoToolbox (macOS)
        if echo "$ffmpeg_encoders" | grep -q "h264_videotoolbox"; then
            hw_codecs_available+=("VideoToolbox (macOS)")
            hw_support_found=true
            echo -e "  ${GREEN}âœ“ VideoToolbox encoder available${NC}"
        fi
        
        if [[ "$hw_support_found" == false ]]; then
            echo -e "  ${YELLOW}âš ï¸  No hardware encoders detected in FFmpeg${NC}"
            echo -e "  ${GRAY}    Hardware acceleration will not be available${NC}"
            echo -e "  ${GRAY}    Consider installing FFmpeg with hardware encoder support:${NC}"
            
            # Provide distro-specific recommendations
            if [[ -f /etc/os-release ]]; then
                source /etc/os-release
                case "${ID,,}" in
                    ubuntu|debian|pop|mint)
                        echo -e "  ${GRAY}    â€¢ sudo apt install mesa-va-drivers intel-media-va-driver libva-utils${NC}"
                        echo -e "  ${GRAY}    â€¢ For NVIDIA: Use proprietary drivers with libva-utils${NC}"
                        ;;
                    fedora|rhel|centos)
                        echo -e "  ${GRAY}    â€¢ sudo dnf install ffmpeg mesa-va-drivers intel-media-driver libva-utils${NC}"
                        ;;
                    arch|manjaro)
                        echo -e "  ${GRAY}    â€¢ sudo pacman -S ffmpeg libva-mesa-driver intel-media-driver libva-utils${NC}"
                        ;;
                    opensuse*|suse)
                        echo -e "  ${GRAY}    â€¢ sudo zypper install ffmpeg-4 Mesa-libva libva-intel-driver libva-vdpau-driver libva-utils${NC}"
                        ;;
                esac
            fi
        else
            echo -e "  ${GREEN}âœ“ Hardware acceleration: ${hw_codecs_available[*]}${NC}"
        fi
    else
        echo -e "  ${YELLOW}âš ï¸  FFmpeg not installed - hardware acceleration check skipped${NC}"
    fi
    
    # Handle missing hardware drivers with installation prompt
    if [[ ${#hw_drivers_missing[@]} -gt 0 ]]; then
        # Check if user previously declined within last 24h
        local skip_file="$LOG_DIR/.hw_prompt_skip"
        local skip_prompt=false
        if [[ -f "$skip_file" ]]; then
            source "$skip_file" 2>/dev/null || true
            local now_ts=$(date +%s)
            if [[ -n "$skip_hw_prompt_until" && $now_ts -lt $skip_hw_prompt_until ]]; then
                echo -e "\n${GRAY}â­ Skipping hardware driver prompt (snoozed for $(( (skip_hw_prompt_until - now_ts) / 3600 )) hours).${NC}"
                echo -e "${GRAY}Run 'Check Dependencies' from the menu to revisit at any time.${NC}"
                skip_prompt=true
            fi
        fi
        
        # Only show and prompt if not skipped
        if [[ "$skip_prompt" == false ]]; then
            echo -e "\n${YELLOW}ðŸ“¦ Missing hardware acceleration drivers:${NC}"
            for driver in "${hw_drivers_missing[@]}"; do
                echo -e "  ${YELLOW}â€¢ $driver${NC}"
            done
            
            # Detect distribution and build installation commands
            local hw_install_commands=()
        if [[ -f /etc/os-release ]]; then
            source /etc/os-release
            
            case "${ID,,}" in
                ubuntu|debian|pop|mint)
                    # Determine which drivers to install based on GPU
                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                        hw_install_commands+=("sudo apt update && sudo apt install -y libva-utils")
                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                        hw_install_commands+=("sudo apt update && sudo apt install -y mesa-va-drivers libva-utils")
                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                        hw_install_commands+=("sudo apt update && sudo apt install -y intel-media-va-driver libva-utils")
                    fi
                    ;;
                fedora|rhel|centos)
                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                        hw_install_commands+=("sudo dnf install -y libva-utils")
                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                        hw_install_commands+=("sudo dnf install -y libva-utils mesa-va-drivers")
                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                        hw_install_commands+=("sudo dnf install -y intel-media-driver libva-utils")
                    fi
                    ;;
                arch|manjaro)
                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                        hw_install_commands+=("sudo pacman -S --needed libva-utils")
                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                        hw_install_commands+=("sudo pacman -S --needed libva-mesa-driver libva-utils")
                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                        hw_install_commands+=("sudo pacman -S --needed intel-media-driver libva-utils")
                    fi
                    ;;
                opensuse*|suse)
                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                        hw_install_commands+=("sudo zypper install -y libva-vdpau-driver libva-utils")
                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                        hw_install_commands+=("sudo zypper install -y Mesa-libva libva-utils")
                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                        hw_install_commands+=("sudo zypper install -y libva-intel-driver libva-utils")
                    fi
                    ;;
                *)
                    echo -e "  ${GRAY}Distribution not recognized for automatic installation${NC}"
                    ;;
            esac
        fi
        
            # Prompt user to install hardware drivers
            if [[ ${#hw_install_commands[@]} -gt 0 ]]; then
                echo ""
                echo -e "${CYAN}ðŸš€ Hardware acceleration can significantly speed up conversions!${NC}"
                echo -e "${GRAY}Without it, CPU-only encoding will be slower and use more resources.${NC}"
                echo ""
                echo -ne "${CYAN}Would you like to install hardware acceleration drivers? [Y/n]:${NC} "
                read -r hw_install_choice
            
                if [[ ! "$hw_install_choice" =~ ^[Nn]$ ]]; then
                    echo -e "\n${BLUE}ðŸ”§ Installing hardware acceleration drivers...${NC}"
                    
                    local install_success=false
                    for cmd in "${hw_install_commands[@]}"; do
                        echo -e "${CYAN}âž¡ï¸  Running: ${GRAY}$cmd${NC}"
                        if eval "$cmd"; then
                            install_success=true
                            echo -e "${GREEN}âœ“ Installation completed${NC}"
                        else
                            echo -e "${YELLOW}âš ï¸  Installation failed or was cancelled${NC}"
                        fi
                    done
                    
                    if [[ "$install_success" == true ]]; then
                        echo -e "\n${GREEN}âœ… Hardware acceleration drivers installed!${NC}"
                        echo -e "${CYAN}ðŸ”„ Please restart the script to detect the new drivers.${NC}"
                        echo ""
                        echo -ne "${YELLOW}Press Enter to exit and restart...${NC}"
                        read -r
                        exit 0
                    else
                        echo -e "${YELLOW}Continuing without hardware acceleration drivers...${NC}"
                        echo -e "${GRAY}You can install them manually later for better performance.${NC}"
                    fi
                else
                    echo -e "${CYAN}Continuing without hardware acceleration...${NC}"
                    echo -e "${GRAY}Note: Conversions will use CPU-only encoding (slower).${NC}"
                    # Remember choice to skip on next run for 24h
                    mkdir -p "$LOG_DIR" 2>/dev/null || true
                    echo "skip_hw_prompt_until=$(date -d '+24 hours' +%s)" > "$LOG_DIR/.hw_prompt_skip"
                fi
            else
                echo -e "\n${GRAY}ðŸ“ Manual installation required for your system${NC}"
                echo -e "${GRAY}Please refer to your distribution's documentation.${NC}"
            fi
        fi
    fi
    
    # Handle missing optional dependencies
    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}âš ï¸  Missing optional dependencies:${NC}"
        for dep in "${missing_optional[@]}"; do
            case "$dep" in
                "gifsicle")
                    echo -e "  ${YELLOW}â€¢ $dep${NC} - GIF optimization will be disabled"
                    AUTO_OPTIMIZE=false
                    ;;
                "jq")
                    echo -e "  ${YELLOW}â€¢ $dep${NC} - Advanced auto-detection features will be limited"
                    ;;
                "convert")
                    echo -e "  ${YELLOW}â€¢ $dep (ImageMagick)${NC} - AI perceptual hashing for duplicate detection will be disabled"
                    echo -e "  ${GRAY}    Level 4 duplicate detection will use basic size/frame comparison only${NC}"
                    ;;
                "xxhsum"|"xxh64sum"|"xxh128sum")
                    echo -e "  ${YELLOW}â€¢ xxhash${NC} - Duplicate detection will use MD5 (baseline speed)"
                    echo -e "  ${GRAY}    Installing xxhash provides ${GREEN}20-30x faster${GRAY} duplicate detection!${NC}"
                    echo -e "  ${GRAY}    Alternative: blake3 (b3sum) provides 10-15x faster performance${NC}"
                    ;;
            esac
        done
        
        echo ""
        echo -ne "${CYAN}Would you like to install optional dependencies? [y/N]:${NC} "
        read -r optional_choice
        
        if [[ "$optional_choice" =~ ^[Yy]$ ]]; then
            if auto_install_dependencies "${missing_optional[@]}"; then
                echo -e "${GREEN}âœ… Optional dependencies installed!${NC}"
                # Re-enable features that were disabled
                if command -v gifsicle >/dev/null 2>&1; then
                    AUTO_OPTIMIZE=true
                fi
            else
                echo -e "${YELLOW}Continuing without optional dependencies...${NC}"
            fi
        else
            echo -e "${CYAN}Continuing without optional dependencies...${NC}"
        fi
    fi
    
    # Prompt to update outdated packages
    if [[ ${#OUTDATED_PACKAGES[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}âš ï¸  Found ${#OUTDATED_PACKAGES[@]} package(s) with updates available${NC}"
        
        # Show detailed list of tools and exact commands before asking
        echo -e "${BLUE}Details:${NC}"
        for entry in "${OUTDATED_PACKAGES[@]}"; do
            local tool="${entry%%:*}"
            local cmd="${entry#*:}"
            echo -e "  ${CYAN}â€¢ ${BOLD}$tool${NC}${CYAN} â†’ ${GRAY}$cmd${NC}"
        done
        
        echo ""
        echo -ne "${CYAN}Would you like to run these update commands now? [y/N]:${NC} "
        read -r update_choice
        
        if [[ "$update_choice" =~ ^[Yy]$ ]]; then
            echo -e "\n${BLUE}ðŸ”„ Updating packages...${NC}"
            for entry in "${OUTDATED_PACKAGES[@]}"; do
                local tool="${entry%%:*}"
                local cmd="${entry#*:}"
                echo -e "\n${CYAN}âž¡ï¸  Updating $tool...${NC}"
                echo -e "${GRAY}Command: $cmd${NC}"
                eval "$cmd"
                if [[ $? -eq 0 ]]; then
                    echo -e "${GREEN}âœ“ $tool updated successfully${NC}"
                else
                    echo -e "${YELLOW}âš ï¸  $tool update failed or was skipped${NC}"
                fi
            done
            echo -e "\n${GREEN}âœ… Package updates completed${NC}"
        else
            echo -e "${CYAN}ðŸ“ You can run the commands above manually later if you prefer.${NC}"
        fi
    fi
    
    # Save successful check to cache ONLY if all required tools present AND no missing optional tools
    # This ensures optional dependency prompts (like xxhash) appear on every startup until installed
    if [[ ${#missing_required[@]} -eq 0 && ${#missing_optional[@]} -eq 0 ]]; then
        cat > "$cache_file" << 'EOF'
# Dependency check cache
# Generated: $(date)
# All required and optional dependencies verified
EOF
        echo -e "\n${GREEN}âœ… All dependencies verified successfully${NC}"
        echo -e "${GRAY}  ðŸ’¾ Cached for faster startup next time${NC}"
    elif [[ ${#missing_required[@]} -eq 0 ]]; then
        echo -e "\n${GREEN}âœ… Required dependencies verified${NC}"
        echo -e "${YELLOW}   Missing optional dependencies - will check again next run${NC}"
    else
        echo -e "\n${YELLOW}âš ï¸  Dependency check completed with warnings${NC}"
    fi
        
        # ðŸ§  Initialize AI Training System
        init_ai_training
    }
    
    # ðŸ“‹ Comprehensive environment validation
    validate_environment() {
    trace_function "validate_environment"
    
    # Check write permissions
    if [[ ! -w "." ]]; then
        log_error "No write permission in current directory" "$(pwd)" "User: $USER, Permissions: $(ls -ld . 2>/dev/null)" "${BASH_LINENO[0]}" "validate_environment"
        echo -e "${RED}âŒ Error: No write permission in current directory${NC}"
        return 1
    fi
    
    # Check available disk space (warn if less than 1GB)
    local available_space=$(df . | awk 'NR==2 {print $4}' 2>/dev/null || echo "0")
    if [[ $available_space -lt 1000000 ]]; then
        echo -e "${YELLOW}âš ï¸  Warning: Low disk space (less than 1GB available)${NC}"
        echo -e "${YELLOW}GIF files can be large. Consider freeing up space.${NC}"
        log_error "Low disk space warning" "$(pwd)" "Available: ${available_space}KB" "${BASH_LINENO[0]}" "validate_environment"
    fi
    
    return 0
}

# ðŸŽ¥ Validate conversion environment specifically
validate_conversion_environment() {
    trace_function "validate_conversion_environment"
    
    # Check basic environment first
    if ! validate_environment; then
        return 1
    fi
    
    # Check required variables are set
    local missing_vars=()
    [[ -z "$RESOLUTION" ]] && missing_vars+=("RESOLUTION")
    [[ -z "$FRAMERATE" ]] && missing_vars+=("FRAMERATE")
    [[ -z "$QUALITY" ]] && missing_vars+=("QUALITY")
    [[ -z "$ASPECT_RATIO" ]] && missing_vars+=("ASPECT_RATIO")
    
    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        log_error "Missing configuration variables" "" "Missing: ${missing_vars[*]}" "${BASH_LINENO[0]}" "validate_conversion_environment"
        return 1
    fi
    
    # Validate log directory is accessible
    if [[ ! -d "$(dirname "$ERROR_LOG")" ]]; then
        if ! mkdir -p "$(dirname "$ERROR_LOG")" 2>/dev/null; then
            log_error "Cannot create log directory" "$(dirname "$ERROR_LOG")" "Permission denied or path invalid" "${BASH_LINENO[0]}" "validate_conversion_environment"
            return 1
        fi
    fi
    
    return 0
}

# ðŸŽ¬ Comprehensive video file validation with MD5-based caching
validate_video_file() {
    local file="$1"
    trace_function "validate_video_file"
    
    # Basic file checks
    if [[ ! -f "$file" ]]; then
        log_error "File does not exist" "$file" "File not found" "${BASH_LINENO[0]}" "validate_video_file"
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log_error "File not readable" "$file" "Permission denied" "${BASH_LINENO[0]}" "validate_video_file"
        return 1
    fi
    
    # Check file size (must be > 1KB for valid video)
    local file_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
    if [[ $file_size -lt 1024 ]]; then
        log_error "File too small or empty" "$file" "Size: $file_size bytes (minimum: 1KB)" "${BASH_LINENO[0]}" "validate_video_file"
        return 1
    fi
    
    # MD5-based validation cache to skip expensive FFprobe checks
    local validation_cache="$LOG_DIR/validation_cache.db"
    local file_mtime=$(stat -c%Y -- "$file" 2>/dev/null || echo "0")
    local cache_key="${file}|${file_size}|${file_mtime}"
    
    # Validate cache integrity on first access (silent rebuild)
    if [[ -f "$validation_cache" ]]; then
        # Check if cache is corrupted (malformed entries)
        if ! head -1 "$validation_cache" 2>/dev/null | grep -qE '^.+\\|[0-9]+\\|[0-9]+\\|(VALID|INVALID)$'; then
            # First line is corrupted or invalid format
            if [[ $(wc -l < "$validation_cache" 2>/dev/null || echo 0) -gt 0 ]]; then
                # Silently rebuild cache
                mv "$validation_cache" "${validation_cache}.corrupt.$(date +%s)" 2>/dev/null
                echo "# Validation Cache v1.0 - $(date)" > "$validation_cache"
                
                # Clean up old corrupt backups (keep only last 5)
                ( ls -t "${validation_cache}.corrupt."* 2>/dev/null | tail -n +6 | xargs -r rm -f ) &
            fi
        fi
        
        # Check cache for this specific file (no output)
        if grep -qF "$cache_key|VALID" "$validation_cache" 2>/dev/null; then
            CACHE_HITS=$((CACHE_HITS + 1))
            return 0
        elif grep -qF "$cache_key|INVALID" "$validation_cache" 2>/dev/null; then
            CACHE_HITS=$((CACHE_HITS + 1))
            return 1
        fi
    else
        # Initialize cache with header
        mkdir -p "$(dirname "$validation_cache")" 2>/dev/null
        echo "# Validation Cache v1.0 - $(date)" > "$validation_cache"
        echo "# Format: filepath|filesize|mtime|VALID/INVALID" >> "$validation_cache"
    fi
    
    # Cache miss - perform full validation
    CACHE_MISSES=$((CACHE_MISSES + 1))
    local validation_result="INVALID"
    if detect_video_corruption "$file"; then
        validation_result="VALID"
    fi
    
    # Save to cache
    mkdir -p "$(dirname "$validation_cache")" 2>/dev/null
    echo "$cache_key|$validation_result" >> "$validation_cache"
    
    # Keep cache size manageable (last 1000 entries)
    if [[ -f "$validation_cache" ]] && [[ $(wc -l < "$validation_cache") -gt 1000 ]]; then
        tail -800 "$validation_cache" > "${validation_cache}.tmp" && mv "${validation_cache}.tmp" "$validation_cache"
    fi
    
    [[ "$validation_result" == "VALID" ]] && return 0 || return 1
}

# ðŸ” Basic corruption detection for video files (less aggressive)
detect_video_corruption() {
    local file="$1"
    local temp_error="/tmp/ffprobe_error_$$_$(date +%s).log"
    trace_function "detect_video_corruption"
    
    # Silent validation - no output
    
    # Test 1: Basic stream validation
    if ! ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_type -of csv=p=0 -- "$file" 2>"$temp_error" | grep -q "video"; then
        local error_msg="No video stream found"
        [[ -s "$temp_error" ]] && error_msg="$(head -3 "$temp_error" | tr '\n' ' ')"
        log_error "Invalid video file - no video stream" "$file" "$error_msg" "${BASH_LINENO[0]}" "detect_video_corruption"
        rm -f "$temp_error" 2>/dev/null
        return 1
    fi
    
    # Test 2: Basic metadata check (less strict)
    if ! ffprobe -v quiet -show_entries format=duration -of csv=p=0 -- "$file" 2>"$temp_error" >/dev/null; then
        local error_msg="Cannot read basic metadata"
        [[ -s "$temp_error" ]] && error_msg="$(head -3 "$temp_error" | tr '\n' ' ')"
        log_error "Corrupt video file - metadata unreadable" "$file" "$error_msg" "${BASH_LINENO[0]}" "detect_video_corruption"
        rm -f "$temp_error" 2>/dev/null
        return 1
    fi
    
    # Skip the aggressive frame decoding test that was causing false positives
    # If basic tests pass, assume the file is valid
    
    # Cleanup and success (silent)
    rm -f "$temp_error" 2>/dev/null
    return 0
}

# ðŸ”„ Check if output file already exists and is valid
check_duplicate_output() {
    local input_file="$1"
    local base_name="$(basename -- "${input_file%.*}")"
    local output_file="$OUTPUT_DIRECTORY/$base_name.${OUTPUT_FORMAT}"
    
    # If file doesn't exist, not a duplicate
    if [[ ! -f "$output_file" ]]; then
        return 1
    fi
    
    # If force conversion is enabled, ignore existing files
    if [[ "$FORCE_CONVERSION" == "true" ]]; then
        [[ "$VALIDATION_SILENT_MODE" != "true" ]] && echo -e "  ${YELLOW}â™¾ï¸ Force mode: Will overwrite existing $(basename -- "$output_file")${NC}"
        return 1
    fi
    
    # Check if output is newer than input (modification time)
    if [[ "$output_file" -nt "$input_file" ]]; then
        [[ "$VALIDATION_SILENT_MODE" != "true" ]] && echo -e "  ${GREEN}âœ“ Already converted: $(basename -- "$output_file") (newer than source)${NC}"
        return 0
    fi
    
    # Check if output file is valid (basic size check)
    local output_size=$(stat -c%s -- "$output_file" 2>/dev/null || echo "0")
    if [[ $output_size -lt 100 ]]; then
        [[ "$VALIDATION_SILENT_MODE" != "true" ]] && echo -e "  ${YELLOW}âš ï¸ Existing file too small, will recreate: $(basename -- "$output_file")${NC}"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # Quick validation of existing GIF
    if ! file "$output_file" 2>/dev/null | grep -q "GIF"; then
        [[ "$VALIDATION_SILENT_MODE" != "true" ]] && echo -e "  ${YELLOW}âš ï¸ Existing file not a valid GIF, will recreate: $(basename -- "$output_file")${NC}"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # File exists, is newer, and appears valid
    [[ "$VALIDATION_SILENT_MODE" != "true" ]] && echo -e "  ${GREEN}â­ï¸ Skipping: $(basename -- "$output_file") already exists and is valid${NC}"
    return 0
}

# ðŸ…¾ï¸Validate output GIF files for corruption
validate_output_file() {
    local output_file="$1"
    local source_file="$2"
    local temp_error="/tmp/gif_validation_$$_$(date +%s).log"
    trace_function "validate_output_file"
    
    echo -e "  ${BLUE}ðŸ” Validating output: $(basename -- "$output_file")${NC}"
    
    # Test 1: Check if file was created
    if [[ ! -f "$output_file" ]]; then
        log_error "Output file was not created" "$source_file" "Expected: $output_file" "${BASH_LINENO[0]}" "validate_output_file"
        echo -e "  ${RED}âŒ Output file was not created${NC}"
        return 1
    fi
    
    # Test 2: Check file size (must be > 100 bytes for valid GIF)
    local file_size=$(stat -c%s -- "$output_file" 2>/dev/null || echo "0")
    if [[ $file_size -lt 100 ]]; then
        log_error "Output file too small" "$source_file" "Output: $output_file, Size: $file_size bytes (minimum: 100)" "${BASH_LINENO[0]}" "validate_output_file"
        echo -e "  ${RED}âŒ Output file too small: $file_size bytes${NC}"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # Test 3: Check GIF file signature (magic bytes)
    local file_header=$(hexdump -C "$output_file" | head -1 | cut -d'|' -f2 2>/dev/null)
    if ! echo "$file_header" | grep -q "GIF8[79]a"; then
        # Try alternative method
        local magic_bytes=$(file "$output_file" 2>/dev/null)
        if [[ ! "$magic_bytes" == *"GIF image"* ]]; then
            log_error "Invalid GIF format - wrong magic bytes" "$source_file" "Output: $output_file, Header: $file_header, File output: $magic_bytes" "${BASH_LINENO[0]}" "validate_output_file"
            echo -e "  ${RED}âŒ Invalid GIF format (corrupted header)${NC}"
            rm -f "$output_file" 2>/dev/null
            return 1
        fi
    fi
    
    # Test 4: Basic GIF format check with FFprobe (simplified)
    if ! ffprobe -v quiet -show_entries format=format_name -of csv=p=0 -- "$output_file" 2>/dev/null | grep -q "gif\\|image2"; then
        local error_msg="Not recognized as GIF format"
        log_error "Invalid GIF format" "$source_file" "Output: $output_file" "${BASH_LINENO[0]}" "validate_output_file"
        echo -e "  ${RED}âŒ Invalid GIF format${NC}"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # Test 5: Get basic GIF info (non-failing)
    local gif_info=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "$output_file" 2>/dev/null || echo "unknown")
    
    # Test 6: Basic playability check (less strict)
    # Skip the aggressive frame decoding test that causes false positives
    # If we got this far, the GIF is likely valid
    
    # Test 7: Check for reasonable file size ratio (not too big or suspiciously small)
    # NOTE: Videoâ†’GIF conversion typically results in larger files depending on quality settings
    # This is NORMAL and expected behavior - don't warn unless truly anomalous
    local source_size=$(stat -c%s -- "$source_file" 2>/dev/null || echo "1")
    local ratio=$((file_size * 100 / source_size))
    
    # Only warn if GIF is EXTREMELY large (100,000%+ = 1000x source) which might indicate issues
    # Check raw ratio instead of using compute_ratio_percent since we need numeric comparison
    if [[ $ratio -gt 100000 ]]; then  # More than 1000x the source size
            # Convert sizes to MB for readability
            local source_size_mb=$(echo "scale=2; $source_size / 1024 / 1024" | bc 2>/dev/null || echo "0.00")
            local output_size_mb=$(echo "scale=2; $file_size / 1024 / 1024" | bc 2>/dev/null || echo "0.00")
            # Calculate actual multiplier (e.g., "1078x larger")
            local multiplier=$(echo "scale=1; $file_size / $source_size" | bc 2>/dev/null || echo "0")
            
            echo -e "  ${YELLOW}âš ï¸ Warning: Output GIF is extremely large (${multiplier}x source size)${NC}"
            log_warning "Extremely large output file" "$source_file" "Output: $output_file, Source: ${source_size_mb}MB, Output: ${output_size_mb}MB, Multiplier: ${multiplier}x" "${BASH_LINENO[0]}" "validate_output_file"
            # Don't fail, just warn
    fi
    
    # Cleanup and success
    rm -f "$temp_error" 2>/dev/null
    local file_size_mb=$(echo "scale=1; $(stat -c%s -- "$output_file" 2>/dev/null || echo "0") / 1024 / 1024" | bc 2>/dev/null || echo "?.?")
    echo -e "  ${GREEN}âœ“ GIF created successfully: ${file_size_mb}MB${NC}"
    return 0
}

# ðŸ”« Kill ffmpeg processes
kill_ffmpeg_processes() {
    clear
    print_header
    echo -e "${RED}${BOLD}ðŸ”« KILL FFMPEG PROCESSES${NC}\n"
    
    # Find running ffmpeg processes
    local ffmpeg_pids=($(pgrep -f ffmpeg 2>/dev/null || true))
    
    if [[ ${#ffmpeg_pids[@]} -eq 0 ]]; then
        echo -e "${GREEN}âœ“ No ffmpeg processes are currently running${NC}"
        show_tmux_controls
        echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
        read -rsn1
        return
    fi
    
    echo -e "${YELLOW}Found ${BOLD}${#ffmpeg_pids[@]}${NC}${YELLOW} running ffmpeg process(es):${NC}\n"
    
    # Show process details
    for pid in "${ffmpeg_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            local cmd=$(ps -p "$pid" -o args --no-headers 2>/dev/null || echo "Unknown command")
            local runtime=$(ps -p "$pid" -o etime --no-headers 2>/dev/null | tr -d ' ' || echo "Unknown")
            echo -e "  ${BLUE}PID ${BOLD}$pid${NC}: Running for ${CYAN}$runtime${NC}"
            echo -e "    ${GRAY}Command: ${cmd:0:80}...${NC}"
        fi
    done
    
    echo -e "\n${RED}${BOLD}âš ï¸  WARNING: This will forcefully terminate all ffmpeg processes!${NC}"
    echo -e "${RED}This may interrupt ongoing conversions and could cause file corruption.${NC}\n"
    
    echo -e "${MAGENTA}Kill options:${NC}"
    echo -e "  ${GREEN}[1]${NC} Send SIGTERM (graceful shutdown)"
    echo -e "  ${GREEN}[2]${NC} Send SIGKILL (force kill)"
    echo -e "  ${GREEN}[3]${NC} Interactive kill (choose specific processes)"
            echo -e "  ${GREEN}[0]${NC} Cancel and return to menu\n"
    
    # Show tmux controls
    show_tmux_controls
    
    echo -ne "${MAGENTA}Select an option [0-3]: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            echo -e "\n${YELLOW}Sending SIGTERM to all ffmpeg processes...${NC}"
            for pid in "${ffmpeg_pids[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    if kill -TERM "$pid" 2>/dev/null; then
                        echo -e "  ${GREEN}âœ“ Sent SIGTERM to PID $pid${NC}"
                    else
                        echo -e "  ${RED}âŒ Failed to send SIGTERM to PID $pid${NC}"
                    fi
                fi
            done
            echo -e "\n${BLUE}Waiting 3 seconds for processes to terminate gracefully...${NC}"
            sleep 3
            
            # Check if any processes are still running
            local remaining_pids=($(pgrep -f ffmpeg 2>/dev/null || true))
            if [[ ${#remaining_pids[@]} -gt 0 ]]; then
                echo -e "${YELLOW}${#remaining_pids[@]} process(es) still running. Use option 2 to force kill.${NC}"
            else
                echo -e "${GREEN}âœ“ All ffmpeg processes terminated successfully${NC}"
            fi
            ;;
        "2")
            echo -e "\n${RED}Force killing all ffmpeg processes...${NC}"
            for pid in "${ffmpeg_pids[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    if kill -KILL "$pid" 2>/dev/null; then
                        echo -e "  ${GREEN}âœ“ Force killed PID $pid${NC}"
                    else
                        echo -e "  ${RED}âŒ Failed to kill PID $pid${NC}"
                    fi
                fi
            done
            echo -e "${GREEN}âœ“ Force kill commands sent to all processes${NC}"
            ;;
        "3")
            echo -e "\n${CYAN}Interactive kill mode:${NC}"
            for pid in "${ffmpeg_pids[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    local cmd=$(ps -p "$pid" -o args --no-headers 2>/dev/null || echo "Unknown")
                    echo -e "\n${BLUE}PID $pid:${NC} ${cmd:0:60}..."
                    echo -ne "${MAGENTA}Kill this process? [y/N]: ${NC}"
                    read -r confirm
                    if [[ "$confirm" =~ ^[Yy]$ ]]; then
                        if kill -TERM "$pid" 2>/dev/null; then
                            echo -e "  ${GREEN}âœ“ Sent SIGTERM to PID $pid${NC}"
                        else
                            echo -e "  ${RED}âŒ Failed to terminate PID $pid${NC}"
                        fi
                    else
                        echo -e "  ${YELLOW}Skipped PID $pid${NC}"
                    fi
                fi
            done
            ;;
        "0"|"")
            echo -e "${YELLOW}Operation cancelled${NC}"
            ;;
        *)
            echo -e "${RED}Invalid option${NC}"
            ;;
    esac
    
    show_tmux_controls
    echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# ðŸ“‹ Detect available file picker (comprehensive desktop environment support)
detect_file_picker() {
    # Check for various file picker dialogs in order of preference
    # GTK-based dialogs
    if command -v zenity >/dev/null 2>&1; then
        echo "zenity"  # GNOME, XFCE, Cinnamon, Budgie
    elif command -v yad >/dev/null 2>&1; then
        echo "yad"  # Enhanced zenity fork
    elif command -v matedialog >/dev/null 2>&1; then
        echo "matedialog"  # MATE Desktop
    # Qt-based dialogs
    elif command -v kdialog >/dev/null 2>&1; then
        echo "kdialog"  # KDE Plasma
    elif command -v qarma >/dev/null 2>&1; then
        echo "qarma"  # Qt zenity clone
    # Other dialogs
    elif command -v dialog >/dev/null 2>&1; then
        echo "dialog"  # Text-based fallback
    elif command -v whiptail >/dev/null 2>&1; then
        echo "whiptail"  # Text-based alternative
    # Try Python-based tkinter as last GUI resort
    elif command -v python3 >/dev/null 2>&1 && python3 -c "import tkinter" 2>/dev/null; then
        echo "python-tk"
    else
        echo "none"
    fi
}

# ðŸ“‚ Browse for directory using file picker
browse_for_directory() {
    local picker=$(detect_file_picker)
    local selected_dir=""
    
    case "$picker" in
        "zenity")
            selected_dir=$(zenity --file-selection --directory --title="Select Output Directory" 2>/dev/null || echo "")
            ;;
        "kdialog")
            selected_dir=$(kdialog --getexistingdirectory "$HOME" --title "Select Output Directory" 2>/dev/null || echo "")
            ;;
        "yad")
            # YAD (Yet Another Dialog) - Zenity fork with more features
            selected_dir=$(yad --file --directory --title="Select Output Directory" 2>/dev/null || echo "")
            ;;
        "qarma")
            # Qarma - Qt-based Zenity clone
            selected_dir=$(qarma --file-selection --directory --title="Select Output Directory" 2>/dev/null || echo "")
            ;;
        "matedialog")
            # MATE Desktop dialog
            selected_dir=$(matedialog --file-selection --directory --title="Select Output Directory" 2>/dev/null || echo "")
            ;;
        "dialog")
            # Text-based dialog fallback
            selected_dir=$(dialog --stdout --title "Select Output Directory" --dselect "$HOME/" 14 48 2>/dev/null || echo "")
            ;;
        "whiptail")
            # Whiptail text-based fallback
            selected_dir=$(whiptail --title "Select Output Directory" --inputbox "Enter directory path:" 10 60 "$HOME/" 3>&1 1>&2 2>&3 || echo "")
            ;;
        "python-tk")
            # Python tkinter GUI fallback
            selected_dir=$(python3 -c "
import tkinter as tk
from tkinter import filedialog
root = tk.Tk()
root.withdraw()
selected = filedialog.askdirectory(initialdir='$HOME', title='Select Output Directory')
if selected:
    print(selected)
" 2>/dev/null || echo "")
            ;;
        "none")
            echo "none"
            return 1
            ;;
    esac
    
    if [[ -n "$selected_dir" && -d "$selected_dir" ]]; then
        echo "$selected_dir"
        return 0
    fi
    
    return 1
}

# ðŸ“‚ Select video folder (change working directory)
select_video_folder() {
    local selected=0
    local picker=$(detect_file_picker)
    local options=()
    local descriptions=()
    
    # Build options array based on available picker
    options+=("Enter path manually")
    descriptions+=("Type the full path to your video folder")
    
    if [[ "$picker" != "none" ]]; then
        options+=("Browse with file picker")
        descriptions+=("Use $picker to select folder visually")
    fi
    
    options+=("Back to main menu")
    descriptions+=("Return without changing folder")
    
    while true; do
        clear
        print_header
        
        echo -e "${CYAN}${BOLD}ðŸ“‚ SELECT VIDEO FOLDER${NC}\n"
        
        # Show current directory
        local current_dir_display="$(pwd | sed "s|$HOME|~|g")"
        local current_dir_path="$(pwd)"
        local clickable_current=$(make_clickable_path "$current_dir_path" "$current_dir_display")
        
        echo -e "${BLUE}ðŸ“‚ Current Video Folder:${NC}"
        echo -e "  $clickable_current"
        
        # Count videos in current folder
        local video_count=$(find . -maxdepth 1 \( -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" \) 2>/dev/null | wc -l)
        echo -e "  ${YELLOW}ðŸ“¹ Videos found: ${BOLD}$video_count${NC}\n"
        
        # Display options with highlight
        for i in "${!options[@]}"; do
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}âž¤ ${options[$i]}${NC}"
                echo -e "    ${CYAN}ðŸ’¡ ${descriptions[$i]}${NC}"
            else
                echo -e "  ${GRAY}  ${options[$i]}${NC}"
            fi
        done
        
        echo ""
        echo -e "${CYAN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸŽ¹ Controls:${NC}                                      ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}W${NC} or ${GREEN}â†‘${NC}  - Move up                              ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}S${NC} or ${GREEN}â†“${NC}  - Move down                            ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}Enter${NC}  - Confirm selection                      ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        
        # Read key
        read -rsn1 key 2>/dev/null || read -r key
        
        case "$key" in
            $'\x1b')  # Arrow keys
                read -rsn2 -t 0.1 key
                case "$key" in
                    '[A') # Up
                        selected=$((selected - 1))
                        [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                        ;;
                    '[B') # Down
                        selected=$((selected + 1))
                        [[ $selected -ge ${#options[@]} ]] && selected=0
                        ;;
                esac
                ;;
            'w'|'W') # Up
                selected=$((selected - 1))
                [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                sleep 0.1
                ;;
            's'|'S') # Down
                selected=$((selected + 1))
                [[ $selected -ge ${#options[@]} ]] && selected=0
                sleep 0.1
                ;;
            ''|$'\n'|$'\r'|' ') # Enter/Space
                break
                ;;
        esac
    done
    
    # Handle the selected option
    # Options array: 0=manual, 1=browse (if available), last=back
    local last_option=$((${#options[@]} - 1))
    
    if [[ $selected -eq $last_option ]]; then
        # Back to main menu
        return 0
    elif [[ $selected -eq 0 ]]; then
        # Manual path entry
        echo -e "\n${CYAN}Enter folder path where videos are located:${NC}"
        echo -e "${GRAY}Common: $HOME/Videos, $HOME/Downloads, $HOME/Pictures${NC}"
        echo -ne "${YELLOW}Path: ${NC}"
        read -r manual_path
        
        if [[ -n "$manual_path" ]]; then
            manual_path="${manual_path/#\~/$HOME}"
            
            if [[ -d "$manual_path" ]]; then
                if cd "$manual_path" 2>/dev/null; then
                    local new_video_count=$(find . -maxdepth 1 \( -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" \) 2>/dev/null | wc -l)
                    echo -e "\n${GREEN}âœ“ Changed to: $manual_path${NC}"
                    echo -e "  ${YELLOW}ðŸ“¹ Videos found: ${BOLD}$new_video_count${NC}"
                    [[ $new_video_count -eq 0 ]] && echo -e "  ${YELLOW}âš ï¸  No video files found in this folder${NC}"
                    sleep 2
                    return 0
                else
                    echo -e "\n${RED}âŒ Cannot access directory: $manual_path${NC}"
                    sleep 2
                fi
            else
                echo -e "\n${RED}âŒ Directory does not exist: $manual_path${NC}"
                sleep 2
            fi
        else
            echo -e "\n${YELLOW}No path entered${NC}"
            sleep 1
        fi
    elif [[ $selected -eq 1 && "$picker" != "none" ]]; then
        # Browse with file picker
        echo -e "\n${GREEN}Opening file picker to select video folder...${NC}"
        sleep 0.5
        
        local selected_dir=$(browse_for_directory)
        
        if [[ $? -eq 0 && -n "$selected_dir" && -d "$selected_dir" ]]; then
            if cd "$selected_dir" 2>/dev/null; then
                local new_video_count=$(find . -maxdepth 1 \( -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" \) 2>/dev/null | wc -l)
                echo -e "\n${GREEN}âœ“ Changed to: $selected_dir${NC}"
                echo -e "  ${YELLOW}ðŸ“¹ Videos found: ${BOLD}$new_video_count${NC}"
                [[ $new_video_count -eq 0 ]] && echo -e "  ${YELLOW}âš ï¸  No video files found in this folder${NC}"
                sleep 2
                return 0
            else
                echo -e "\n${RED}âŒ Cannot access directory: $selected_dir${NC}"
                sleep 2
            fi
        else
            echo -e "\n${YELLOW}â„¹ï¸  No directory selected${NC}"
            sleep 1
        fi
    fi
}

# ðŸ”” Configure notification settings (Advanced UI)
configure_notifications() {
    # Check if settings need upgrade and do it immediately
    local notify_count=$(grep "^NOTIFY_" "$SETTINGS_FILE" 2>/dev/null | wc -l | tr -d ' ')
    [[ -z "$notify_count" ]] && notify_count=0
    if [[ $notify_count -lt 10 ]]; then
        clear
        print_header
        echo -e "${YELLOW}ðŸ”„ Initializing notification settings... ($notify_count/10 found)${NC}\n"
        echo -e "${CYAN}Adding missing notification options to your settings file...${NC}"
        save_settings --silent
        echo -e "${GREEN}âœ“ Notification settings initialized successfully!${NC}"
        echo -e "${CYAN}All 10 notification options are now available.${NC}\n"
        sleep 2
    fi
    
    local selected=0
    local options=(
        "ðŸ”” Master Toggle - All Notifications"
        "ðŸš€ Session Start Notifications"
        "ðŸ”„ Session Found Notifications"
        "âœ… Conversion Complete Notifications"
        "ðŸ“¢ Error Notifications"
        "ðŸ’» Terminal Closed Detection"
        "â° Periodic Reminders (Still Running)"
        "â±ï¸  Reminder Interval"
        "ðŸ“¢ Progress Notifications"
        "â²ï¸  Progress Interval"
        "ðŸ§ª Test Notification"
        "â† Back to Main Menu"
    )
    
    while true; do
        clear
        print_header
        
        echo -e "${CYAN}${BOLD}ðŸ”” NOTIFICATION SETTINGS${NC}"
        echo -e "${GRAY}Configure desktop notifications for various conversion events${NC}\n"
        
        # Check if notify-send is available
        if ! command -v notify-send >/dev/null 2>&1; then
            echo -e "${RED}âš ï¸  notify-send not found!${NC}"
            echo -e "${YELLOW}Install: ${GREEN}sudo zypper install libnotify-tools${NC}\n"
        fi
        
        # Show current notification status
        local master_status=$([ "$NOTIFY_ENABLED" = "true" ] && echo "${GREEN}${BOLD}ENABLED${NC}" || echo "${RED}${BOLD}DISABLED${NC}")
        echo -e "${BLUE}ðŸ“¡ Notification System: ${master_status}${NC}\n"
        
        # Display options with current values
        for i in "${!options[@]}"; do
            local status_indicator=""
            local value_display=""
            
            case $i in
                0) status_indicator=$([ "$NOTIFY_ENABLED" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${RED}â˜${NC}") ;;
                1) status_indicator=$([ "$NOTIFY_SESSION_START" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                2) status_indicator=$([ "$NOTIFY_SESSION_FOUND" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                3) status_indicator=$([ "$NOTIFY_CONVERSION_COMPLETE" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                4) status_indicator=$([ "$NOTIFY_ERROR" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                5) status_indicator=$([ "$NOTIFY_TERMINAL_CLOSED" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                6) status_indicator=$([ "$NOTIFY_REMINDER_ENABLED" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                7) value_display="${CYAN}(${NOTIFY_REMINDER_INTERVAL}s / $(( NOTIFY_REMINDER_INTERVAL / 60 ))m)${NC}" ;;
                8) status_indicator=$([ "$NOTIFY_CONVERSION_PROGRESS" = "true" ] && echo "${GREEN}â˜‘${NC}" || echo "${GRAY}â˜${NC}"); [ "$NOTIFY_ENABLED" = "false" ] && status_indicator="${GRAY}â˜${NC}" ;;
                9) value_display="${CYAN}(${NOTIFY_PROGRESS_INTERVAL}s / $(( NOTIFY_PROGRESS_INTERVAL / 60 ))m)${NC}" ;;
                10) status_indicator="ðŸ§ª" ;;
                11) status_indicator="" ;;
            esac
            
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}â¯ ${options[$i]}${NC} ${status_indicator} ${value_display}"
            else
                echo -e "  ${GRAY}  ${options[$i]}${NC} ${status_indicator} ${value_display}"
            fi
        done
        
        echo ""
        echo -e "${CYAN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        
        # Show help text for selected option
        case $selected in
            0) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Master switch - turns all notifications on/off at once${NC}                 ${CYAN}â”‚${NC}" ;;
            1) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Notify when tmux session starts (shows reconnect commands)${NC}             ${CYAN}â”‚${NC}" ;;
            2) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Notify when existing session found (persistent notification)${NC}          ${CYAN}â”‚${NC}" ;;
            3) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Notify when conversion finishes (success/failure)${NC}                   ${CYAN}â”‚${NC}" ;;
            4) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Notify when errors occur during conversion${NC}                          ${CYAN}â”‚${NC}" ;;
            5) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Alert when Konsole closes with active tmux session${NC}                 ${CYAN}â”‚${NC}" ;;
            6) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Send periodic \"still running\" reminders${NC}                            ${CYAN}â”‚${NC}" ;;
            7) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ How often to send reminder notifications (in seconds)${NC}               ${CYAN}â”‚${NC}" ;;
            8) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Send periodic progress updates during conversion${NC}                   ${CYAN}â”‚${NC}" ;;
            9) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ How often to send progress notifications (in seconds)${NC}              ${CYAN}â”‚${NC}" ;;
            10) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Send a test notification to see what they look like${NC}                ${CYAN}â”‚${NC}" ;;
            11) echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Return to main menu${NC}                                               ${CYAN}â”‚${NC}" ;;
        esac
        
        echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        
        show_tmux_controls
        
        echo -e "\n${CYAN}ðŸŽ® Controls: ${YELLOW}w/s${NC}=Navigate ${YELLOW}Enter/Space${NC}=Toggle/Select ${YELLOW}q${NC}=Back"
        
        # Read single key
        read -rsn1 key 2>/dev/null
        
        case "$key" in
            'w'|'W')
                selected=$((selected - 1))
                [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                ;;
            's'|'S')
                selected=$((selected + 1))
                [[ $selected -ge ${#options[@]} ]] && selected=0
                ;;
            ''|$'\n'|$'\r'|' ')
                case $selected in
                    0) # Master Toggle
                        NOTIFY_ENABLED=$([ "$NOTIFY_ENABLED" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    1) # Session Start
                        NOTIFY_SESSION_START=$([ "$NOTIFY_SESSION_START" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    2) # Session Found
                        NOTIFY_SESSION_FOUND=$([ "$NOTIFY_SESSION_FOUND" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    3) # Conversion Complete
                        NOTIFY_CONVERSION_COMPLETE=$([ "$NOTIFY_CONVERSION_COMPLETE" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    4) # Error Notifications
                        NOTIFY_ERROR=$([ "$NOTIFY_ERROR" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    5) # Terminal Closed Detection
                        NOTIFY_TERMINAL_CLOSED=$([ "$NOTIFY_TERMINAL_CLOSED" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    6) # Reminders
                        NOTIFY_REMINDER_ENABLED=$([ "$NOTIFY_REMINDER_ENABLED" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    7) # Reminder Interval
                        clear
                        print_header
                        echo -e "${CYAN}${BOLD}â±ï¸  SET REMINDER INTERVAL${NC}\n"
                        echo -e "${BLUE}Current interval: ${BOLD}${NOTIFY_REMINDER_INTERVAL}s${NC} ($(( NOTIFY_REMINDER_INTERVAL / 60 )) minutes)\n"
                        echo -e "${YELLOW}Presets:${NC}"
                        echo -e "  ${GREEN}[1]${NC}  5 minutes (300s)"
                        echo -e "  ${GREEN}[2]${NC} 10 minutes (600s) ${CYAN}[Current Default]${NC}"
                        echo -e "  ${GREEN}[3]${NC} 15 minutes (900s)"
                        echo -e "  ${GREEN}[4]${NC} 30 minutes (1800s)"
                        echo -e "  ${GREEN}[5]${NC} Custom value"
                        echo -ne "\n${CYAN}Choice [1-5]: ${NC}"
                        read -r interval_choice
                        case "$interval_choice" in
                            1) NOTIFY_REMINDER_INTERVAL=300 ;;
                            2) NOTIFY_REMINDER_INTERVAL=600 ;;
                            3) NOTIFY_REMINDER_INTERVAL=900 ;;
                            4) NOTIFY_REMINDER_INTERVAL=1800 ;;
                            5)
                                echo -ne "${YELLOW}Enter seconds: ${NC}"
                                read -r custom_interval
                                if [[ "$custom_interval" =~ ^[0-9]+$ ]] && [[ $custom_interval -gt 0 ]]; then
                                    NOTIFY_REMINDER_INTERVAL=$custom_interval
                                fi
                                ;;
                        esac
                        save_settings --silent
                        ;;
                    8) # Progress Notifications
                        NOTIFY_CONVERSION_PROGRESS=$([ "$NOTIFY_CONVERSION_PROGRESS" = "true" ] && echo "false" || echo "true")
                        save_settings --silent
                        ;;
                    9) # Progress Interval
                        clear
                        print_header
                        echo -e "${CYAN}${BOLD}â²ï¸  SET PROGRESS INTERVAL${NC}\n"
                        echo -e "${BLUE}Current interval: ${BOLD}${NOTIFY_PROGRESS_INTERVAL}s${NC} ($(( NOTIFY_PROGRESS_INTERVAL / 60 )) minutes)\n"
                        echo -e "${YELLOW}Presets:${NC}"
                        echo -e "  ${GREEN}[1]${NC}  2 minutes (120s)"
                        echo -e "  ${GREEN}[2]${NC}  5 minutes (300s) ${CYAN}[Current Default]${NC}"
                        echo -e "  ${GREEN}[3]${NC} 10 minutes (600s)"
                        echo -e "  ${GREEN}[4]${NC} Custom value"
                        echo -ne "\n${CYAN}Choice [1-4]: ${NC}"
                        read -r prog_choice
                        case "$prog_choice" in
                            1) NOTIFY_PROGRESS_INTERVAL=120 ;;
                            2) NOTIFY_PROGRESS_INTERVAL=300 ;;
                            3) NOTIFY_PROGRESS_INTERVAL=600 ;;
                            4)
                                echo -ne "${YELLOW}Enter seconds: ${NC}"
                                read -r custom_prog
                                if [[ "$custom_prog" =~ ^[0-9]+$ ]] && [[ $custom_prog -gt 0 ]]; then
                                    NOTIFY_PROGRESS_INTERVAL=$custom_prog
                                fi
                                ;;
                        esac
                        save_settings --silent
                        ;;
                    10) # Test Notification
                        if command -v notify-send >/dev/null 2>&1; then
                            notify-send -u normal -t 5000 -i video-x-generic \
                                "ðŸ§ª GIF Converter Test" \
                                "This is a test notification!\n\nIf you can see this, notifications are working correctly. âœ…" \
                                2>/dev/null &
                            echo -e "\n${GREEN}âœ“ Test notification sent!${NC}"
                            sleep 2
                        else
                            echo -e "\n${RED}âŒ notify-send not found!${NC}"
                            echo -e "${YELLOW}Install with: sudo zypper install libnotify-tools${NC}"
                            sleep 3
                        fi
                        ;;
                    11) # Back
                        return 0
                        ;;
                esac
                ;;
            'q'|'Q')
                return 0
                ;;
        esac
    done
}

# ðŸ“ Configure output directory
configure_output_directory() {
    local selected=0
    
    # Calculate actual paths for display based on what each option WILL set
    local current_dir="$(pwd)"
    local converted_gifs_path="$current_dir/converted_gifs"  # Option 1: ./converted_gifs from current dir
    local pictures_path="$HOME/Pictures/GIFs"                # Option 2: Pictures folder
    local current_dir_path="$current_dir"                    # Option 3: Current directory itself
    
    local options=(
        "./converted_gifs - Keep videos & GIFs organized"
        "Pictures folder - Save to system Pictures directory"
        "Current directory - Save with your video files"
        "Custom path - Choose your own location"
        "Back to main menu"
    )
    local descriptions=(
        "Path: $converted_gifs_path"
        "Path: $pictures_path"
        "Path: $current_dir_path"
        "Browse with file picker or type any path you want"
        "Return to main menu without changes"
    )
    
    while true; do
        clear
        print_header
        
        echo -e "${CYAN}${BOLD}ðŸ“ OUTPUT DIRECTORY CONFIGURATION${NC}\n"
        
        # Show current output directory
        local output_display="$(echo "$OUTPUT_DIRECTORY" | sed "s|$HOME|~|g")"
        local output_abs="$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd || echo "$OUTPUT_DIRECTORY")"
        local clickable_output=$(make_clickable_path "$output_abs" "$output_display")
        
        echo -e "${BLUE}ðŸ’¾ Current Output Directory:${NC}"
        echo -e "  $clickable_output"
        echo -e "  ${GRAY}Mode: $OUTPUT_DIR_MODE${NC}\n"
        
        # Check if directory exists and is writable
        if [[ -d "$OUTPUT_DIRECTORY" ]]; then
            if [[ -w "$OUTPUT_DIRECTORY" ]]; then
                echo -e "  ${GREEN}âœ“ Directory exists and is writable${NC}"
            else
                echo -e "  ${YELLOW}âš ï¸  Warning: Directory is not writable${NC}"
            fi
        else
            echo -e "  ${YELLOW}âš ï¸  Directory does not exist (will be created)${NC}"
        fi
        
        echo -e "${CYAN}${BOLD}ðŸ“ OPTIONS:${NC}\n"
        
        # Display options with highlight (no descriptions here)
        for i in "${!options[@]}"; do
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}âž¤ ${options[$i]}${NC}"
            else
                echo -e "  ${GRAY}  ${options[$i]}${NC}"
            fi
        done
        
        echo ""
        echo -e "${CYAN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ Full Path:${NC}                                               ${CYAN}â”‚${NC}"
        
        # Make path clickable based on selected option
        local clickable_desc=""
        case $selected in
            0) clickable_desc=$(make_clickable_path "$converted_gifs_path" "$converted_gifs_path") ;;
            1) clickable_desc=$(make_clickable_path "$pictures_path" "$pictures_path") ;;
            2) clickable_desc=$(make_clickable_path "$current_dir_path" "$current_dir_path") ;;
            *) clickable_desc="${descriptions[$selected]}" ;;
        esac
        
        echo -e "${CYAN}â”‚${NC}   $clickable_desc$(printf '%*s' $((77 - ${#descriptions[$selected]})) '')${CYAN}â”‚${NC}"
        echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        echo -e "${CYAN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo -e "${CYAN}â”‚${NC} ${YELLOW}ðŸŽ¹ Controls:${NC}                                      ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}W${NC} or ${GREEN}â†‘${NC}  - Move up                              ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}S${NC} or ${GREEN}â†“${NC}  - Move down                            ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â”‚${NC}   ${GREEN}Enter${NC}  - Confirm selection                      ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        
        # Read key
        read -rsn1 key 2>/dev/null || read -r key
        
        case "$key" in
            $'\x1b')  # Arrow keys
                read -rsn2 -t 0.1 key
                case "$key" in
                    '[A') # Up
                        selected=$((selected - 1))
                        [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                        ;;
                    '[B') # Down
                        selected=$((selected + 1))
                        [[ $selected -ge ${#options[@]} ]] && selected=0
                        ;;
                esac
                ;;
            'w'|'W') # Up
                selected=$((selected - 1))
                [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                sleep 0.1
                ;;
            's'|'S') # Down
                selected=$((selected + 1))
                [[ $selected -ge ${#options[@]} ]] && selected=0
                sleep 0.1
                ;;
            ''|$'\n'|$'\r'|' ') # Enter/Space
                break
                ;;
        esac
    done
    
    local choice=$((selected + 1))
    
    case "$choice" in
        "1")
            # Set to ./converted_gifs (relative to current working directory)
            OUTPUT_DIRECTORY="./converted_gifs"
            OUTPUT_DIR_MODE="default"
            
            # Create directory if it doesn't exist
            mkdir -p "$OUTPUT_DIRECTORY" 2>/dev/null || {
                echo -e "\n${RED}âŒ Cannot create directory: $OUTPUT_DIRECTORY${NC}"
                sleep 2
                return 1
            }
            
            # Get absolute path for display
            local abs_path="$(cd "$OUTPUT_DIRECTORY" && pwd)"
            
            clear
            print_header
            echo -e "\n${GREEN}âœ“ Output directory set to: $abs_path${NC}"
            echo -e "  ${CYAN}ðŸ’¡ Organized subfolder - recommended${NC}"
            echo -e "  ${GREEN}âœ“ Directory created and ready${NC}"
            save_settings --silent
            sleep 2
            ;;
        "2")
            OUTPUT_DIRECTORY="$HOME/Pictures/GIFs"
            OUTPUT_DIR_MODE="pictures"
            
            # Create directory
            mkdir -p "$OUTPUT_DIRECTORY" 2>/dev/null || {
                echo -e "\n${RED}âŒ Cannot create Pictures/GIFs directory${NC}"
                sleep 2
                return 1
            }
            
            clear
            print_header
            echo -e "\n${GREEN}âœ“ Output directory set to: $OUTPUT_DIRECTORY${NC}"
            echo -e "  ${GREEN}âœ“ Directory created and ready${NC}"
            save_settings --silent
            sleep 2
            ;;
        "3")
            # Current directory (where user is running the script FROM)
            OUTPUT_DIRECTORY="$(pwd)"
            OUTPUT_DIR_MODE="current"
            
            # Verify directory is writable
            if [[ ! -w "$OUTPUT_DIRECTORY" ]]; then
                echo -e "\n${RED}âŒ Current directory is not writable${NC}"
                sleep 2
                return 1
            fi
            
            clear
            print_header
            echo -e "\n${GREEN}âœ“ Output directory set to: $(pwd)${NC}"
            echo -e "  ${CYAN}ðŸ’¡ Same folder as your video files (current directory)${NC}"
            echo -e "  ${GREEN}âœ“ Directory ready${NC}"
            save_settings --silent
            sleep 2
            ;;
        "4")
            # Custom path - try file picker first
            local picker=$(detect_file_picker)
            local custom_path=""
            
            if [[ "$picker" != "none" ]]; then
                echo -e "\n${CYAN}Opening file picker...${NC}"
                sleep 0.5
                custom_path=$(browse_for_directory)
                
                if [[ -z "$custom_path" ]]; then
                    echo -e "${YELLOW}No directory selected. Enter path manually:${NC}"
                    echo -ne "${YELLOW}Path: ${NC}"
                    read -r custom_path
                    custom_path="${custom_path/#\~/$HOME}"
                fi
            else
                echo -e "\n${CYAN}Enter custom output directory path:${NC}"
                echo -e "${GRAY}Common: ./converted_gifs, $HOME/Pictures/GIFs${NC}"
                echo -ne "${YELLOW}Path: ${NC}"
                read -r custom_path
            fi
            
            # Expand ~ to $HOME
            custom_path="${custom_path/#\~/$HOME}"
            
            # Validate path is not empty
            if [[ -z "$custom_path" ]]; then
                echo -e "${RED}âŒ No path entered${NC}"
                sleep 1
                return 1
            fi
            
            # Create directory if it doesn't exist
            if [[ ! -d "$custom_path" ]]; then
                echo -ne "\n${YELLOW}Directory does not exist. Create it? [Y/n]: ${NC}"
                read -r confirm
                if [[ ! "$confirm" =~ ^[Nn]$ ]]; then
                    mkdir -p "$custom_path" 2>/dev/null || {
                        echo -e "${RED}âŒ Cannot create directory: $custom_path${NC}"
                        sleep 2
                        return 1
                    }
                    echo -e "${GREEN}âœ“ Directory created successfully${NC}"
                else
                    echo -e "${YELLOW}Cancelled - directory not created${NC}"
                    sleep 1
                    return 1
                fi
            fi
            
            # Verify it's writable
            if [[ ! -w "$custom_path" ]]; then
                echo -e "${RED}âŒ Directory is not writable: $custom_path${NC}"
                sleep 2
                return 1
            fi
            
            OUTPUT_DIRECTORY="$custom_path"
            OUTPUT_DIR_MODE="custom"
            clear
            print_header
            echo -e "\n${GREEN}âœ“ Output directory set to: $custom_path${NC}"
            echo -e "  ${GREEN}âœ“ Directory ready for conversions${NC}"
            save_settings --silent
            sleep 2
            ;;
        "5"|"0"|"")
            return 0
            ;;
    esac
}

# ðŸŽ¨ Interactive Main Menu System
show_main_menu() {
    # Ensure we always start at the first option
    local selected=0
    local options=(
        "ðŸš€ AI-Powered Quick Mode (Speed Optimized)"
        "ðŸŽ›ï¸  Smart AI Configuration (Balanced Control)"
        "âš™ï¸  Configure Settings & Convert (Advanced)"
        "ðŸ’¾ Configure Output Directory"
        "ðŸ“Š View Conversion Statistics"
        "ðŸ¤– AI System Status & Diagnostics"
        "ðŸ”” Notification Settings"
        "ðŸ“ Manage Log Files"
        "ðŸ”§ System Information"
        "ðŸ”« Kill FFmpeg Processes"
        "â“ Help & Documentation"
        "ðŸ“¦ Check Dependencies"
        "ðŸ”„ Check for Updates"
        "ðŸ› ï¸  Reset All Settings"
        "ðŸšº Exit"
    )
    
    while true; do
        clear
        print_header
        
        # Show current directory info
        local video_count=$(find . -maxdepth 1 -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" 2>/dev/null | wc -l)
        local gif_count=$(find . -maxdepth 1 -name "*.gif" 2>/dev/null | wc -l)
        
        # Create clickable directory links for easy navigation
        local current_dir_path="$(pwd)"
        local current_dir_display="$(pwd | sed "s|$HOME|~|g")"
        local clickable_current_dir=$(make_clickable_path "$current_dir_path" "$current_dir_display")
        
        echo -e "${BLUE}ðŸ“‚ Current Directory: ${BOLD}$clickable_current_dir${NC}"
        echo -e "${YELLOW}ðŸ“¹ Video Files: ${BOLD}$video_count${NC} | ${GREEN}ðŸŽ¬ GIF Files: ${BOLD}$gif_count${NC}"
        
        # Quick access links section - script's settings directory
        local settings_dir="$HOME/.smart-gif-converter"
        
        # Ensure settings directory exists before creating clickable link
        if [[ ! -d "$settings_dir" ]]; then
            mkdir -p "$settings_dir" 2>/dev/null || true
        fi
        
        local quick_links="$(make_clickable_path "$settings_dir" "~/.smart-gif-converter/")"
        
        # Add cache link if enabled
        if [[ "$AI_CACHE_ENABLED" == "true" ]]; then
            quick_links="$quick_links | $(make_clickable_path "$AI_CACHE_DIR" "ðŸ—« Cache")"
        fi
        
        # Add training folder link if AI training enabled
        if [[ "$AI_TRAINING_ENABLED" == "true" ]]; then
            quick_links="$quick_links | $(make_clickable_path "$AI_TRAINING_DIR" "ðŸ§  AI Training")"
        fi
        
        # Add parent directory link for easy navigation up
        local parent_dir="$(dirname "$(pwd)")"
        quick_links="$quick_links | $(make_clickable_path "$parent_dir" "â¬†ï¸ Parent")"
        
        # Add home directory link
        quick_links="$quick_links | $(make_clickable_path "$HOME" "ðŸ  Home")"
        
        echo -e "${CYAN}ðŸ”— Quick Links: ${NC}$quick_links"
        
        # Current settings with status
        local ai_status=$([[ "$AI_ENABLED" == true ]] && echo "ON" || echo "OFF")
        
        # Make output directory clickable with full path
        local output_abs_path="$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd || realpath -m "$OUTPUT_DIRECTORY" 2>/dev/null || echo "$OUTPUT_DIRECTORY")"
        local output_display="$(echo "$output_abs_path" | sed "s|$HOME|~|g")"
        local clickable_output=$(make_clickable_path "$output_abs_path" "$output_display")
        
        echo -e "${MAGENTA}âš™ï¸  Current Settings: ${QUALITY} quality, ${ASPECT_RATIO} aspect ratio, AI:${ai_status}${NC}"
        echo -e "${BLUE}ðŸ’¾ Output Directory: $clickable_output${NC}"
        
        # Dev Mode and Update Status Display
        local dev_status=$([[ "$DEV_MODE" == true ]] && echo "${YELLOW}DEV${NC}" || echo "${GREEN}USER${NC}")
        local update_status=""
        local update_info_file="$LOG_DIR/.update_available"
        
        # In DEV_MODE, show dev status instead of update check
        if [[ "$DEV_MODE" == "true" ]]; then
            update_status="${YELLOW}DEV MODE${NC} - ${GRAY}Updates disabled${NC}"
        # Check if update is available
        elif [[ -f "$update_info_file" && "$AUTO_UPDATE_ENABLED" == "true" ]]; then
            # Load update information
            source "$update_info_file" 2>/dev/null || true
            if [[ "$UPDATE_AVAILABLE" == "true" && -n "$REMOTE_VERSION" ]]; then
                update_status="${YELLOW}UPDATE AVAILABLE${NC} - Smart GIF Converter ${GREEN}v${REMOTE_VERSION}${NC}"
            else
                update_status="${GREEN}UP TO DATE${NC}"
            fi
        elif [[ "$AUTO_UPDATE_ENABLED" == "true" ]]; then
            update_status="${GREEN}UP TO DATE${NC}"
        else
            update_status="${RED}DISABLED${NC}"
        fi
        
        echo -e "${CYAN}ðŸ”§ Mode: $dev_status | ðŸ”„ Updates: $update_status${NC}\n"
        
        # Check if notification settings need upgrade
        local notify_count=$(grep "^NOTIFY_" "$SETTINGS_FILE" 2>/dev/null | wc -l | tr -d ' ')
        [[ -z "$notify_count" ]] && notify_count=0
        if [[ $notify_count -lt 10 ]]; then
            echo -e "${YELLOW}âš ï¸  ${BOLD}SETTINGS UPGRADE AVAILABLE${NC}"
            echo -e "${CYAN}ðŸ”„ Your notification settings need to be initialized ($notify_count/10 found)${NC}"
            echo -e "${GREEN}âž¡ï¸  Go to 'Notification Settings' menu to upgrade automatically${NC}\n"
        fi
        
        echo -e "${CYAN}${BOLD}ðŸŽ¯ MAIN MENU${NC}"
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select ${GREEN}q${NC}=Quit ${GREEN}h${NC}=Help${NC}\n"
        
        # Get terminal dimensions for smart responsive design
        local term_width=$(tput cols 2>/dev/null || echo 80)
        local term_height=$(tput lines 2>/dev/null || echo 24)
        
        # Smart responsive breakpoints (like CSS media queries)
        local menu_width
        local layout_mode="desktop"
        
        if [[ $term_width -lt 50 ]]; then
            # Mobile: Very narrow terminal
            menu_width=$((term_width - 4))
            layout_mode="mobile"
        elif [[ $term_width -lt 80 ]]; then
            # Tablet: Medium width
            menu_width=$((term_width - 8))
            layout_mode="tablet"
        elif [[ $term_width -lt 120 ]]; then
            # Desktop: Normal width - use 70%
            menu_width=$((term_width * 70 / 100))
            layout_mode="desktop"
        else
            # Large desktop: Cap at readable width
            menu_width=84
            layout_mode="desktop-large"
        fi
        
        # Ensure sane bounds
        if [[ $menu_width -lt 40 ]]; then menu_width=40; fi
        if [[ $menu_width -gt 100 ]]; then menu_width=100; fi
        
        # Smart help text based on layout mode
        local help_text
        case $selected in
            0) help_text=$(get_responsive_help_text "AI Quick Mode - just pick quality!" "Just select quality level - AI handles everything else automatically!" $layout_mode) ;;
            1) help_text=$(get_responsive_help_text "Smart AI Config - balanced control" "Choose key AI features and settings without overwhelming complexity" $layout_mode) ;;
            2) help_text=$(get_responsive_help_text "Configure 15+ settings" "Fine-tune all 15+ settings for perfect results and control" $layout_mode) ;;
            3) help_text=$(get_responsive_help_text "Choose output directory" "Set where GIFs are saved: current dir, Pictures, or custom path" $layout_mode) ;;
            4) help_text=$(get_responsive_help_text "View conversion stats" "View your conversion history and success rates with details" $layout_mode) ;;
            5) help_text=$(get_responsive_help_text "AI system diagnostics" "Check AI cache, training data, health status, and performance" $layout_mode) ;;
            6) help_text=$(get_responsive_help_text "Notification settings" "Configure desktop notifications, reminders, and alerts" $layout_mode) ;;
            7) help_text=$(get_responsive_help_text "Manage log files" "Manage error logs and conversion history files safely" $layout_mode) ;;
            8) help_text=$(get_responsive_help_text "System info" "Check CPU, GPU, and system capabilities for optimization" $layout_mode) ;;
            9) help_text=$(get_responsive_help_text "Kill processes" "Stop any stuck or runaway FFmpeg processes safely" $layout_mode) ;;
            10) help_text=$(get_responsive_help_text "Help & docs" "Complete usage guide with examples and feature docs" $layout_mode) ;;
            11) help_text=$(get_responsive_help_text "Check dependencies" "Review and install required and optional dependencies" $layout_mode) ;;
            12) help_text=$(get_responsive_help_text "Check for updates" "Check for and install script updates from GitHub" $layout_mode) ;;
            13) help_text=$(get_responsive_help_text "Reset settings" "Reset all settings to factory defaults (files are safe)" $layout_mode) ;;
            14) help_text=$(get_responsive_help_text "Exit" "Save your current settings and exit gracefully" $layout_mode) ;;
        esac
        
        # Calculate actual content width by measuring the longest menu option
        local max_content_len=0
        local current_len
        
        # Measure title length
        local title="MENU OPTIONS"
        if [[ $layout_mode == "mobile" ]]; then
            title="MENU"
        fi
        max_content_len=${#title}
        
        # Measure each menu option length (simple character count + buffer for emojis)
        for option in "${options[@]}"; do
            # Simple width estimation: raw length + buffer for emojis
            # Most menu options have 1-2 emojis, so add 2-4 extra characters as buffer
            current_len=$((${#option} + 4))  # +4 buffer for emojis and formatting
            if [[ $current_len -gt $max_content_len ]]; then
                max_content_len=$current_len
            fi
        done
        
        # Measure help text length with emoji buffer
        current_len=$((${#help_text} + 4))  # +4 for icon, space and emoji buffer
        if [[ $current_len -gt $max_content_len ]]; then
            max_content_len=$current_len
        fi
        
        # Use fixed, generous width to accommodate emojis and ensure alignment
        local inner_width
        case $layout_mode in
            "mobile")
                inner_width=45
                ;;
            "tablet")
                inner_width=65
                ;;
            *)
                inner_width=80  # Wide enough for all content with emoji buffer
                ;;
        esac
        
        # Ensure help text fits within inner width
        if [[ ${#help_text} -gt $((inner_width - 5)) ]]; then
            help_text="${help_text:0:$((inner_width - 8))}..."
        fi
        
        # Create clean ASCII borders with fixed width for perfect alignment
        local content_width=65  # Fixed content area width
        local border_chars=$(printf "%*s" $content_width "" | tr ' ' '-')
        
        # Menu borders with consistent width
        local top_border="+${border_chars}+"
        local mid_border="+${border_chars}+"
        local bot_border="+${border_chars}+"
        
        # Smart responsive menu layout
        echo -e "${CYAN}$top_border${NC}"
        
        # Header with responsive title
        local title="MENU OPTIONS"
        if [[ $layout_mode == "mobile" ]]; then
            title="MENU"
        fi
        local title_padded_content=$(printf "%-${content_width}s" "$title")
        echo -e "${CYAN}|${NC} ${BOLD}${title_padded_content}${NC} ${CYAN}|${NC}"
        echo -e "${CYAN}$mid_border${NC}"
        
        # Display menu options with guaranteed perfect alignment
        for i in "${!options[@]}"; do
            local option_text="${options[$i]}"
            
            # Truncate text if it's too long (accounting for emojis)
            if [[ ${#option_text} -gt $((content_width - 5)) ]]; then
                option_text="${option_text:0:$((content_width - 8))}..."
            fi
            
            if [[ $i -eq $selected ]]; then
                # Selected option with arrow - use fixed spacing
                local padded_content=$(printf "%-${content_width}s" "> $option_text")
                echo -e "${CYAN}|${NC} ${GREEN}${BOLD}${padded_content}${NC} ${CYAN}|${NC}"
            else
                # Regular option with indent - use fixed spacing
                local padded_content=$(printf "%-${content_width}s" "   $option_text")
                echo -e "${CYAN}|${NC} ${padded_content} ${CYAN}|${NC}"
            fi
        done
        
        # Close the main menu box
        echo -e "${CYAN}$bot_border${NC}"
        
        # Dynamic help section that adjusts to content (only show if not mobile or very cramped)
        if [[ $layout_mode != "mobile" || $term_height -gt 15 ]]; then
            # Beautiful emoji icon
            local help_icon="ðŸ’¡"
            if [[ $layout_mode == "mobile" ]]; then
                help_icon="â†’"  # Arrow for mobile
            fi
            
            # Use the same width as main menu for perfect alignment
            local help_full_text="$help_icon $help_text"
            
            # Truncate help text if too long to fit in content area
            if [[ ${#help_full_text} -gt $((content_width - 2)) ]]; then
                help_full_text="${help_full_text:0:$((content_width - 5))}..."
            fi
            
            # Create help section borders using same width as main menu
            local help_border="+${border_chars}+"
            
            echo -e "${CYAN}$help_border${NC}"
            
            # Create padded help content using same width as main menu
            local help_padded_content=$(printf "%-${content_width}s" "$help_full_text")
            echo -e "${CYAN}|${NC} ${YELLOW}${help_padded_content}${NC} ${CYAN}|${NC}"
            
            echo -e "${CYAN}$help_border${NC}"
        fi
        
        # Show layout debug info in very wide terminals
        if [[ $term_width -gt 150 && $layout_mode == "desktop-large" ]]; then
            echo -e "${GRAY}Layout: $layout_mode | Terminal: ${term_width}x${term_height} | Menu: ${menu_width}${NC}"
        fi
        
        # Show tmux controls at the bottom of main menu
        show_tmux_controls
        
        echo -e "\n${CYAN}ðŸŽ® Controls: ${YELLOW}w/s${NC}=Navigate ${YELLOW}Enter/Space${NC}=Select ${YELLOW}q${NC}=Quit ${YELLOW}h/?${NC}=Help"
        
        # True single-key input without Enter
        local key=""
        
        # Use bash read with -n1 for single character input
        if read -rsn1 key 2>/dev/null; then
            # Successfully read single character
            true
        else
            # Fallback: read line and take first character
            printf "${MAGENTA}Press key: ${NC}"
            read -r key 2>/dev/null
            key="${key:0:1}"
        fi
        
        case "$key" in
            ''|$'\n'|$'\r'|' ')  # Enter, Return, Space, or empty (Enter without -n1)
                execute_menu_option $selected
                ;;
            'q'|'Q'|$'\x03')  # q, Q, or Ctrl+C
                echo -e "${YELLOW}ðŸ‘‹ Goodbye!${NC}"
                exit 0
                ;;
            'w'|'W')  # Up navigation (w key)
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                # Small delay to make navigation visible
                sleep 0.1
                ;;
            's'|'S')  # Down navigation (s key)
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                # Small delay to make navigation visible  
                sleep 0.1
                ;;
            'h'|'H'|'?')  # Help
                clear
                print_header
                echo -e "${BLUE}${BOLD}â“ NAVIGATION HELP${NC}\n"
                echo -e "${YELLOW}Keyboard Controls:${NC}"
                echo -e "  ${GREEN}â†‘ Up Arrow${NC} - Navigate up"
                echo -e "  ${GREEN}â†“ Down Arrow${NC} - Navigate down"
                echo -e "  ${GREEN}w / s${NC} - WASD-style navigation (up/down)"
                echo -e "  ${GREEN}Enter / Space${NC} - Select highlighted option"
                echo -e "  ${GREEN}q${NC} - Quit application"
                echo -e "  ${GREEN}h / ?${NC} - Show this help\n"
                echo -e "${CYAN}Tips:${NC}"
                echo -e "  â€¢ Use arrow keys for smooth navigation"
                echo -e "  â€¢ w/s keys also work (WASD-style)"
                echo -e "  â€¢ Press Enter to select the highlighted option"
                echo -e "\n${YELLOW}Press any key to return to menu...${NC}"
                read -r -n1 2>/dev/null || read -r
                ;;
            *)  # Invalid input - just ignore and continue
                ;;
        esac
    done
}

# ðŸŽ¯ Execute selected menu option
execute_menu_option() {
    local option=$1
    
    case $option in
        0) # Quick Mode
            echo -e "\n${GREEN}ðŸš€ Starting Quick Conversion...${NC}"
            sleep 1
            quick_convert_mode
            ;;
        1) # Smart AI Configuration Mode
            echo -e "\n${CYAN}ðŸŽ›ï¸  Entering Smart AI Configuration...${NC}"
            sleep 1
            smart_ai_config_mode
            ;;
        2) # Advanced Mode
            echo -e "\n${BLUE}âš™ï¸  Entering Advanced Configuration...${NC}"
            sleep 1
            advanced_convert_mode
            ;;
        3) # Configure Output Directory
            configure_output_directory
            ;;
        4) # Statistics
            show_conversion_stats
            ;;
        5) # AI Status & Diagnostics
            clear
            print_header
            show_ai_status
            show_tmux_controls
            echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
            read -rsn1
            ;;
        6) # Notification Settings
            configure_notifications
            ;;
        7) # Manage Logs
            manage_log_files
            ;;
        8) # System Info
            show_system_info
            ;;
        9) # Kill FFmpeg
            kill_ffmpeg_processes
            ;;
        10) # Help
            show_interactive_help
            ;;
        11) # Check Dependencies
            show_dependency_check_menu
            ;;
        12) # Check for Updates
            clear
            print_header
            echo -e "${CYAN}${BOLD}ðŸ”„ CHECKING FOR UPDATES${NC}\n"
            echo -e "${BLUE}ðŸ’» Repository: ${CYAN}https://github.com/${GITHUB_REPO}${NC}"
            echo -e "${BLUE}ðŸ“… Current Version: ${YELLOW}v${CURRENT_VERSION}${NC}\n"
            
            # Run manual update check
            manual_update
            
            show_tmux_controls
            echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
            read -rsn1
            ;;
        13) # Reset All Settings
            reset_all_settings
            ;;
        14) # Exit
            echo -e "\n${YELLOW}ðŸ‘‹ Goodbye!${NC}"
            exit 0
            ;;
    esac
}

# ðŸš€ AI-Powered Quick Conversion Mode
quick_convert_mode() {
    clear
    print_header
    echo -e "${GREEN}${BOLD}ðŸš€ AI-POWERED QUICK CONVERSION${NC}\n"
    
    local video_files=()
    shopt -s nullglob
    for ext in mp4 avi mov mkv webm; do
        video_files+=(*."$ext")
    done
    shopt -u nullglob
    
    if [[ ${#video_files[@]} -eq 0 ]]; then
        echo -e "${RED}âŒ No video files found in current directory${NC}\n"
        echo -e "${BLUE}ðŸ¤– ${BOLD}AI Video Discovery - Let me help you find videos!${NC}"
        
        # AI-powered video search
        ai_discover_videos
        local discovery_result=$?
        
        if [[ $discovery_result -eq 0 ]]; then
            # Videos were found and user selected some - restart the function
            quick_convert_mode
            return
        else
            # No videos found or user declined
            echo -e "\n${BLUE}ðŸ“ ${BOLD}Manual options:${NC}"
            echo -e "  ${CYAN}â€¢${NC} Place video files in: ${BOLD}$(pwd)${NC}"
            echo -e "  ${CYAN}â€¢${NC} Supported formats: ${GREEN}.mp4 .avi .mov .mkv .webm${NC}"
            echo -e "  ${CYAN}â€¢${NC} Or use: ${YELLOW}--file /path/to/video.mp4${NC}"
            show_tmux_controls
            echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
            read -rsn1
            return
        fi
    fi
    
    echo -e "${BLUE}ðŸ“¹ Found ${BOLD}${#video_files[@]}${NC}${BLUE} video files${NC}"
    echo -e "${CYAN}ðŸ¤– AI will automatically analyze each video and optimize all settings${NC}"
    echo -e "${MAGENTA}ðŸŽ¯ You only need to choose your preferred quality level${NC}"
    echo -e "${GREEN}âš¡ Speed-optimized: Uses all ${BOLD}$(nproc 2>/dev/null || echo '4')${NC}${GREEN} CPU cores for maximum performance${NC}\n"
    
    # AI-powered quality selection
    ai_quality_selection
    
    # Enable AI automatically for quick mode
    AI_ENABLED=true
    AI_MODE="smart"  # Use comprehensive smart analysis
    
    # Auto-enable optimal settings for AI mode
    AUTO_OPTIMIZE=true
    PARALLEL_JOBS="auto"  # Let AI determine optimal parallel jobs
    PROGRESS_BAR=true
    
    echo -e "\n${GREEN}${BOLD}ðŸ¤– AI QUICK MODE SETTINGS:${NC}"
    echo -e "  ${CYAN}âœ“ Quality Level:${NC} ${BOLD}$QUALITY${NC}"
    echo -e "  ${CYAN}âœ“ AI Analysis:${NC} ${BOLD}Smart Mode (Full Analysis)${NC}"
    echo -e "  ${CYAN}âœ“ Auto-Optimization:${NC} ${BOLD}Enabled${NC}"
    echo -e "  ${CYAN}âœ“ Parallel Processing:${NC} ${BOLD}Auto-Detected${NC}"
    echo -e "\n${YELLOW}${BOLD}ðŸ§  AI will analyze each video for:${NC}"
    echo -e "  ${BLUE}â€¢ Content type (animation, screencast, movie, clip)${NC}"
    echo -e "  ${BLUE}â€¢ Motion complexity (static, low, medium, high)${NC}"
    echo -e "  ${BLUE}â€¢ Visual complexity and optimal color count${NC}"
    echo -e "  ${BLUE}â€¢ Intelligent cropping opportunities${NC}"
    echo -e "  ${BLUE}â€¢ Frame rate and dithering optimization${NC}"
    echo -e "  ${BLUE}â€¢ Resolution and scaling algorithm selection${NC}"
    
    echo -ne "\n${MAGENTA}${BOLD}ðŸš€ Ready to start AI-powered conversion? [Y/n]:${NC} "
    read -r confirm
    
    if [[ ! "$confirm" =~ ^[Nn]$ ]]; then
        INTERACTIVE_MODE=false
            echo -e "\n${CYAN}ðŸ¤– Starting AI-powered conversion with smart analysis...${NC}"
            echo -e "${BLUE}ðŸ“Š AI will analyze each video and optimize automatically!${NC}"
            echo -e "${GREEN}âš¡ Using ${BOLD}$(nproc 2>/dev/null || echo '4')${NC}${GREEN} CPU cores for maximum speed!${NC}\n"
        
        # Show AI analysis preview for first file
        if [[ ${#video_files[@]} -gt 0 ]]; then
            echo -e "${YELLOW}ðŸ” AI Preview Analysis (first file: $(basename -- "${video_files[0]}"))...${NC}"
            ai_preview_analysis "${video_files[0]}"
        fi
        
        if start_conversion; then
            # Check if process was interrupted
            if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
                echo -e "\n${YELLOW}ðŸ‘‹ Process incomplete - stopped by user${NC}"
                echo -e "${CYAN}ðŸ’¾ Progress saved! Run again to continue where you left off.${NC}"
                echo -e "${BLUE}ðŸ’¡ Tip: Completed files are already converted and will be skipped.${NC}"
            else
                echo -e "\n${GREEN}ðŸŽ‰ AI-powered quick conversion completed successfully!${NC}"
                echo -e "${BLUE}ðŸ“¦ Your GIF files are ready in the current directory!${NC}"
                echo -e "${CYAN}ðŸ“Š Check Statistics to see detailed results, or run again with new videos!${NC}"
            fi
            show_ai_summary
        else
            if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
                echo -e "\n${YELLOW}ðŸ‘‹ Process stopped - no files were converted${NC}"
                echo -e "${BLUE}ðŸ’¡ Tip: Run again when ready to continue.${NC}"
            else
                echo -e "\n${YELLOW}ðŸ“‹ Quick conversion completed (no action needed)${NC}"
                echo -e "${BLUE}ðŸ’¡ Tip: Add video files to this directory and run again!${NC}"
            fi
        fi
    fi
    
    echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# ðŸŽ›ï¸ Smart AI Configuration Mode with WASD Navigation
smart_ai_config_mode() {
    local video_files=()
    shopt -s nullglob
    for ext in mp4 avi mov mkv webm; do
        video_files+=(*."$ext")
    done
    shopt -u nullglob
    
    if [[ ${#video_files[@]} -eq 0 ]]; then
        clear
        print_header
        echo -e "${RED}âŒ No video files found in current directory${NC}\n"
        echo -e "${BLUE}ðŸ“ ${BOLD}Manual options:${NC}"
        echo -e "  ${CYAN}â€¢${NC} Place video files in: ${BOLD}$(pwd)${NC}"
        echo -e "  ${CYAN}â€¢${NC} Supported formats: ${GREEN}.mp4 .avi .mov .mkv .webm${NC}"
        echo -e "  ${CYAN}â€¢${NC} Or use: ${YELLOW}--file /path/to/video.mp4${NC}"
        echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
        read -rsn1
        return
    fi
    
    # Start the Smart AI Configuration with interactive navigation
    show_smart_ai_menu
}

# ðŸŽ›ï¸ Interactive Smart AI Configuration Menu with WASD Navigation
show_smart_ai_menu() {
    local selected=0
    local options=(
        "ðŸŽ¯ Quality & Resolution Settings"
        "ðŸ¤– AI Feature Selection"
        "âš¡ Performance & Processing"
        "ðŸ“ Output & File Management"
        "ðŸš€ Start Conversion with Current Settings"
        "ðŸ”„ Reset to Smart Defaults"
        "ðŸ”™ Return to Main Menu"
    )
    
    while true; do
        clear
        print_header
        
        echo -e "${CYAN}${BOLD}ðŸŽ›ï¸  SMART AI CONFIGURATION${NC}\n"
        echo -e "${BLUE}Perfect balance between simplicity and control${NC}"
        echo -e "${GRAY}Choose key AI features and settings without overwhelming complexity${NC}\n"
        
        local video_count=$(find . -maxdepth 1 -name "*.mp4" -o -name "*.avi" -o -name "*.mov" -o -name "*.mkv" -o -name "*.webm" 2>/dev/null | wc -l)
        echo -e "${BLUE}ðŸ“¹ Found ${BOLD}$video_count${NC}${BLUE} video files${NC}"
        echo -e "${CYAN}ðŸŽ›ï¸ Configure key settings while AI handles the complexity${NC}\n"
        
        # Show current smart configuration in compact form
        show_smart_ai_config_compact
        
        echo -e "\n${CYAN}${BOLD}ðŸŽ›ï¸ SMART CONFIGURATION OPTIONS${NC}"
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select ${GREEN}q${NC}=Quit ${GREEN}h${NC}=Help${NC}\n"
        
        # Get terminal dimensions for responsive design
        local term_width=$(tput cols 2>/dev/null || echo 80)
        local menu_width
        
        if [[ $term_width -lt 80 ]]; then
            menu_width=$((term_width - 8))
        else
            menu_width=72
        fi
        
        # Smart help text based on selected option
        local help_text
        case $selected in
            0) help_text="Configure quality presets, resolution limits, and file size targets" ;;
            1) help_text="Choose which AI features to enable: content detection, quality optimization, motion analysis" ;;
            2) help_text="Set parallel processing, optimization level, and AI per-file decisions" ;;
            3) help_text="Configure file naming, backup strategy, and validation level" ;;
            4) help_text="Start Smart AI conversion with current settings" ;;
            5) help_text="Reset all settings to recommended smart defaults" ;;
            6) help_text="Return to main menu without making changes" ;;
        esac
        
        # Draw the menu box
        local box_width=$menu_width
        local padding=$(((box_width - 30) / 2))
        [[ $padding -lt 1 ]] && padding=1
        
        # Top border
        printf "${CYAN}â”Œ"
        printf "â”€%.0s" $(seq 1 $((box_width - 2)))
        printf "â”${NC}\n"
        
        # Menu options with highlighting
        for i in "${!options[@]}"; do
            local option="${options[$i]}"
            if [[ $i -eq $selected ]]; then
                printf "${CYAN}â”‚${NC} ${GREEN}${BOLD}>>> %-*s <<<${NC} ${CYAN}â”‚${NC}\n" $((box_width - 12)) "$option"
            else
                printf "${CYAN}â”‚${NC} %-*s ${CYAN}â”‚${NC}\n" $((box_width - 4)) "    $option"
            fi
        done
        
        # Separator
        printf "${CYAN}â”œ"
        printf "â”€%.0s" $(seq 1 $((box_width - 2)))
        printf "â”¤${NC}\n"
        
        # Help text
        printf "${CYAN}â”‚${NC} ${YELLOW}ðŸ’¡ %-*s${NC} ${CYAN}â”‚${NC}\n" $((box_width - 8)) "$help_text"
        
        # Bottom border
        printf "${CYAN}â””"
        printf "â”€%.0s" $(seq 1 $((box_width - 2)))
        printf "â”˜${NC}\n\n"
        
        # Read user input
        read -rsn1 key
        
        case "$key" in
            $'\x1b')  # Escape sequence
                read -rsn2 -t 0.1 key
                case "$key" in
                    '[A') # Up arrow
                        selected=$((selected - 1))
                        if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                        ;;
                    '[B') # Down arrow
                        selected=$((selected + 1))
                        if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                        ;;
                esac
                ;;
            'w'|'W')  # Up navigation (WASD)
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                sleep 0.1
                ;;
            's'|'S')  # Down navigation (WASD)
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                sleep 0.1
                ;;
            ''|' ')  # Enter or Space - Select option
                execute_smart_ai_option $selected
                if [[ $selected -ge 4 ]]; then  # If Start, Reset, or Return was selected
                    return
                fi
                ;;
            'q'|'Q')  # Quit
                return
                ;;
            'h'|'H'|'?')  # Help
                show_smart_ai_help
                ;;
            *)  # Invalid input - ignore
                ;;
        esac
    done
}

# ðŸ“„ Show compact Smart AI configuration
show_smart_ai_config_compact() {
    echo -e "${CYAN}${BOLD}ðŸ“„ CURRENT CONFIGURATION:${NC}"
    
    # AI Features (condensed)
    local ai_features=""
    [[ "${AI_CONTENT_DETECTION:-true}" == "true" ]] && ai_features+="Content "
    [[ "${AI_QUALITY_OPTIMIZATION:-true}" == "true" ]] && ai_features+="Quality "
    [[ "${AI_MOTION_ANALYSIS:-true}" == "true" ]] && ai_features+="Motion "
    [[ -z "$ai_features" ]] && ai_features="None"
    
    echo -e "  ${MAGENTA}ðŸ¤– AI:${NC} $ai_features| ${YELLOW}ðŸŽ¯ Quality:${NC} $QUALITY | ${BLUE}âš¡ Parallel:${NC} ${SMART_PARALLEL_JOBS:-auto}"
    
    local max_res_display=$([[ "$SMART_MAX_RESOLUTION" == "auto" ]] && echo "AI" || echo "$SMART_MAX_RESOLUTION")
    local target_size_display=$([[ "$SMART_TARGET_SIZE" == "auto" ]] && echo "AI" || echo "${SMART_TARGET_SIZE}MB")
    
    echo -e "  ${GREEN}ðŸ“ Resolution:${NC} $max_res_display | ${GREEN}Size:${NC} $target_size_display | ${GREEN}Naming:${NC} ${SMART_NAMING:-ai}"
}

# ðŸŽ® Execute Smart AI menu option
execute_smart_ai_option() {
    local option=$1
    
    case $option in
        0) # Quality & Resolution Settings
            show_smart_quality_menu
            ;;
        1) # AI Feature Selection
            show_smart_ai_features_menu
            ;;
        2) # Performance & Processing
            show_smart_performance_menu
            ;;
        3) # Output & File Management
            show_smart_output_menu
            ;;
        4) # Start Conversion
            clear
            print_header
            echo -e "${CYAN}ðŸŽ›ï¸ Starting Smart AI conversion...${NC}"
            INTERACTIVE_MODE=false
            
            # Apply smart settings to core variables
            apply_smart_settings_to_core
            
            if start_conversion; then
                echo -e "\n${GREEN}ðŸŽ‰ Smart AI conversion completed successfully!${NC}"
                echo -e "${BLUE}ðŸ“¦ Your GIF files are ready in the current directory!${NC}"
                show_ai_summary 2>/dev/null || true
            else
                echo -e "\n${YELLOW}ðŸ“‹ Smart AI conversion completed (no action needed)${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
            read -rsn1
            return
            ;;
        5) # Reset to Smart Defaults
            reset_to_smart_defaults
            clear
            print_header
            echo -e "${GREEN}${BOLD}âœ“ RESET COMPLETE${NC}\n"
            echo -e "${BLUE}All settings have been reset to smart defaults:${NC}"
            echo -e "  ${GREEN}â€¢${NC} AI features enabled (Content, Quality, Motion)"
            echo -e "  ${GREEN}â€¢${NC} Quality preset: High with AI adjustments"
            echo -e "  ${GREEN}â€¢${NC} Resolution: Auto (AI decides)"
            echo -e "  ${GREEN}â€¢${NC} Processing: Auto parallel jobs"
            echo -e "  ${GREEN}â€¢${NC} Output: AI naming, originals backup"
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            ;;
        6) # Return to Main Menu
            return
            ;;
    esac
}

# âš™ï¸ Apply smart settings to core variables
apply_smart_settings_to_core() {
    # AI settings
    AI_ENABLED="true"
    AI_MODE="smart"
    
    # Apply smart parallel jobs to core PARALLEL_JOBS
    if [[ "$SMART_PARALLEL_JOBS" == "auto" ]]; then
        PARALLEL_JOBS="auto"
    else
        PARALLEL_JOBS="$SMART_PARALLEL_JOBS"
    fi
    
    # Apply optimization settings
    case "$SMART_OPTIMIZATION" in
        "light")
            AUTO_OPTIMIZE="false"
            OPTIMIZE_AGGRESSIVE="false"
            ;;
        "balanced")
            AUTO_OPTIMIZE="true"
            OPTIMIZE_AGGRESSIVE="false"
            ;;
        "aggressive")
            AUTO_OPTIMIZE="true"
            OPTIMIZE_AGGRESSIVE="true"
            ;;
    esac
    
    # Apply validation settings
    case "$SMART_VALIDATION" in
        "skip")
            SKIP_VALIDATION="true"
            ;;
        "quick"|"thorough")
            SKIP_VALIDATION="false"
            ;;
    esac
    
    # Apply backup settings
    case "$SMART_BACKUP" in
        "none")
            BACKUP_ORIGINAL="false"
            ;;
        "originals"|"metadata")
            BACKUP_ORIGINAL="true"
            ;;
    esac
    
    # Always enable progress bar for smart mode
    PROGRESS_BAR="true"
}

# â“ Show Smart AI Configuration help
show_smart_ai_help() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}â“ SMART AI CONFIGURATION HELP${NC}\n"
    
    echo -e "${YELLOW}Navigation Controls:${NC}"
    echo -e "  ${GREEN}w / â†‘ Up Arrow${NC} - Navigate up"
    echo -e "  ${GREEN}s / â†“ Down Arrow${NC} - Navigate down"
    echo -e "  ${GREEN}Enter / Space${NC} - Select highlighted option"
    echo -e "  ${GREEN}q${NC} - Quit and return to main menu"
    echo -e "  ${GREEN}h / ?${NC} - Show this help\n"
    
    echo -e "${CYAN}Smart AI Configuration Sections:${NC}"
    echo -e "  ${YELLOW}ðŸŽ¯ Quality & Resolution${NC} - Set quality presets, resolution limits, file size targets"
    echo -e "  ${YELLOW}ðŸ¤– AI Feature Selection${NC} - Choose which AI features to enable or disable"
    echo -e "  ${YELLOW}âš¡ Performance & Processing${NC} - Configure parallel jobs and optimization levels"
    echo -e "  ${YELLOW}ðŸ“ Output & File Management${NC} - Set naming, backup, and validation preferences\n"
    
    echo -e "${MAGENTA}What makes this 'Smart'?${NC}"
    echo -e "  ${BLUE}â€¢${NC} ${BOLD}Balanced Control${NC} - Key settings without overwhelming complexity"
    echo -e "  ${BLUE}â€¢${NC} ${BOLD}AI-Powered${NC} - Smart defaults that adapt to your content"
    echo -e "  ${BLUE}â€¢${NC} ${BOLD}Visual Feedback${NC} - See exactly what each setting does"
    echo -e "  ${BLUE}â€¢${NC} ${BOLD}Instant Reset${NC} - Return to recommended defaults anytime\n"
    
    echo -e "${GREEN}Tips:${NC}"
    echo -e "  â€¢ Use WASD keys for smooth navigation like gaming controls"
    echo -e "  â€¢ Arrow keys also work if you prefer traditional navigation"
    echo -e "  â€¢ Each section has its own navigation for detailed configuration"
    echo -e "  â€¢ Settings are applied immediately when you start conversion\n"
    
    echo -e "${YELLOW}Press any key to return to Smart AI Configuration...${NC}"
    read -rsn1
}

# ðŸŽ¯ Smart Quality & Resolution Menu with WASD Navigation
show_smart_quality_menu() {
    local selected=0
    local options=(
        "Quality Preset: $QUALITY"
        "Max Resolution: ${SMART_MAX_RESOLUTION:-auto}"
        "Target File Size: ${SMART_TARGET_SIZE:-auto}"
        "Frame Rate Mode: ${SMART_FRAMERATE_MODE:-ai}"
        "ðŸ”™ Back to Smart Configuration"
    )
    
    while true; do
        clear
        print_header
        echo -e "${YELLOW}${BOLD}ðŸŽ¯ QUALITY & RESOLUTION SETTINGS${NC}\n"
        echo -e "${BLUE}Configure quality presets, resolution limits, and file size targets${NC}\n"
        
        echo -e "${CYAN}Current Settings:${NC}"
        echo -e "  Quality Preset: ${BOLD}$QUALITY${NC} (with AI adjustments)"
        echo -e "  Max Resolution: ${BOLD}${SMART_MAX_RESOLUTION:-auto}${NC}"
        echo -e "  Target Size: ${BOLD}${SMART_TARGET_SIZE:-auto}${NC}"
        echo -e "  Frame Rate: ${BOLD}${SMART_FRAMERATE_MODE:-ai}${NC}\n"
        
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select ${GREEN}q${NC}=Back\n"
        
        # Draw menu options
        for i in "${!options[@]}"; do
            local option="${options[$i]}"
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}>>> $option <<<${NC}"
            else
                echo -e "      $option"
            fi
        done
        
        echo -e "\n${YELLOW}ðŸ’¡ Tip: AI will optimize within your chosen limits${NC}"
        
        read -rsn1 key
        case "$key" in
            'w'|'W'|$'\x1b[A')  # Up
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                ;;
            's'|'S'|$'\x1b[B')  # Down
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                ;;
            ''|' ')  # Select
                case $selected in
                    0) select_quality_preset ;;
                    1) configure_smart_max_resolution ;;
                    2) configure_smart_target_size ;;
                    3) configure_smart_framerate_mode ;;
                    4) return ;;  # Back
                esac
                if [[ $selected -eq 4 ]]; then return; fi
                # Update options array with new values
                options[0]="Quality Preset: $QUALITY"
                options[1]="Max Resolution: ${SMART_MAX_RESOLUTION:-auto}"
                options[2]="Target File Size: ${SMART_TARGET_SIZE:-auto}"
                options[3]="Frame Rate Mode: ${SMART_FRAMERATE_MODE:-ai}"
                ;;
            'q'|'Q')  # Quit
                return
                ;;
        esac
    done
}

# ðŸ¤– Smart AI Features Menu with WASD Navigation
show_smart_ai_features_menu() {
    local selected=0
    
    while true; do
        local content_status=$([[ "${AI_CONTENT_DETECTION:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
        local quality_status=$([[ "${AI_QUALITY_OPTIMIZATION:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
        local motion_status=$([[ "${AI_MOTION_ANALYSIS:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
        local duplicate_level="${AI_DUPLICATE_DETECTION:-visual}"
        
        local options=(
            "Content Detection: $content_status"
            "Quality Optimization: $quality_status"
            "Motion Analysis: $motion_status"
            "Duplicate Detection: $duplicate_level"
            "ðŸ”™ Back to Smart Configuration"
        )
        
        clear
        print_header
        echo -e "${MAGENTA}${BOLD}ðŸ¤– AI FEATURE SELECTION${NC}\n"
        echo -e "${BLUE}Choose which AI features to enable for intelligent video processing${NC}\n"
        
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Toggle ${GREEN}q${NC}=Back\n"
        
        # Draw menu options with descriptions
        for i in "${!options[@]}"; do
            local option="${options[$i]}"
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}>>> $option <<<${NC}"
                # Show description for selected item
                case $i in
                    0) echo -e "      ${GRAY}Automatically detects animation, screencast, movie, or clip content${NC}" ;;
                    1) echo -e "      ${GRAY}AI adjusts quality parameters based on source characteristics${NC}" ;;
                    2) echo -e "      ${GRAY}Intelligent frame rate adjustments based on movement patterns${NC}" ;;
                    3) echo -e "      ${GRAY}Choose detection level: basic/visual/advanced${NC}" ;;
                esac
            else
                echo -e "      $option"
            fi
        done
        
        echo -e "\n${YELLOW}ðŸ’¡ Tip: More AI features = better results but slower processing${NC}"
        
        read -rsn1 key
        case "$key" in
            'w'|'W'|$'\x1b[A')  # Up
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                ;;
            's'|'S'|$'\x1b[B')  # Down
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                ;;
            ''|' ')  # Select
                case $selected in
                    0) AI_CONTENT_DETECTION=$([[ "${AI_CONTENT_DETECTION:-true}" == "true" ]] && echo "false" || echo "true") ;;
                    1) AI_QUALITY_OPTIMIZATION=$([[ "${AI_QUALITY_OPTIMIZATION:-true}" == "true" ]] && echo "false" || echo "true") ;;
                    2) AI_MOTION_ANALYSIS=$([[ "${AI_MOTION_ANALYSIS:-true}" == "true" ]] && echo "false" || echo "true") ;;
                    3) configure_smart_duplicate_detection ;;
                    4) return ;;  # Back
                esac
                if [[ $selected -eq 4 ]]; then return; fi
                ;;
            'q'|'Q')  # Quit
                return
                ;;
        esac
    done
}

# âš¡ Smart Performance Menu with WASD Navigation
show_smart_performance_menu() {
    local selected=0
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    
    while true; do
        local parallel_display=$([[ "${SMART_PARALLEL_JOBS:-auto}" == "auto" ]] && echo "Auto ($cpu_cores)" || echo "$SMART_PARALLEL_JOBS jobs")
        local per_file_status=$([[ "${SMART_AI_PER_FILE:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
        local optimization_display="${SMART_OPTIMIZATION:-balanced}"
        
        local options=(
            "Parallel Processing: $parallel_display"
            "AI Per-File Decisions: $per_file_status"
            "Optimization Level: $optimization_display"
            "ðŸ”™ Back to Smart Configuration"
        )
        
        clear
        print_header
        echo -e "${BLUE}${BOLD}âš¡ PERFORMANCE & PROCESSING${NC}\n"
        echo -e "${CYAN}System: $cpu_cores CPU cores detected${NC}"
        echo -e "${BLUE}Configure processing speed and resource utilization${NC}\n"
        
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select ${GREEN}q${NC}=Back\n"
        
        # Draw menu options with descriptions
        for i in "${!options[@]}"; do
            local option="${options[$i]}"
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}>>> $option <<<${NC}"
                case $i in
                    0) echo -e "      ${GRAY}Number of videos to process simultaneously${NC}" ;;
                    1) echo -e "      ${GRAY}Let AI choose different settings for each video${NC}" ;;
                    2) echo -e "      ${GRAY}Balance between processing speed and file size${NC}" ;;
                esac
            else
                echo -e "      $option"
            fi
        done
        
        echo -e "\n${YELLOW}ðŸ’¡ Tip: Higher parallel processing = faster conversion but more CPU usage${NC}"
        
        read -rsn1 key
        case "$key" in
            'w'|'W'|$'\x1b[A')  # Up
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                ;;
            's'|'S'|$'\x1b[B')  # Down
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                ;;
            ''|' ')  # Select
                case $selected in
                    0) configure_smart_parallel_jobs ;;
                    1) SMART_AI_PER_FILE=$([[ "${SMART_AI_PER_FILE:-true}" == "true" ]] && echo "false" || echo "true") ;;
                    2) configure_smart_optimization_level ;;
                    3) return ;;  # Back
                esac
                if [[ $selected -eq 3 ]]; then return; fi
                ;;
            'q'|'Q')  # Quit
                return
                ;;
        esac
    done
}

# ðŸ“ Smart Output Menu with WASD Navigation
show_smart_output_menu() {
    local selected=0
    
    while true; do
        local naming_display="${SMART_NAMING:-ai}"
        local backup_display="${SMART_BACKUP:-originals}"
        local validation_display="${SMART_VALIDATION:-quick}"
        
        local options=(
            "File Naming: $naming_display"
            "Backup Strategy: $backup_display"
            "Validation Level: $validation_display"
            "ðŸ”™ Back to Smart Configuration"
        )
        
        clear
        print_header
        echo -e "${GREEN}${BOLD}ðŸ“ OUTPUT & FILE MANAGEMENT${NC}\n"
        echo -e "${BLUE}Configure how files are named, backed up, and validated${NC}\n"
        
        echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select ${GREEN}q${NC}=Back\n"
        
        # Draw menu options with descriptions
        for i in "${!options[@]}"; do
            local option="${options[$i]}"
            if [[ $i -eq $selected ]]; then
                echo -e "  ${GREEN}${BOLD}>>> $option <<<${NC}"
                case $i in
                    0) echo -e "      ${GRAY}How to name output GIF files${NC}" ;;
                    1) echo -e "      ${GRAY}What to backup before conversion${NC}" ;;
                    2) echo -e "      ${GRAY}How thoroughly to check output files${NC}" ;;
                esac
            else
                echo -e "      $option"
            fi
        done
        
        echo -e "\n${YELLOW}ðŸ’¡ Tip: AI naming creates descriptive filenames based on content analysis${NC}"
        
        read -rsn1 key
        case "$key" in
            'w'|'W'|$'\x1b[A')  # Up
                selected=$((selected - 1))
                if [[ $selected -lt 0 ]]; then selected=$((${#options[@]}-1)); fi
                ;;
            's'|'S'|$'\x1b[B')  # Down
                selected=$((selected + 1))
                if [[ $selected -ge ${#options[@]} ]]; then selected=0; fi
                ;;
            ''|' ')  # Select
                case $selected in
                    0) configure_smart_naming ;;
                    1) configure_smart_backup ;;
                    2) configure_smart_validation ;;
                    3) return ;;  # Back
                esac
                if [[ $selected -eq 3 ]]; then return; fi
                ;;
            'q'|'Q')  # Quit
                return
                ;;
        esac
    done
}

# ðŸŽ¨ Configure Smart Max Resolution
configure_smart_max_resolution() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸ“ MAXIMUM RESOLUTION LIMIT${NC}\n"
    echo -e "Current: ${BOLD}${SMART_MAX_RESOLUTION:-auto}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Auto - AI decides based on source quality"
    echo -e "${GREEN}[2]${NC} 480p (854x480) - Small files, mobile-friendly"
    echo -e "${GREEN}[3]${NC} 720p (1280x720) - Balanced quality"
    echo -e "${GREEN}[4]${NC} 1080p (1920x1080) - High quality (recommended)"
    echo -e "${GREEN}[5]${NC} 1440p (2560x1440) - Very high quality"
    echo -e "${GREEN}[6]${NC} 4K (3840x2160) - Maximum quality\n"
    
    echo -e "${MAGENTA}Select resolution limit: ${NC}"
    read -r res_choice
    case "$res_choice" in
        "1") SMART_MAX_RESOLUTION="auto" ;;
        "2") SMART_MAX_RESOLUTION="480p" ;;
        "3") SMART_MAX_RESOLUTION="720p" ;;
        "4") SMART_MAX_RESOLUTION="1080p" ;;
        "5") SMART_MAX_RESOLUTION="1440p" ;;
        "6") SMART_MAX_RESOLUTION="4K" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Max resolution set to: $SMART_MAX_RESOLUTION${NC}"
    sleep 1
}

# ðŸ“† Configure Smart Target Size
configure_smart_target_size() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸ“Š TARGET FILE SIZE${NC}\n"
    echo -e "Current: ${BOLD}${SMART_TARGET_SIZE:-auto}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Auto - AI optimized for quality/size balance"
    echo -e "${GREEN}[2]${NC} Small (1MB average) - Social media stories"
    echo -e "${GREEN}[3]${NC} Medium (5MB average) - General use (recommended)"
    echo -e "${GREEN}[4]${NC} Large (10MB average) - High quality sharing"
    echo -e "${GREEN}[5]${NC} No limit - Quality focused\n"
    
    echo -e "${MAGENTA}Select target size: ${NC}"
    read -r size_choice
    case "$size_choice" in
        "1") SMART_TARGET_SIZE="auto" ;;
        "2") SMART_TARGET_SIZE="1" ;;
        "3") SMART_TARGET_SIZE="5" ;;
        "4") SMART_TARGET_SIZE="10" ;;
        "5") SMART_TARGET_SIZE="none" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Target size set to: $SMART_TARGET_SIZE${NC}"
    sleep 1
}

# ðŸŽ¦ Configure Smart Framerate Mode
configure_smart_framerate_mode() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸŽ¬ FRAME RATE PREFERENCES${NC}\n"
    echo -e "Current: ${BOLD}${SMART_FRAMERATE_MODE:-ai}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} AI Decides (recommended) - Smart frame rate based on content"
    echo -e "${GREEN}[2]${NC} Preserve Source - Keep original frame rate when possible"
    echo -e "${GREEN}[3]${NC} Low (8-12 fps) - Static content, smaller files"
    echo -e "${GREEN}[4]${NC} Medium (12-18 fps) - Balanced approach"
    echo -e "${GREEN}[5]${NC} High (18-24 fps) - Smooth motion\n"
    
    echo -e "${MAGENTA}Select frame rate mode: ${NC}"
    read -r fps_choice
    case "$fps_choice" in
        "1") SMART_FRAMERATE_MODE="ai" ;;
        "2") SMART_FRAMERATE_MODE="preserve" ;;
        "3") SMART_FRAMERATE_MODE="low" ;;
        "4") SMART_FRAMERATE_MODE="medium" ;;
        "5") SMART_FRAMERATE_MODE="high" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Frame rate mode set to: $SMART_FRAMERATE_MODE${NC}"
    sleep 1
}

# ðŸ” Configure Smart Duplicate Detection
configure_smart_duplicate_detection() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸ” DUPLICATE DETECTION LEVEL${NC}\n"
    echo -e "Current: ${BOLD}${AI_DUPLICATE_DETECTION:-visual}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Basic - File name and size comparison (fast)"
    echo -e "${GREEN}[2]${NC} Visual - Perceptual hashing for visual similarity (recommended)"
    echo -e "${GREEN}[3]${NC} Advanced - Full content analysis (thorough but slower)\n"
    
    echo -e "${MAGENTA}Select detection level: ${NC}"
    read -r dup_choice
    case "$dup_choice" in
        "1") AI_DUPLICATE_DETECTION="basic" ;;
        "2") AI_DUPLICATE_DETECTION="visual" ;;
        "3") AI_DUPLICATE_DETECTION="advanced" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Duplicate detection set to: $AI_DUPLICATE_DETECTION${NC}"
    sleep 1
}

# âš¡ Configure Smart Parallel Jobs
configure_smart_parallel_jobs() {
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    clear
    print_header
    echo -e "${BLUE}${BOLD}âš¡ PARALLEL PROCESSING${NC}\n"
    echo -e "Current: ${BOLD}${SMART_PARALLEL_JOBS:-auto}${NC}"
    echo -e "System: $cpu_cores CPU cores available\n"
    
    echo -e "${GREEN}[1]${NC} Auto - Let system decide (recommended)"
    echo -e "${GREEN}[2]${NC} Low - 2 jobs (conservative, stable)"
    echo -e "${GREEN}[3]${NC} Medium - 4 jobs (balanced performance)"
    echo -e "${GREEN}[4]${NC} High - 8 jobs (aggressive, faster)"
    echo -e "${GREEN}[5]${NC} Maximum - Use all $cpu_cores cores\n"
    
    echo -e "${MAGENTA}Select parallel processing level: ${NC}"
    read -r parallel_choice
    case "$parallel_choice" in
        "1") SMART_PARALLEL_JOBS="auto" ;;
        "2") SMART_PARALLEL_JOBS="2" ;;
        "3") SMART_PARALLEL_JOBS="4" ;;
        "4") SMART_PARALLEL_JOBS="8" ;;
        "5") SMART_PARALLEL_JOBS="$cpu_cores" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Parallel jobs set to: $SMART_PARALLEL_JOBS${NC}"
    sleep 1
}

# ðŸš€ Configure Smart Optimization Level
configure_smart_optimization_level() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸš€ OPTIMIZATION LEVEL${NC}\n"
    echo -e "Current: ${BOLD}${SMART_OPTIMIZATION:-balanced}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Light - Fast processing, larger files"
    echo -e "${GREEN}[2]${NC} Balanced - Good balance of speed and size (recommended)"
    echo -e "${GREEN}[3]${NC} Aggressive - Smallest files, slower processing\n"
    
    echo -e "${MAGENTA}Select optimization level: ${NC}"
    read -r opt_choice
    case "$opt_choice" in
        "1") SMART_OPTIMIZATION="light" ;;
        "2") SMART_OPTIMIZATION="balanced" ;;
        "3") SMART_OPTIMIZATION="aggressive" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Optimization level set to: $SMART_OPTIMIZATION${NC}"
    sleep 1
}

# ðŸ·ï¸ Configure Smart Naming
configure_smart_naming() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸ·ï¸ FILE NAMING CONVENTION${NC}\n"
    echo -e "Current: ${BOLD}${SMART_NAMING:-ai}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} AI Suggests - Smart names based on content analysis"
    echo -e "${GREEN}[2]${NC} Original Names - Keep video file names"
    echo -e "${GREEN}[3]${NC} Timestamp - Add conversion timestamp"
    echo -e "${GREEN}[4]${NC} Quality Suffix - Add quality level to names\n"
    
    echo -e "${MAGENTA}Select naming convention: ${NC}"
    read -r naming_choice
    case "$naming_choice" in
        "1") SMART_NAMING="ai" ;;
        "2") SMART_NAMING="original" ;;
        "3") SMART_NAMING="timestamp" ;;
        "4") SMART_NAMING="quality" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Naming convention set to: $SMART_NAMING${NC}"
    sleep 1
}

# ðŸ’¾ Configure Smart Backup
configure_smart_backup() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}ðŸ’¾ BACKUP STRATEGY${NC}\n"
    echo -e "Current: ${BOLD}${SMART_BACKUP:-originals}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} None - No backups (fastest, use with caution)"
    echo -e "${GREEN}[2]${NC} Originals Only - Backup source videos (recommended)"
    echo -e "${GREEN}[3]${NC} With Metadata - Backup with AI analysis data\n"
    
    echo -e "${MAGENTA}Select backup strategy: ${NC}"
    read -r backup_choice
    case "$backup_choice" in
        "1") SMART_BACKUP="none" ;;
        "2") SMART_BACKUP="originals" ;;
        "3") SMART_BACKUP="metadata" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Backup strategy set to: $SMART_BACKUP${NC}"
    sleep 1
}

# âœ“ Configure Smart Validation
configure_smart_validation() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}âœ“ VALIDATION LEVEL${NC}\n"
    echo -e "Current: ${BOLD}${SMART_VALIDATION:-quick}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Skip - No validation (fastest, less reliable)"
    echo -e "${GREEN}[2]${NC} Quick Check - Basic file integrity (recommended)"
    echo -e "${GREEN}[3]${NC} Thorough - Full validation and quality check\n"
    
    echo -e "${MAGENTA}Select validation level: ${NC}"
    read -r validation_choice
    case "$validation_choice" in
        "1") SMART_VALIDATION="skip" ;;
        "2") SMART_VALIDATION="quick" ;;
        "3") SMART_VALIDATION="thorough" ;;
        *) return ;;
    esac
    echo -e "${GREEN}âœ“ Validation level set to: $SMART_VALIDATION${NC}"
    sleep 1
}

# ðŸ“‹ Show current smart AI configuration
show_smart_ai_config() {
    echo -e "${CYAN}${BOLD}ðŸŽ›ï¸ CURRENT SMART CONFIGURATION:${NC}"
    echo -e "${GRAY}System: $(nproc 2>/dev/null || echo '4') cores, $(free -h 2>/dev/null | awk '/^Mem:/ {print $2}' || echo 'unknown') RAM${NC}\n"
    
    # AI Features Section
    echo -e "${MAGENTA}${BOLD}ðŸ¤– AI FEATURES:${NC}"
    local ai_content_status=$([[ "$AI_CONTENT_DETECTION" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local ai_quality_status=$([[ "$AI_QUALITY_OPTIMIZATION" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local ai_motion_status=$([[ "$AI_MOTION_ANALYSIS" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local ai_duplicate_status=$([[ "$AI_DUPLICATE_DETECTION" == "advanced" ]] && echo "${GREEN}âœ“ Advanced${NC}" || echo "${YELLOW}Basic${NC}")
    
    echo -e "  Content Detection: $ai_content_status     Quality Optimization: $ai_quality_status"
    echo -e "  Motion Analysis: $ai_motion_status       Duplicate Detection: $ai_duplicate_status\n"
    
    # Quality Control Section
    echo -e "${YELLOW}${BOLD}ðŸŽ¯ QUALITY CONTROL:${NC}"
    local max_res_display=$([[ "$SMART_MAX_RESOLUTION" == "auto" ]] && echo "AI Decides" || echo "$SMART_MAX_RESOLUTION")
    local target_size_display=$([[ "$SMART_TARGET_SIZE" == "auto" ]] && echo "AI Optimized" || echo "${SMART_TARGET_SIZE}MB avg")
    local fps_display=$([[ "$SMART_FRAMERATE_MODE" == "ai" ]] && echo "AI Decides" || echo "$SMART_FRAMERATE_MODE")
    
    echo -e "  Preset: ${BOLD}$QUALITY${NC} (with AI adjustments)    Max Resolution: ${BOLD}$max_res_display${NC}"
    echo -e "  Target Size: ${BOLD}$target_size_display${NC}                Frame Rate: ${BOLD}$fps_display${NC}\n"
    
    # Processing Section
    echo -e "${BLUE}${BOLD}âš¡ PROCESSING:${NC}"
    local parallel_display=$([[ "$SMART_PARALLEL_JOBS" == "auto" ]] && echo "Auto ($(nproc 2>/dev/null || echo '4'))" || echo "$SMART_PARALLEL_JOBS jobs")
    local ai_per_file_status=$([[ "$SMART_AI_PER_FILE" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local optimization_level_display=$([[ "$SMART_OPTIMIZATION" == "balanced" ]] && echo "Balanced" || echo "$SMART_OPTIMIZATION")
    
    echo -e "  Parallel Jobs: ${BOLD}$parallel_display${NC}              AI Per-File: $ai_per_file_status"
    echo -e "  Optimization: ${BOLD}$optimization_level_display${NC}                Progress: ${BOLD}Detailed${NC}\n"
    
    # Output Section
    echo -e "${GREEN}${BOLD}ðŸ“ OUTPUT:${NC}"
    local naming_display=$([[ "$SMART_NAMING" == "ai" ]] && echo "AI Suggests" || echo "$SMART_NAMING")
    local backup_display=$([[ "$SMART_BACKUP" == "originals" ]] && echo "Originals Only" || echo "$SMART_BACKUP")
    local validation_display=$([[ "$SMART_VALIDATION" == "quick" ]] && echo "Quick Check" || echo "$SMART_VALIDATION")
    
    echo -e "  Naming: ${BOLD}$naming_display${NC}                  Backup: ${BOLD}$backup_display${NC}"
    echo -e "  Validation: ${BOLD}$validation_display${NC}"
}

# ðŸŽ¯ Configure smart quality settings
configure_smart_quality() {
    clear
    print_header
    echo -e "${YELLOW}${BOLD}ðŸŽ¯ QUALITY & RESOLUTION SETTINGS${NC}\n"
    
    echo -e "${CYAN}Current Settings:${NC}"
    echo -e "  Quality Preset: ${BOLD}$QUALITY${NC} (with AI adjustments)"
    echo -e "  Max Resolution: ${BOLD}${SMART_MAX_RESOLUTION:-auto}${NC}"
    echo -e "  Target Size: ${BOLD}${SMART_TARGET_SIZE:-auto}${NC}"
    echo -e "  Frame Rate: ${BOLD}${SMART_FRAMERATE_MODE:-ai}${NC}\n"
    
    echo -e "${GREEN}[1]${NC} Change Quality Preset: ${BOLD}$QUALITY${NC}"
    echo -e "${GREEN}[2]${NC} Set Maximum Resolution Limit"
    echo -e "${GREEN}[3]${NC} Configure Target File Size"
    echo -e "${GREEN}[4]${NC} Frame Rate Preferences"
    echo -e "${GREEN}[0]${NC} Back to Smart Configuration\n"
    
    echo -e "${MAGENTA}Select option: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            select_quality_preset
            ;;
        "2")
            echo -e "\n${BLUE}Maximum Resolution Limit:${NC}"
            echo -e "${GREEN}[1]${NC} Auto (AI decides based on source)"
            echo -e "${GREEN}[2]${NC} 480p (854x480)"
            echo -e "${GREEN}[3]${NC} 720p (1280x720)"
            echo -e "${GREEN}[4]${NC} 1080p (1920x1080)"
            echo -e "${GREEN}[5]${NC} 1440p (2560x1440)"
            echo -e "${GREEN}[6]${NC} 4K (3840x2160)\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r res_choice
            case "$res_choice" in
                "1") SMART_MAX_RESOLUTION="auto" ;;
                "2") SMART_MAX_RESOLUTION="480p" ;;
                "3") SMART_MAX_RESOLUTION="720p" ;;
                "4") SMART_MAX_RESOLUTION="1080p" ;;
                "5") SMART_MAX_RESOLUTION="1440p" ;;
                "6") SMART_MAX_RESOLUTION="4K" ;;
            esac
            echo -e "${GREEN}âœ“ Max resolution set to: $SMART_MAX_RESOLUTION${NC}"
            sleep 1
            ;;
        "3")
            echo -e "\n${BLUE}Target File Size (average per GIF):${NC}"
            echo -e "${GREEN}[1]${NC} Auto (AI optimized for quality/size balance)"
            echo -e "${GREEN}[2]${NC} Small (1MB average)"
            echo -e "${GREEN}[3]${NC} Medium (5MB average)"
            echo -e "${GREEN}[4]${NC} Large (10MB average)"
            echo -e "${GREEN}[5]${NC} No limit (quality focused)\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r size_choice
            case "$size_choice" in
                "1") SMART_TARGET_SIZE="auto" ;;
                "2") SMART_TARGET_SIZE="1" ;;
                "3") SMART_TARGET_SIZE="5" ;;
                "4") SMART_TARGET_SIZE="10" ;;
                "5") SMART_TARGET_SIZE="none" ;;
            esac
            echo -e "${GREEN}âœ“ Target size set to: $SMART_TARGET_SIZE${NC}"
            sleep 1
            ;;
        "4")
            echo -e "\n${BLUE}Frame Rate Preferences:${NC}"
            echo -e "${GREEN}[1]${NC} AI Decides (recommended) - Smart frame rate based on content"
            echo -e "${GREEN}[2]${NC} Preserve Source - Keep original frame rate when possible"
            echo -e "${GREEN}[3]${NC} Low (8-12 fps) - For static content and small files"
            echo -e "${GREEN}[4]${NC} Medium (12-18 fps) - Balanced approach"
            echo -e "${GREEN}[5]${NC} High (18-24 fps) - Smooth motion\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r fps_choice
            case "$fps_choice" in
                "1") SMART_FRAMERATE_MODE="ai" ;;
                "2") SMART_FRAMERATE_MODE="preserve" ;;
                "3") SMART_FRAMERATE_MODE="low" ;;
                "4") SMART_FRAMERATE_MODE="medium" ;;
                "5") SMART_FRAMERATE_MODE="high" ;;
            esac
            echo -e "${GREEN}âœ“ Frame rate mode set to: $SMART_FRAMERATE_MODE${NC}"
            sleep 1
            ;;
        "0"|"")
            return
            ;;
    esac
}

# ðŸ¤– Configure smart AI features
configure_smart_ai_features() {
    clear
    print_header
    echo -e "${MAGENTA}${BOLD}ðŸ¤– AI FEATURE SELECTION${NC}\n"
    
    echo -e "${CYAN}Choose which AI features to enable:${NC}\n"
    
    local content_status=$([[ "${AI_CONTENT_DETECTION:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local quality_status=$([[ "${AI_QUALITY_OPTIMIZATION:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local motion_status=$([[ "${AI_MOTION_ANALYSIS:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local duplicate_status="${AI_DUPLICATE_DETECTION:-basic}"
    
    echo -e "${GREEN}[1]${NC} Content Detection: $content_status"
    echo -e "    ${GRAY}Automatically detects animation, screencast, movie, or clip content${NC}"
    echo -e "${GREEN}[2]${NC} Quality Optimization: $quality_status"
    echo -e "    ${GRAY}AI adjusts quality parameters based on source characteristics${NC}"
    echo -e "${GREEN}[3]${NC} Motion Analysis: $motion_status"
    echo -e "    ${GRAY}Intelligent frame rate adjustments based on movement patterns${NC}"
    echo -e "${GREEN}[4]${NC} Duplicate Detection: ${BOLD}$duplicate_status${NC}"
    echo -e "    ${GRAY}Choose level of duplicate detection (basic/visual/advanced)${NC}\n"
    
    echo -e "${GREEN}[0]${NC} Back to Smart Configuration\n"
    
    echo -e "${MAGENTA}Select option: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            AI_CONTENT_DETECTION=$([[ "${AI_CONTENT_DETECTION:-true}" == "true" ]] && echo "false" || echo "true")
            local new_status=$([[ "$AI_CONTENT_DETECTION" == "true" ]] && echo "enabled" || echo "disabled")
            echo -e "\n${GREEN}âœ“ Content Detection $new_status${NC}"
            sleep 1
            configure_smart_ai_features
            ;;
        "2")
            AI_QUALITY_OPTIMIZATION=$([[ "${AI_QUALITY_OPTIMIZATION:-true}" == "true" ]] && echo "false" || echo "true")
            local new_status=$([[ "$AI_QUALITY_OPTIMIZATION" == "true" ]] && echo "enabled" || echo "disabled")
            echo -e "\n${GREEN}âœ“ Quality Optimization $new_status${NC}"
            sleep 1
            configure_smart_ai_features
            ;;
        "3")
            AI_MOTION_ANALYSIS=$([[ "${AI_MOTION_ANALYSIS:-true}" == "true" ]] && echo "false" || echo "true")
            local new_status=$([[ "$AI_MOTION_ANALYSIS" == "true" ]] && echo "enabled" || echo "disabled")
            echo -e "\n${GREEN}âœ“ Motion Analysis $new_status${NC}"
            sleep 1
            configure_smart_ai_features
            ;;
        "4")
            echo -e "\n${BLUE}Duplicate Detection Level:${NC}"
            echo -e "${GREEN}[1]${NC} Basic - File name and size comparison (fast)"
            echo -e "${GREEN}[2]${NC} Visual - Perceptual hashing for visual similarity (recommended)"
            echo -e "${GREEN}[3]${NC} Advanced - Full content analysis (thorough but slower)\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r dup_choice
            case "$dup_choice" in
                "1") AI_DUPLICATE_DETECTION="basic" ;;
                "2") AI_DUPLICATE_DETECTION="visual" ;;
                "3") AI_DUPLICATE_DETECTION="advanced" ;;
            esac
            echo -e "${GREEN}âœ“ Duplicate detection set to: $AI_DUPLICATE_DETECTION${NC}"
            sleep 1
            configure_smart_ai_features
            ;;
        "0"|"")
            return
            ;;
    esac
}

# âš¡ Configure smart performance settings
configure_smart_performance() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}âš¡ PERFORMANCE & PROCESSING${NC}\n"
    
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    echo -e "${CYAN}System: $cpu_cores CPU cores detected${NC}\n"
    
    local parallel_display=$([[ "${SMART_PARALLEL_JOBS:-auto}" == "auto" ]] && echo "Auto ($cpu_cores)" || echo "$SMART_PARALLEL_JOBS jobs")
    local per_file_status=$([[ "${SMART_AI_PER_FILE:-true}" == "true" ]] && echo "${GREEN}âœ“ ON${NC}" || echo "${RED}âœ— OFF${NC}")
    local optimization_display="${SMART_OPTIMIZATION:-balanced}"
    
    echo -e "${GREEN}[1]${NC} Parallel Processing: ${BOLD}$parallel_display${NC}"
    echo -e "    ${GRAY}Number of videos to process simultaneously${NC}"
    echo -e "${GREEN}[2]${NC} AI Per-File Decisions: $per_file_status"
    echo -e "    ${GRAY}Let AI choose different settings for each video${NC}"
    echo -e "${GREEN}[3]${NC} Optimization Level: ${BOLD}$optimization_display${NC}"
    echo -e "    ${GRAY}Balance between speed and file size${NC}\n"
    
    echo -e "${GREEN}[0]${NC} Back to Smart Configuration\n"
    
    echo -e "${MAGENTA}Select option: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            echo -e "\n${BLUE}Parallel Processing:${NC}"
            echo -e "${GREEN}[1]${NC} Auto - Let system decide (recommended)"
            echo -e "${GREEN}[2]${NC} Low - 2 jobs (conservative)"
            echo -e "${GREEN}[3]${NC} Medium - 4 jobs (balanced)"
            echo -e "${GREEN}[4]${NC} High - 8 jobs (aggressive)"
            echo -e "${GREEN}[5]${NC} Maximum - Use all $cpu_cores cores\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r parallel_choice
            case "$parallel_choice" in
                "1") SMART_PARALLEL_JOBS="auto" ;;
                "2") SMART_PARALLEL_JOBS="2" ;;
                "3") SMART_PARALLEL_JOBS="4" ;;
                "4") SMART_PARALLEL_JOBS="8" ;;
                "5") SMART_PARALLEL_JOBS="$cpu_cores" ;;
            esac
            echo -e "${GREEN}âœ“ Parallel jobs set to: $SMART_PARALLEL_JOBS${NC}"
            sleep 1
            configure_smart_performance
            ;;
        "2")
            SMART_AI_PER_FILE=$([[ "${SMART_AI_PER_FILE:-true}" == "true" ]] && echo "false" || echo "true")
            local new_status=$([[ "$SMART_AI_PER_FILE" == "true" ]] && echo "enabled" || echo "disabled")
            echo -e "\n${GREEN}âœ“ AI per-file decisions $new_status${NC}"
            sleep 1
            configure_smart_performance
            ;;
        "3")
            echo -e "\n${BLUE}Optimization Level:${NC}"
            echo -e "${GREEN}[1]${NC} Light - Fast processing, larger files"
            echo -e "${GREEN}[2]${NC} Balanced - Good balance (recommended)"
            echo -e "${GREEN}[3]${NC} Aggressive - Smallest files, slower processing\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r opt_choice
            case "$opt_choice" in
                "1") SMART_OPTIMIZATION="light" ;;
                "2") SMART_OPTIMIZATION="balanced" ;;
                "3") SMART_OPTIMIZATION="aggressive" ;;
            esac
            echo -e "${GREEN}âœ“ Optimization level set to: $SMART_OPTIMIZATION${NC}"
            sleep 1
            configure_smart_performance
            ;;
        "0"|"")
            return
            ;;
    esac
}

# ðŸ“ Configure smart output settings
configure_smart_output() {
    clear
    print_header
    echo -e "${GREEN}${BOLD}ðŸ“ OUTPUT & FILE MANAGEMENT${NC}\n"
    
    local naming_display="${SMART_NAMING:-ai}"
    local backup_display="${SMART_BACKUP:-originals}"
    local validation_display="${SMART_VALIDATION:-quick}"
    
    echo -e "${GREEN}[1]${NC} File Naming: ${BOLD}$naming_display${NC}"
    echo -e "    ${GRAY}How to name output GIF files${NC}"
    echo -e "${GREEN}[2]${NC} Backup Strategy: ${BOLD}$backup_display${NC}"
    echo -e "    ${GRAY}What to backup before conversion${NC}"
    echo -e "${GREEN}[3]${NC} Validation Level: ${BOLD}$validation_display${NC}"
    echo -e "    ${GRAY}How thoroughly to check output files${NC}\n"
    
    echo -e "${GREEN}[0]${NC} Back to Smart Configuration\n"
    
    echo -e "${MAGENTA}Select option: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            echo -e "\n${BLUE}File Naming Convention:${NC}"
            echo -e "${GREEN}[1]${NC} AI Suggests - Smart names based on content"
            echo -e "${GREEN}[2]${NC} Original Names - Keep video file names"
            echo -e "${GREEN}[3]${NC} Timestamp - Add conversion timestamp"
            echo -e "${GREEN}[4]${NC} Quality Suffix - Add quality level to names\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r naming_choice
            case "$naming_choice" in
                "1") SMART_NAMING="ai" ;;
                "2") SMART_NAMING="original" ;;
                "3") SMART_NAMING="timestamp" ;;
                "4") SMART_NAMING="quality" ;;
            esac
            echo -e "${GREEN}âœ“ Naming convention set to: $SMART_NAMING${NC}"
            sleep 1
            configure_smart_output
            ;;
        "2")
            echo -e "\n${BLUE}Backup Strategy:${NC}"
            echo -e "${GREEN}[1]${NC} None - No backups (fastest)"
            echo -e "${GREEN}[2]${NC} Originals Only - Backup source videos"
            echo -e "${GREEN}[3]${NC} With Metadata - Backup with AI analysis data\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r backup_choice
            case "$backup_choice" in
                "1") SMART_BACKUP="none" ;;
                "2") SMART_BACKUP="originals" ;;
                "3") SMART_BACKUP="metadata" ;;
            esac
            echo -e "${GREEN}âœ“ Backup strategy set to: $SMART_BACKUP${NC}"
            sleep 1
            configure_smart_output
            ;;
        "3")
            echo -e "\n${BLUE}Validation Level:${NC}"
            echo -e "${GREEN}[1]${NC} Skip - No validation (fastest)"
            echo -e "${GREEN}[2]${NC} Quick Check - Basic file integrity"
            echo -e "${GREEN}[3]${NC} Thorough - Full validation and quality check\n"
            echo -e "${MAGENTA}Select: ${NC}"
            read -r validation_choice
            case "$validation_choice" in
                "1") SMART_VALIDATION="skip" ;;
                "2") SMART_VALIDATION="quick" ;;
                "3") SMART_VALIDATION="thorough" ;;
            esac
            echo -e "${GREEN}âœ“ Validation level set to: $SMART_VALIDATION${NC}"
            sleep 1
            configure_smart_output
            ;;
        "0"|"")
            return
            ;;
    esac
}

# ðŸ”„ Reset to smart defaults
reset_to_smart_defaults() {
    # AI Features
    AI_CONTENT_DETECTION="true"
    AI_QUALITY_OPTIMIZATION="true"
    AI_MOTION_ANALYSIS="true"
    AI_DUPLICATE_DETECTION="visual"
    
    # Quality Control
    QUALITY="high"  # Start with high quality
    SMART_MAX_RESOLUTION="auto"
    SMART_TARGET_SIZE="auto"
    SMART_FRAMERATE_MODE="ai"
    
    # Processing
    SMART_PARALLEL_JOBS="auto"
    SMART_AI_PER_FILE="true"
    SMART_OPTIMIZATION="balanced"
    
    # Output
    SMART_NAMING="ai"
    SMART_BACKUP="originals"
    SMART_VALIDATION="quick"
    
    # Core AI settings
    AI_ENABLED="true"
    AI_MODE="smart"
    AUTO_OPTIMIZE="true"
    PARALLEL_JOBS="auto"
    PROGRESS_BAR="true"
}

# Initialize smart defaults if not set
if [[ -z "$SMART_MAX_RESOLUTION" ]]; then
    reset_to_smart_defaults
fi

# ðŸ“‹ Show comprehensive advanced settings menu
show_advanced_settings_menu() {
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    local total_ram=$(free -h 2>/dev/null | awk '/^Mem:/ {print $2}' || echo "unknown")
    
    echo -e "${CYAN}${BOLD}ðŸ”§ COMPREHENSIVE SETTINGS CONFIGURATION:${NC}"
    echo -e "${GRAY}System: ${cpu_cores} cores, ${total_ram} RAM${NC}"
    echo -e "${YELLOW}ðŸ’¡ Tip: Press a number to toggle/configure that option${NC}\n"
    
    # Basic Options (1-5)
    echo -e "${BLUE}${BOLD}ðŸ”§ BASIC OPTIONS:${NC}"
    echo -e "  ${GREEN}[1]${NC} Force re-conversion: $(get_status_icon "$FORCE_CONVERSION")"
    echo -e "  ${GREEN}[2]${NC} Backup originals: $(get_status_icon "$BACKUP_ORIGINAL")"
    echo -e "  ${GREEN}[3]${NC} Auto-optimization: $(get_status_icon "$AUTO_OPTIMIZE")"
    echo -e "  ${GREEN}[4]${NC} Debug mode: $(get_status_icon "$DEBUG_MODE")"
    echo -e "  ${GREEN}[5]${NC} AI smart analysis: $(get_status_icon "$AI_ENABLED")\n"
    
    # AI & Performance Options (6-11)
    echo -e "${MAGENTA}${BOLD}ðŸ¤– AI & PERFORMANCE:${NC}"
    echo -e "  ${GREEN}[6]${NC} AI Mode: ${BOLD}${AI_MODE:-smart}${NC} (smart/content/motion/quality)"
    echo -e "  ${GREEN}[7]${NC} Content Type Preference: ${BOLD}${CONTENT_TYPE_PREFERENCE}${NC}"
    echo -e "  ${GREEN}[8]${NC} FFmpeg Threads: ${BOLD}${FFMPEG_THREADS}${NC}"
    echo -e "  ${GREEN}[9]${NC} Parallel Jobs: ${BOLD}${PARALLEL_JOBS}${NC}"
    echo -e "  ${GREEN}[10]${NC} GPU Acceleration: ${BOLD}${GPU_ACCELERATION}${NC}"
    echo -e "  ${GREEN}[11]${NC} Memory Settings: ${BOLD}${RAM_CACHE_SIZE:-auto}${NC}\n"
    
    # Quality & Compression (12-13)
    echo -e "${YELLOW}${BOLD}ðŸŽ¨ QUALITY & COMPRESSION:${NC}"
    echo -e "  ${GREEN}[12]${NC} Quality Preset: ${BOLD}${QUALITY}${NC} | Colors: ${BOLD}${MAX_COLORS}${NC} | Dither: ${BOLD}${DITHER_MODE}${NC}"
    echo -e "  ${GREEN}[13]${NC} Compression: ${BOLD}${COMPRESSION_LEVEL}${NC} | Max Size: ${BOLD}${MAX_GIF_SIZE_MB}MB${NC}\n"
    
    # System & Validation (14-16)
    echo -e "${CYAN}${BOLD}âš™ï¸ SYSTEM & VALIDATION:${NC}"
    echo -e "  ${GREEN}[14]${NC} Interactive Mode: $(get_status_icon "$INTERACTIVE_MODE")"
    echo -e "  ${GREEN}[15]${NC} Skip Validation: $(get_status_icon "$SKIP_VALIDATION")"
    echo -e "  ${GREEN}[16]${NC} Log Level: ${BOLD}${LOG_LEVEL}${NC} | Progress Bar: $(get_status_icon "$PROGRESS_BAR")\n"
    
    echo -e "${GRAY}[c] Custom FFmpeg Settings | [Enter] Start Conversion${NC}\n"
}

# ðŸ“¦ Get status icon for boolean values
get_status_icon() {
    if [[ "$1" == "true" ]]; then
        echo -e "${GREEN}${BOLD}âœ“ ON${NC}"
    else
        echo -e "${RED}âœ— OFF${NC}"
    fi
}

# ðŸ¤– Enhanced AI Configuration Menu
configure_ai_mode() {
    echo -e "\n${BLUE}${BOLD}ðŸ§  ADVANCED AI CONFIGURATION${NC}"
    echo -e "${CYAN}Current Mode: ${BOLD}${AI_MODE:-smart}${NC}\n"
    
    echo -e "${YELLOW}${BOLD}ðŸŽ¯ ANALYSIS MODES:${NC}"
    echo -e "  ${GREEN}[1]${NC} ðŸ§  Smart Mode (recommended) - Full AI analysis with all features"
    echo -e "  ${GREEN}[2]${NC} ðŸŽ¨ Content Mode - Focus on content type detection"
    echo -e "  ${GREEN}[3]${NC} ðŸ’ª Motion Mode - Focus on motion analysis and frame rate optimization"
    echo -e "  ${GREEN}[4]${NC} ðŸ’Ž Quality Mode - Focus on quality optimization and scaling\n"
    
    echo -e "${MAGENTA}${BOLD}ðŸ”§ ADVANCED FEATURES:${NC}"
    echo -e "  ${GREEN}[5]${NC} ðŸŽ¬ Scene Analysis: $(get_status_icon "$AI_SCENE_ANALYSIS")"
    echo -e "  ${GREEN}[6]${NC} ðŸ‘€ Visual Similarity: $(get_status_icon "$AI_VISUAL_SIMILARITY")"
    echo -e "  ${GREEN}[7]${NC} âœ‚ï¸ Smart Crop: $(get_status_icon "$AI_SMART_CROP")"
    echo -e "  ${GREEN}[8]${NC} ðŸ“Š Dynamic Frame Rate: $(get_status_icon "$AI_DYNAMIC_FRAMERATE")"
    echo -e "  ${GREEN}[9]${NC} ðŸŽ¨ Quality Scaling: $(get_status_icon "$AI_QUALITY_SCALING")\n"
    
    echo -e "${CYAN}${BOLD}ðŸ¤– AI AUTO FEATURES:${NC}"
    echo -e "  ${GREEN}[10]${NC} ðŸŽ¯ Auto Quality: $(get_status_icon "$AI_AUTO_QUALITY")"
    echo -e "  ${GREEN}[11]${NC} ðŸ” Content Fingerprint: $(get_status_icon "$AI_CONTENT_FINGERPRINT")"
    echo -e "  ${GREEN}[12]${NC} ðŸ” Video Discovery: $(get_status_icon "$AI_DISCOVERY_ENABLED") (Mode: $AI_DISCOVERY_AUTO_SELECT)\n"
    
    echo -en "${MAGENTA}Select option [1-12] or Enter to finish: ${NC}"
    read -r ai_choice
    
    case "$ai_choice" in
        "1") 
            AI_MODE="smart"
            echo -e "${GREEN}âœ“ AI Mode set to Smart (Full Analysis)${NC}"
            ;;
        "2") 
            AI_MODE="content"
            echo -e "${GREEN}âœ“ AI Mode set to Content Focus${NC}"
            ;;
        "3") 
            AI_MODE="motion"
            echo -e "${GREEN}âœ“ AI Mode set to Motion Focus${NC}"
            ;;
        "4") 
            AI_MODE="quality"
            echo -e "${GREEN}âœ“ AI Mode set to Quality Focus${NC}"
            ;;
        "5") 
            AI_SCENE_ANALYSIS=$([[ "$AI_SCENE_ANALYSIS" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Scene Analysis $(get_status_text "$AI_SCENE_ANALYSIS")${NC}"
            ;;
        "6") 
            AI_VISUAL_SIMILARITY=$([[ "$AI_VISUAL_SIMILARITY" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Visual Similarity $(get_status_text "$AI_VISUAL_SIMILARITY")${NC}"
            ;;
        "7") 
            AI_SMART_CROP=$([[ "$AI_SMART_CROP" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Smart Crop $(get_status_text "$AI_SMART_CROP")${NC}"
            ;;
        "8") 
            AI_DYNAMIC_FRAMERATE=$([[ "$AI_DYNAMIC_FRAMERATE" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Dynamic Frame Rate $(get_status_text "$AI_DYNAMIC_FRAMERATE")${NC}"
            ;;
        "9") 
            AI_QUALITY_SCALING=$([[ "$AI_QUALITY_SCALING" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Quality Scaling $(get_status_text "$AI_QUALITY_SCALING")${NC}"
            ;;
        "10") 
            AI_AUTO_QUALITY=$([[ "$AI_AUTO_QUALITY" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Auto Quality $(get_status_text "$AI_AUTO_QUALITY")${NC}"
            ;;
        "11") 
            AI_CONTENT_FINGERPRINT=$([[ "$AI_CONTENT_FINGERPRINT" == "true" ]] && echo "false" || echo "true")
            echo -e "${GREEN}âœ“ Content Fingerprint $(get_status_text "$AI_CONTENT_FINGERPRINT")${NC}"
            ;;
        "") 
            echo -e "${CYAN}AI configuration complete${NC}"
            ;;
        *) 
            echo -e "${YELLOW}No change made${NC}"
            ;;
    esac
    
    [[ -n "$ai_choice" && "$ai_choice" != "" ]] && sleep 1 && configure_ai_mode
}

# ðŸ’¬ Helper function for status text
get_status_text() {
    if [[ "$1" == "true" ]]; then
        echo "enabled"
    else
        echo "disabled"
    fi
}

# ðŸŽ¬ Configure Content Type Preference
configure_content_type_preference() {
    echo -e "\n${BLUE}${BOLD}ðŸŽ¬ CONTENT TYPE PREFERENCE CONFIGURATION${NC}"
    echo -e "${CYAN}Current Setting: ${BOLD}${CONTENT_TYPE_PREFERENCE}${NC}\n"
    
    echo -e "${YELLOW}${BOLD}ðŸŽ¬ SELECT YOUR TYPICAL CONTENT:${NC}"
    echo -e "${GRAY}This helps optimize default settings for your content type${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} ðŸŽ¨ Animation (Anime/Cartoons)"
    echo -e "      ${GRAY}â€¢ Optimized for: Sharp edges, solid colors, high contrast${NC}"
    echo -e "      ${GRAY}â€¢ Settings: High quality, Floyd-Steinberg dither, 128 colors${NC}"
    echo -e "      ${GRAY}â€¢ Best for: Anime, cartoons, 2D animations${NC}\n"
    
    echo -e "  ${GREEN}[2]${NC} ðŸŽ¬ Movie (Live Action/Real Video)"
    echo -e "      ${GRAY}â€¢ Optimized for: Natural motion, complex scenes, gradients${NC}"
    echo -e "      ${GRAY}â€¢ Settings: Medium quality, Bayer dither, 256 colors${NC}"
    echo -e "      ${GRAY}â€¢ Best for: Movies, TV shows, real-world footage${NC}\n"
    
    echo -e "  ${GREEN}[3]${NC} ðŸ’» Screencast (Screen Recordings/Tutorials)"
    echo -e "      ${GRAY}â€¢ Optimized for: Text clarity, UI elements, minimal motion${NC}"
    echo -e "      ${GRAY}â€¢ Settings: High quality, no dither, 64 colors, 10fps${NC}"
    echo -e "      ${GRAY}â€¢ Best for: Tutorials, gameplay, software demos${NC}\n"
    
    echo -e "  ${GREEN}[4]${NC} ðŸ§  Mixed Content (AI Auto-Detect) ${BOLD}[Recommended]${NC}"
    echo -e "      ${GRAY}â€¢ Optimized for: Automatic detection per video${NC}"
    echo -e "      ${GRAY}â€¢ Settings: Smart AI analysis with learning${NC}"
    echo -e "      ${GRAY}â€¢ Best for: Varied content types, batch processing${NC}"
    echo -e "      ${CYAN}â€¢ Enables: Full AI system with caching and training${NC}\n"
    
    echo -en "${MAGENTA}Select content type [1-4] or Enter to keep current: ${NC}"
    read -r content_choice
    
    case "$content_choice" in
        "1") 
            CONTENT_TYPE_PREFERENCE="animation"
            QUALITY="high"
            MAX_COLORS="128"
            DITHER_MODE="floyd_steinberg"
            AI_MODE="content"
            echo -e "${GREEN}âœ“ Content type set to Animation${NC}"
            echo -e "${CYAN}â€¢ Quality: high | Colors: 128 | Dither: floyd_steinberg${NC}"
            ;;
        "2") 
            CONTENT_TYPE_PREFERENCE="movie"
            QUALITY="medium"
            MAX_COLORS="256"
            DITHER_MODE="bayer"
            AI_MODE="motion"
            echo -e "${GREEN}âœ“ Content type set to Movie${NC}"
            echo -e "${CYAN}â€¢ Quality: medium | Colors: 256 | Dither: bayer${NC}"
            ;;
        "3") 
            CONTENT_TYPE_PREFERENCE="screencast"
            QUALITY="high"
            MAX_COLORS="64"
            DITHER_MODE="none"
            FRAMERATE="10"
            AI_MODE="quality"
            echo -e "${GREEN}âœ“ Content type set to Screencast${NC}"
            echo -e "${CYAN}â€¢ Quality: high | Colors: 64 | Dither: none | FPS: 10${NC}"
            ;;
        "4") 
            CONTENT_TYPE_PREFERENCE="mixed"
            AI_ENABLED=true
            AI_MODE="smart"
            AI_AUTO_QUALITY=true
            AI_SCENE_ANALYSIS=true
            AI_VISUAL_SIMILARITY=true
            AI_SMART_CROP=true
            AI_DYNAMIC_FRAMERATE=true
            AI_QUALITY_SCALING=true
            AI_CONTENT_FINGERPRINT=true
            AI_CACHE_ENABLED=true
            AI_TRAINING_ENABLED=true
            echo -e "${GREEN}âœ“ Content type set to Mixed (AI Auto-Detect)${NC}"
            echo -e "${CYAN}â€¢ Full AI system activated with learning enabled${NC}"
            echo -e "${CYAN}â€¢ AI will analyze and optimize each video automatically${NC}"
            ;;
        "") 
            echo -e "${CYAN}No change - keeping current setting: ${BOLD}${CONTENT_TYPE_PREFERENCE}${NC}"
            ;;
        *) 
            echo -e "${YELLOW}Invalid selection - no change made${NC}"
            ;;
    esac
    
    # Save settings after change
    if [[ -n "$content_choice" && "$content_choice" != "" ]]; then
        save_settings >/dev/null 2>&1
        sleep 1
    fi
}

# ðŸ’» Configure Threading
configure_threads() {
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    echo -e "\n${BLUE}${BOLD}ðŸ’» THREADING CONFIGURATION:${NC}"
    echo -e "${CYAN}System has ${BOLD}${cpu_cores}${NC}${CYAN} CPU cores available${NC}"
    echo -e "${CYAN}Current: ${BOLD}${FFMPEG_THREADS}${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Auto (recommended)"
    echo -e "  ${GREEN}[2]${NC} All cores (${cpu_cores} threads)"
    echo -e "  ${GREEN}[3]${NC} Half cores ($((cpu_cores / 2)) threads)"
    echo -e "  ${GREEN}[4]${NC} Conservative (2 threads)"
    echo -e "  ${GREEN}[5]${NC} Custom number\n"
    
    echo -en "${MAGENTA}Select threading option [1-5]: ${NC}"
    read -r thread_choice
    
    case "$thread_choice" in
        "1") FFMPEG_THREADS="auto"; echo -e "${GREEN}âœ“ Threads set to Auto${NC}" ;;
        "2") FFMPEG_THREADS="$cpu_cores"; echo -e "${GREEN}âœ“ Threads set to ${cpu_cores}${NC}" ;;
        "3") FFMPEG_THREADS="$((cpu_cores / 2))"; echo -e "${GREEN}âœ“ Threads set to $((cpu_cores / 2))${NC}" ;;
        "4") FFMPEG_THREADS="2"; echo -e "${GREEN}âœ“ Threads set to 2${NC}" ;;
        "5") 
            echo -en "${MAGENTA}Enter custom thread count (1-${cpu_cores}): ${NC}"
            read -r custom_threads
            if [[ "$custom_threads" =~ ^[0-9]+$ ]] && [[ $custom_threads -ge 1 && $custom_threads -le $cpu_cores ]]; then
                FFMPEG_THREADS="$custom_threads"
                echo -e "${GREEN}âœ“ Threads set to ${custom_threads}${NC}"
            else
                echo -e "${RED}âœ— Invalid input. No change made.${NC}"
            fi
            ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ”„ Configure Parallel Jobs
configure_parallel_jobs() {
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    echo -e "\n${BLUE}${BOLD}ðŸ”„ PARALLEL PROCESSING CONFIGURATION:${NC}"
    echo -e "${CYAN}Current: ${BOLD}${PARALLEL_JOBS}${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Auto (recommended)"
    echo -e "  ${GREEN}[2]${NC} Maximum (${cpu_cores} jobs)"
    echo -e "  ${GREEN}[3]${NC} Conservative (2 jobs)"
    echo -e "  ${GREEN}[4]${NC} Sequential (1 job)"
    echo -e "  ${GREEN}[5]${NC} Custom number\n"
    
    echo -en "${MAGENTA}Select parallel jobs [1-5]: ${NC}"
    read -r parallel_choice
    
    case "$parallel_choice" in
        "1") PARALLEL_JOBS="auto"; echo -e "${GREEN}âœ“ Parallel jobs set to Auto${NC}" ;;
        "2") PARALLEL_JOBS="$cpu_cores"; echo -e "${GREEN}âœ“ Parallel jobs set to ${cpu_cores}${NC}" ;;
        "3") PARALLEL_JOBS="2"; echo -e "${GREEN}âœ“ Parallel jobs set to 2${NC}" ;;
        "4") PARALLEL_JOBS="1"; echo -e "${GREEN}âœ“ Parallel jobs set to 1 (sequential)${NC}" ;;
        "5") 
            echo -en "${MAGENTA}Enter custom job count (1-${cpu_cores}): ${NC}"
            read -r custom_jobs
            if [[ "$custom_jobs" =~ ^[0-9]+$ ]] && [[ $custom_jobs -ge 1 && $custom_jobs -le $cpu_cores ]]; then
                PARALLEL_JOBS="$custom_jobs"
                echo -e "${GREEN}âœ“ Parallel jobs set to ${custom_jobs}${NC}"
            else
                echo -e "${RED}âœ— Invalid input. No change made.${NC}"
            fi
            ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ’ª Configure Memory Settings
configure_memory_settings() {
    local total_ram=$(free -m 2>/dev/null | awk '/^Mem:/ {print $2}' || echo "4096")
    echo -e "\n${BLUE}${BOLD}ðŸ’ª MEMORY OPTIMIZATION:${NC}"
    echo -e "${CYAN}System RAM: ${BOLD}$((total_ram / 1024))GB${NC}${CYAN} (${total_ram}MB)${NC}"
    echo -e "${CYAN}Current cache size: ${BOLD}${RAM_CACHE_SIZE:-auto}${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Auto (recommended)"
    echo -e "  ${GREEN}[2]${NC} Conservative (512MB)"
    echo -e "  ${GREEN}[3]${NC} Moderate (1GB)"
    echo -e "  ${GREEN}[4]${NC} Aggressive (2GB)"
    echo -e "  ${GREEN}[5]${NC} Maximum (4GB)"
    echo -e "  ${GREEN}[6]${NC} Enable RAM disk: $(get_status_icon "$RAM_DISK_ENABLED")\n"
    
    echo -en "${MAGENTA}Select memory option [1-6]: ${NC}"
    read -r memory_choice
    
    case "$memory_choice" in
        "1") RAM_CACHE_SIZE="auto"; echo -e "${GREEN}âœ“ Memory cache set to Auto${NC}" ;;
        "2") RAM_CACHE_SIZE="512m"; echo -e "${GREEN}âœ“ Memory cache set to 512MB${NC}" ;;
        "3") RAM_CACHE_SIZE="1g"; echo -e "${GREEN}âœ“ Memory cache set to 1GB${NC}" ;;
        "4") RAM_CACHE_SIZE="2g"; echo -e "${GREEN}âœ“ Memory cache set to 2GB${NC}" ;;
        "5") RAM_CACHE_SIZE="4g"; echo -e "${GREEN}âœ“ Memory cache set to 4GB${NC}" ;;
        "6") RAM_DISK_ENABLED=$([[ "$RAM_DISK_ENABLED" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ RAM disk $([ "$RAM_DISK_ENABLED" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸŽ¨ Configure Quality Settings
configure_quality_settings() {
    echo -e "\n${BLUE}${BOLD}ðŸŽ¨ QUALITY & COLOR CONFIGURATION:${NC}"
    echo -e "${CYAN}Current: Quality=${BOLD}${QUALITY}${NC}${CYAN}, Colors=${BOLD}${MAX_COLORS}${NC}${CYAN}, Dither=${BOLD}${DITHER_MODE}${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Quick config - Low quality (64 colors, fast)"
    echo -e "  ${GREEN}[2]${NC} Quick config - Medium quality (128 colors, balanced)"
    echo -e "  ${GREEN}[3]${NC} Quick config - High quality (256 colors, best)"
    echo -e "  ${GREEN}[4]${NC} Custom max colors (current: ${MAX_COLORS})"
    echo -e "  ${GREEN}[5]${NC} Dither mode (current: ${DITHER_MODE})\n"
    
    echo -en "${MAGENTA}Select quality option [1-5]: ${NC}"
    read -r quality_choice
    
    case "$quality_choice" in
        "1") QUALITY="low"; MAX_COLORS="64"; DITHER_MODE="none"; echo -e "${GREEN}âœ“ Set to Low quality${NC}" ;;
        "2") QUALITY="medium"; MAX_COLORS="128"; DITHER_MODE="bayer"; echo -e "${GREEN}âœ“ Set to Medium quality${NC}" ;;
        "3") QUALITY="high"; MAX_COLORS="256"; DITHER_MODE="floyd_steinberg"; echo -e "${GREEN}âœ“ Set to High quality${NC}" ;;
        "4") 
            echo -en "${MAGENTA}Enter max colors (8-256): ${NC}"
            read -r custom_colors
            if [[ "$custom_colors" =~ ^[0-9]+$ ]] && [[ $custom_colors -ge 8 && $custom_colors -le 256 ]]; then
                MAX_COLORS="$custom_colors"
                echo -e "${GREEN}âœ“ Max colors set to ${custom_colors}${NC}"
            else
                echo -e "${RED}âœ— Invalid input. No change made.${NC}"
            fi
            ;;
        "5")
            echo -en "${MAGENTA}Select dither mode: ${NC}"
            echo -e "  ${GREEN}[a]${NC} none, ${GREEN}[b]${NC} bayer, ${GREEN}[c]${NC} floyd_steinberg, ${GREEN}[d]${NC} sierra2_4a"
            read -r dither_choice
            case "$dither_choice" in
                "a") DITHER_MODE="none"; echo -e "${GREEN}âœ“ Dither set to none${NC}" ;;
                "b") DITHER_MODE="bayer"; echo -e "${GREEN}âœ“ Dither set to bayer${NC}" ;;
                "c") DITHER_MODE="floyd_steinberg"; echo -e "${GREEN}âœ“ Dither set to floyd_steinberg${NC}" ;;
                "d") DITHER_MODE="sierra2_4a"; echo -e "${GREEN}âœ“ Dither set to sierra2_4a${NC}" ;;
                *) echo -e "${YELLOW}No change made${NC}" ;;
            esac
            ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ›¡ï¸ Configure Compression Settings
configure_compression_settings() {
    echo -e "\n${BLUE}${BOLD}ðŸ›¡ï¸ COMPRESSION & SIZE LIMITS:${NC}"
    echo -e "${CYAN}Current: Level=${BOLD}${COMPRESSION_LEVEL}${NC}${CYAN}, Max Size=${BOLD}${MAX_GIF_SIZE_MB}MB${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Compression Level (current: ${COMPRESSION_LEVEL})"
    echo -e "  ${GREEN}[2]${NC} Max GIF Size (current: ${MAX_GIF_SIZE_MB}MB)"
    echo -e "  ${GREEN}[3]${NC} Auto reduce quality: $(get_status_icon "$AUTO_REDUCE_QUALITY")"
    echo -e "  ${GREEN}[4]${NC} Smart size down: $(get_status_icon "$SMART_SIZE_DOWN")\n"
    
    echo -en "${MAGENTA}Select compression option [1-4]: ${NC}"
    read -r comp_choice
    
    case "$comp_choice" in
        "1")
            echo -en "${MAGENTA}Select compression level: ${NC}"
            echo -e "  ${GREEN}[a]${NC} low, ${GREEN}[b]${NC} medium, ${GREEN}[c]${NC} high, ${GREEN}[d]${NC} maximum"
            read -r level_choice
            case "$level_choice" in
                "a") COMPRESSION_LEVEL="low"; echo -e "${GREEN}âœ“ Compression set to low${NC}" ;;
                "b") COMPRESSION_LEVEL="medium"; echo -e "${GREEN}âœ“ Compression set to medium${NC}" ;;
                "c") COMPRESSION_LEVEL="high"; echo -e "${GREEN}âœ“ Compression set to high${NC}" ;;
                "d") COMPRESSION_LEVEL="maximum"; echo -e "${GREEN}âœ“ Compression set to maximum${NC}" ;;
                *) echo -e "${YELLOW}No change made${NC}" ;;
            esac
            ;;
        "2")
            echo -en "${MAGENTA}Enter max GIF size in MB (1-100): ${NC}"
            read -r custom_size
            if [[ "$custom_size" =~ ^[0-9]+$ ]] && [[ $custom_size -ge 1 && $custom_size -le 100 ]]; then
                MAX_GIF_SIZE_MB="$custom_size"
                echo -e "${GREEN}âœ“ Max GIF size set to ${custom_size}MB${NC}"
            else
                echo -e "${RED}âœ— Invalid input. No change made.${NC}"
            fi
            ;;
        "3") AUTO_REDUCE_QUALITY=$([[ "$AUTO_REDUCE_QUALITY" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Auto reduce quality $([ "$AUTO_REDUCE_QUALITY" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        "4") SMART_SIZE_DOWN=$([[ "$SMART_SIZE_DOWN" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Smart size down $([ "$SMART_SIZE_DOWN" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ” Configure Validation Settings
configure_validation_settings() {
    echo -e "\n${BLUE}${BOLD}ðŸ” VALIDATION & DETECTION SETTINGS:${NC}"
    echo -e "${CYAN}Current validation settings:\n${NC}"
    
    echo -e "  ${GREEN}[1]${NC} Skip validation: $(get_status_icon "$SKIP_VALIDATION")"
    echo -e "  ${GREEN}[2]${NC} Dynamic file detection: $(get_status_icon "$DYNAMIC_FILE_DETECTION")"
    echo -e "  ${GREEN}[3]${NC} File monitor interval: ${BOLD}${FILE_MONITOR_INTERVAL}s${NC}\n"
    
    echo -en "${MAGENTA}Select validation option [1-3]: ${NC}"
    read -r val_choice
    
    case "$val_choice" in
        "1") SKIP_VALIDATION=$([[ "$SKIP_VALIDATION" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Skip validation $([ "$SKIP_VALIDATION" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        "2") DYNAMIC_FILE_DETECTION=$([[ "$DYNAMIC_FILE_DETECTION" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Dynamic file detection $([ "$DYNAMIC_FILE_DETECTION" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        "3")
            echo -en "${MAGENTA}Enter monitor interval in seconds (5-60): ${NC}"
            read -r custom_interval
            if [[ "$custom_interval" =~ ^[0-9]+$ ]] && [[ $custom_interval -ge 5 && $custom_interval -le 60 ]]; then
                FILE_MONITOR_INTERVAL="$custom_interval"
                echo -e "${GREEN}âœ“ Monitor interval set to ${custom_interval}s${NC}"
            else
                echo -e "${RED}âœ— Invalid input. No change made.${NC}"
            fi
            ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ“ Configure Logging Settings
configure_logging_settings() {
    echo -e "\n${BLUE}${BOLD}ðŸ“ LOGGING & DEBUG CONFIGURATION:${NC}"
    echo -e "${CYAN}Current logging settings:\n${NC}"
    
    echo -e "  ${GREEN}[1]${NC} Log level: ${BOLD}${LOG_LEVEL}${NC}"
    echo -e "  ${GREEN}[2]${NC} Progress bar: $(get_status_icon "$PROGRESS_BAR")"
    echo -e "  ${GREEN}[3]${NC} CPU benchmark: $(get_status_icon "$CPU_BENCHMARK")"
    echo -e "  ${GREEN}[4]${NC} Cleanup on exit: $(get_status_icon "$CLEANUP_ON_EXIT")\n"
    
    echo -en "${MAGENTA}Select logging option [1-4]: ${NC}"
    read -r log_choice
    
    case "$log_choice" in
        "1")
            echo -en "${MAGENTA}Select log level: ${NC}"
            echo -e "  ${GREEN}[a]${NC} error, ${GREEN}[b]${NC} warning, ${GREEN}[c]${NC} info, ${GREEN}[d]${NC} debug"
            read -r level_choice
            case "$level_choice" in
                "a") LOG_LEVEL="error"; echo -e "${GREEN}âœ“ Log level set to error${NC}" ;;
                "b") LOG_LEVEL="warning"; echo -e "${GREEN}âœ“ Log level set to warning${NC}" ;;
                "c") LOG_LEVEL="info"; echo -e "${GREEN}âœ“ Log level set to info${NC}" ;;
                "d") LOG_LEVEL="debug"; echo -e "${GREEN}âœ“ Log level set to debug${NC}" ;;
                *) echo -e "${YELLOW}No change made${NC}" ;;
            esac
            ;;
        "2") PROGRESS_BAR=$([[ "$PROGRESS_BAR" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Progress bar $([ "$PROGRESS_BAR" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        "3") CPU_BENCHMARK=$([[ "$CPU_BENCHMARK" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ CPU benchmark $([ "$CPU_BENCHMARK" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        "4") CLEANUP_ON_EXIT=$([[ "$CLEANUP_ON_EXIT" == "true" ]] && echo "false" || echo "true")
             echo -e "${GREEN}âœ“ Cleanup on exit $([ "$CLEANUP_ON_EXIT" == "true" ] && echo "enabled" || echo "disabled")${NC}" ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ”§ Configure Custom Settings
configure_custom_settings() {
    echo -e "\n${BLUE}${BOLD}ðŸ”§ CUSTOM FFMPEG SETTINGS:${NC}"
    echo -e "${CYAN}Advanced users only - direct FFmpeg parameter configuration${NC}\n"
    
    echo -e "${YELLOW}Current custom settings:${NC}"
    echo -e "  Resolution: ${BOLD}${RESOLUTION}${NC}"
    echo -e "  Framerate: ${BOLD}${FRAMERATE}${NC}"
    echo -e "  Scaling algo: ${BOLD}${SCALING_ALGO}${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} Custom resolution (e.g., 1920:1080)"
    echo -e "  ${GREEN}[2]${NC} Custom framerate (e.g., 15)"
    echo -e "  ${GREEN}[3]${NC} Scaling algorithm"
    echo -e "  ${GREEN}[4]${NC} Export current settings to file"
    echo -e "  ${GREEN}[5]${NC} Import settings from file\n"
    
    echo -en "${MAGENTA}Select custom option [1-5]: ${NC}"
    read -r custom_choice
    
    case "$custom_choice" in
        "1")
            echo -en "${MAGENTA}Enter resolution (width:height, e.g. 1280:720): ${NC}"
            read -r custom_res
            if [[ "$custom_res" =~ ^[0-9]+:[0-9]+$ ]]; then
                RESOLUTION="$custom_res"
                echo -e "${GREEN}âœ“ Resolution set to ${custom_res}${NC}"
            else
                echo -e "${RED}âœ— Invalid format. Use width:height${NC}"
            fi
            ;;
        "2")
            echo -en "${MAGENTA}Enter framerate (1-60): ${NC}"
            read -r custom_fps
            if [[ "$custom_fps" =~ ^[0-9]+$ ]] && [[ $custom_fps -ge 1 && $custom_fps -le 60 ]]; then
                FRAMERATE="$custom_fps"
                echo -e "${GREEN}âœ“ Framerate set to ${custom_fps}${NC}"
            else
                echo -e "${RED}âœ— Invalid framerate${NC}"
            fi
            ;;
        "3")
            echo -en "${MAGENTA}Select scaling algorithm: ${NC}"
            echo -e "  ${GREEN}[a]${NC} lanczos (best quality), ${GREEN}[b]${NC} bicubic, ${GREEN}[c]${NC} bilinear, ${GREEN}[d]${NC} neighbor (fastest)"
            read -r scale_choice
            case "$scale_choice" in
                "a") SCALING_ALGO="lanczos"; echo -e "${GREEN}âœ“ Scaling set to lanczos${NC}" ;;
                "b") SCALING_ALGO="bicubic"; echo -e "${GREEN}âœ“ Scaling set to bicubic${NC}" ;;
                "c") SCALING_ALGO="bilinear"; echo -e "${GREEN}âœ“ Scaling set to bilinear${NC}" ;;
                "d") SCALING_ALGO="neighbor"; echo -e "${GREEN}âœ“ Scaling set to neighbor${NC}" ;;
                *) echo -e "${YELLOW}No change made${NC}" ;;
            esac
            ;;
        "4")
            save_current_settings
            ;;
        "5")
            load_settings_from_file
            ;;
        *) echo -e "${YELLOW}No change made${NC}" ;;
    esac
    sleep 1
}

# ðŸ’¾ Save current settings to file
save_current_settings() {
    local settings_file="gif-converter-settings-$(date +%Y%m%d-%H%M%S).conf"
    {
        echo "# Smart GIF Converter Settings - $(date)"
        echo "QUALITY=$QUALITY"
        echo "RESOLUTION=$RESOLUTION"
        echo "FRAMERATE=$FRAMERATE"
        echo "MAX_COLORS=$MAX_COLORS"
        echo "DITHER_MODE=$DITHER_MODE"
        echo "FFMPEG_THREADS=$FFMPEG_THREADS"
        echo "PARALLEL_JOBS=$PARALLEL_JOBS"
        echo "AI_ENABLED=$AI_ENABLED"
        echo "AI_MODE=$AI_MODE"
        echo "GPU_ACCELERATION=$GPU_ACCELERATION"
        echo "COMPRESSION_LEVEL=$COMPRESSION_LEVEL"
        echo "MAX_GIF_SIZE_MB=$MAX_GIF_SIZE_MB"
        echo "BACKUP_ORIGINAL=$BACKUP_ORIGINAL"
        echo "DEBUG_MODE=$DEBUG_MODE"
    } > "$settings_file"
    echo -e "${GREEN}âœ“ Settings saved to: $settings_file${NC}"
}

# ðŸ“ Load settings from file
load_settings_from_file() {
    echo -e "${MAGENTA}Enter settings file path (or press Enter for default): ${NC}"
    read -r settings_path
    
    if [[ -z "$settings_path" ]]; then
        settings_path="$CONFIG_FILE"
    fi
    
    if [[ -f "$settings_path" ]]; then
        source "$settings_path"
        echo -e "${GREEN}âœ“ Settings loaded from: $settings_path${NC}"
    else
        echo -e "${RED}âœ— File not found: $settings_path${NC}"
    fi
}

# âš™ï¸ Advanced conversion mode with settings
advanced_convert_mode() {
    clear
    print_header
    echo -e "${BLUE}${BOLD}âš™ï¸  ADVANCED CONVERSION MODE${NC}\n"
    
    # Show settings configuration
    select_quality_preset
    echo ""
    select_aspect_ratio
    echo ""
    
    # Show comprehensive advanced settings
    show_advanced_settings_menu
    
    echo -e "${MAGENTA}Enter option number (1-16), 'c' to configure custom settings, or Enter to start: ${NC}"
    read -r choice
    
    case "$choice" in
        "1") FORCE_CONVERSION=$([[ "$FORCE_CONVERSION" == "true" ]] && echo "false" || echo "true") ;;
        "2") BACKUP_ORIGINAL=$([[ "$BACKUP_ORIGINAL" == "true" ]] && echo "false" || echo "true") ;;
        "3") AUTO_OPTIMIZE=$([[ "$AUTO_OPTIMIZE" == "true" ]] && echo "false" || echo "true") ;;
        "4") DEBUG_MODE=$([[ "$DEBUG_MODE" == "true" ]] && echo "false" || echo "true") ;;
        "5") AI_ENABLED=$([[ "$AI_ENABLED" == "true" ]] && echo "false" || echo "true") ;;
        "6") configure_ai_mode ;;
        "7") configure_content_type_preference ;;
        "8") configure_threads ;;
        "9") configure_parallel_jobs ;;
        "10") GPU_ACCELERATION=$([[ "$GPU_ACCELERATION" == "auto" ]] && echo "disabled" || echo "auto") ;;
        "11") configure_memory_settings ;;
        "12") configure_quality_settings ;;
        "13") configure_compression_settings ;;
        "14") INTERACTIVE_MODE=$([[ "$INTERACTIVE_MODE" == "true" ]] && echo "false" || echo "true") ;;
        "15") configure_validation_settings ;;
        "16") configure_logging_settings ;;
        "c"|"C") configure_custom_settings ;;
        "")
            INTERACTIVE_MODE=false
            echo -e "\n${CYAN}ðŸ” Starting advanced conversion with validation...${NC}\n"
            if start_conversion; then
                echo -e "\n${GREEN}âœ… Advanced conversion completed successfully!${NC}"
            else
                echo -e "\n${YELLOW}ðŸ“‹ Advanced conversion completed (no action needed)${NC}"
            fi
            ;;
    esac
    
    if [[ -n "$choice" && ("$choice" =~ ^[1-9]$ || "$choice" =~ ^1[0-6]$ || "$choice" =~ ^[cC]$) ]]; then
        advanced_convert_mode  # Recursive call to show updated options
    else
        echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
        read -rsn1
    fi
}

# ðŸ“Š Show conversion statistics
show_conversion_stats() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}ðŸ“Š CONVERSION STATISTICS${NC}\n"
    
    init_log_directory >/dev/null 2>&1
    
    if [[ -f "$CONVERSION_LOG" ]]; then
        local total_conversions=$(grep -c "SUCCESS\|FAILED\|SKIPPED" "$CONVERSION_LOG" 2>/dev/null || echo "0")
        local successful=$(grep -c "SUCCESS" "$CONVERSION_LOG" 2>/dev/null || echo "0")
        local failed=$(grep -c "FAILED" "$CONVERSION_LOG" 2>/dev/null || echo "0")
        local skipped=$(grep -c "SKIPPED" "$CONVERSION_LOG" 2>/dev/null || echo "0")
        
        echo -e "${BLUE}ðŸ“ Log File: $CONVERSION_LOG${NC}"
        echo -e "${YELLOW}ðŸ“ˆ Total Operations: ${BOLD}$total_conversions${NC}"
        echo -e "${GREEN}âœ“ Successful: ${BOLD}$successful${NC}"
        echo -e "${RED}âŒ Failed: ${BOLD}$failed${NC}"
        echo -e "${YELLOW}â­ï¸ Skipped: ${BOLD}$skipped${NC}\n"
        
        if [[ $total_conversions -gt 0 ]]; then
            echo -e "${CYAN}${BOLD}ðŸ•°ï¸ RECENT ACTIVITY (Last 10):${NC}\n"
            tail -10 "$CONVERSION_LOG" | grep -E "SUCCESS|FAILED|SKIPPED" | while read line; do
                if [[ $line == *"SUCCESS"* ]]; then
                    echo -e "  ${GREEN}âœ“ $line${NC}"
                elif [[ $line == *"FAILED"* ]]; then
                    echo -e "  ${RED}âŒ $line${NC}"
                elif [[ $line == *"SKIPPED"* ]]; then
                    echo -e "  ${YELLOW}â­ï¸ $line${NC}"
                fi
            done
        fi
    else
        echo -e "${YELLOW}âš ï¸ No conversion history found${NC}"
        echo -e "${BLUE}Run some conversions to see statistics here!${NC}"
    fi
    
    echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# ðŸ”„ Reset all settings to factory defaults
reset_all_settings() {
    clear
    print_header
    echo -e "${RED}${BOLD}âš ï¸  WARNING: RESET ALL SETTINGS TO FACTORY DEFAULTS${NC}\n"
    
    echo -e "${YELLOW}This will reset ALL settings to their default values:${NC}"
    echo -e "  ${CYAN}â€¢ Quality preset: high${NC}"
    echo -e "  ${CYAN}â€¢ Resolution: 1280:720${NC}"
    echo -e "  ${CYAN}â€¢ Frame rate: 12fps${NC}"
    echo -e "  ${CYAN}â€¢ Aspect ratio: 16:9${NC}"
    echo -e "  ${CYAN}â€¢ AI features: disabled${NC}"
    echo -e "  ${CYAN}â€¢ Output directory: ./converted_gifs${NC}"
    echo -e "  ${CYAN}â€¢ FFmpeg threads: auto${NC}"
    echo -e "  ${CYAN}â€¢ All other settings to defaults${NC}\n"
    
    echo -e "${GREEN}${BOLD}âœ“ YOUR FILES ARE SAFE:${NC}"
    echo -e "  ${GREEN}âœ“ Video files will NOT be affected${NC}"
    echo -e "  ${GREEN}âœ“ Existing GIF files will NOT be deleted${NC}"
    echo -e "  ${GREEN}âœ“ Logs and history will be preserved${NC}"
    echo -e "  ${GREEN}âœ“ AI cache and training data will be kept${NC}\n"
    
    echo -ne "${MAGENTA}${BOLD}Are you ABSOLUTELY SURE you want to reset all settings? [y/N]: ${NC}"
    read -r confirm_reset
    
    if [[ ! "$confirm_reset" =~ ^[Yy]$ ]]; then
        echo -e "\n${YELLOW}â„¹ï¸  Reset cancelled. Settings unchanged.${NC}"
        sleep 2
        return 0
    fi
    
    echo -e "\n${RED}${BOLD}FINAL CONFIRMATION: Type 'RESET' to proceed: ${NC}"
    read -r final_confirm
    
    if [[ "$final_confirm" != "RESET" ]]; then
        echo -e "\n${YELLOW}â„¹ï¸  Reset cancelled. Settings unchanged.${NC}"
        sleep 2
        return 0
    fi
    
    echo -e "\n${CYAN}ðŸ”„ Resetting all settings to factory defaults...${NC}\n"
    sleep 1
    
    # Reset all settings to defaults
    RESOLUTION="1280:720"
    FRAMERATE="12"
    QUALITY="high"
    ASPECT_RATIO="16:9"
    SCALING_ALGO="lanczos"
    DITHER_MODE="bayer"
    MAX_COLORS="128"
    PALETTE_MODE="custom"
    FORCE_CONVERSION=false
    PARALLEL_JOBS="$(nproc 2>/dev/null || echo '4')"
    OUTPUT_FORMAT="gif"
    COMPRESSION_LEVEL="medium"
    AUTO_OPTIMIZE=true
    OPTIMIZE_AGGRESSIVE=true
    OPTIMIZE_TARGET_RATIO=20
    MAX_GIF_SIZE_MB=25
    AUTO_REDUCE_QUALITY=true
    SMART_SIZE_DOWN=true
    GPU_ACCELERATION="auto"
    FFMPEG_THREADS="auto"
    BACKUP_ORIGINAL=true
    LOG_LEVEL="info"
    PROGRESS_BAR=true
    INTERACTIVE_MODE=true
    SKIP_VALIDATION=false
    ONLY_FILE=""
    OUTPUT_DIRECTORY="./converted_gifs"
    OUTPUT_DIR_MODE="default"
    
    # Reset AI settings
    AI_ENABLED=false
    CROP_FILTER=""
    AI_MODE="smart"
    AI_CONFIDENCE_THRESHOLD=70
    AI_CONTENT_CACHE=""
    AI_AUTO_QUALITY=false
    AI_SCENE_ANALYSIS=true
    AI_VISUAL_SIMILARITY=true
    AI_SMART_CROP=true
    AI_DYNAMIC_FRAMERATE=true
    AI_QUALITY_SCALING=true
    AI_CONTENT_FINGERPRINT=true
    AI_THREADS_OPTIMAL="auto"
    AI_MEMORY_OPT="auto"
    CONTENT_TYPE_PREFERENCE="mixed"
    AI_DISCOVERY_ENABLED=true
    AI_DISCOVERY_AUTO_SELECT="ask"
    AI_DISCOVERY_REMEMBER_CHOICE=true
    CPU_BENCHMARK=false
    
    # Reset AI cache settings (keep enabled to preserve cache)
    AI_CACHE_ENABLED=true
    AI_CACHE_MAX_AGE_DAYS=30
    
    # Reset AI training settings (keep enabled to preserve training data)
    AI_TRAINING_ENABLED=true
    AI_LEARNING_RATE=0.1
    AI_CONFIDENCE_MIN=0.3
    AI_TRAINING_MIN_SAMPLES=5
    
    echo -e "  ${GREEN}âœ“ Quality settings reset${NC}"
    echo -e "  ${GREEN}âœ“ AI settings reset${NC}"
    echo -e "  ${GREEN}âœ“ Output directory reset${NC}"
    echo -e "  ${GREEN}âœ“ Threading settings reset${NC}"
    echo -e "  ${GREEN}âœ“ Optimization settings reset${NC}\n"
    
    # Save the reset settings
    save_settings --silent
    
    echo -e "${GREEN}${BOLD}âœ“ ALL SETTINGS RESET TO FACTORY DEFAULTS!${NC}\n"
    echo -e "${CYAN}ðŸ’¡ Tips:${NC}"
    echo -e "  ${YELLOW}â€¢ Your video and GIF files are untouched${NC}"
    echo -e "  ${YELLOW}â€¢ Logs and history are preserved${NC}"
    echo -e "  ${YELLOW}â€¢ AI cache and training data are kept${NC}"
    echo -e "  ${YELLOW}â€¢ You can now reconfigure settings as needed${NC}\n"
    
    echo -e "${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# ðŸ“¦ Comprehensive Dependency Check Menu with WASD Navigation
# Uses existing global dependency checking system from check_dependencies()
show_dependency_check_menu() {
    local selected=0
    local options=(
        "ðŸ”§ Install missing tools (automatic)"
        "ðŸš€ Install hardware drivers (automatic)"
        "ðŸ“‹ Show manual installation commands"
        "ðŸ”„ Re-run dependency check"
        "â† Return to main menu"
    )
    
    # Perform dependency check ONCE before entering loop
    local required_tools=("ffmpeg" "git" "curl" "tmux" "notify-send" "gifsicle" "jq" "convert" "xxhsum" "parallel")
    local optional_tools=()  # All tools are now required per existing logic
    local needs_recheck=true
    
    while true; do
        # Only run dependency check if needed (first time or after option 3)
        if [[ "$needs_recheck" == true ]]; then
            # Arrays to track results
            local missing_required=()
            local missing_optional=()
            local installed_required=()
            local installed_optional=()
            local hw_drivers_missing=()
            
            # Check required dependencies using same logic as check_dependencies()
            for tool in "${required_tools[@]}"; do
        # Special handling for xxhash: accept any variant (matches line 17711-17731)
        if [[ "$tool" == "xxhsum" ]]; then
            if ! command -v xxh128sum >/dev/null 2>&1 && \
               ! command -v xxh64sum  >/dev/null 2>&1 && \
               ! command -v xxhsum    >/dev/null 2>&1; then
                missing_required+=("xxhsum")
                echo -e "  ${RED}âœ—${NC} ${BOLD}xxhash${NC} - ${YELLOW}MISSING${NC}"
                echo -e "    ${GRAY}Benefit: ${GREEN}20-30x faster${GRAY} duplicate detection vs MD5${NC}"
                continue
            fi
            # Show version for whichever variant exists
            installed_required+=("xxhsum")
            local version=""
            if command -v xxh128sum >/dev/null 2>&1; then
                version=$(xxh128sum --version 2>&1 | head -1 | awk '{print $2}' || echo "available")
            elif command -v xxh64sum >/dev/null 2>&1; then
                version=$(xxh64sum --version 2>&1 | head -1 | awk '{print $2}' || echo "available")
            else
                version=$(xxhsum --version 2>&1 | head -1 | awk '{print $2}' || echo "available")
            fi
            echo -e "  ${GREEN}âœ“${NC} ${BOLD}xxhash${NC} - xxHash $version"
            continue
        fi
        
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_required+=("$tool")
            echo -e "  ${RED}âœ—${NC} ${BOLD}$tool${NC} - ${YELLOW}MISSING${NC}"
            case "$tool" in
                "ffmpeg") echo -e "    ${GRAY}Needed for: Video processing (CRITICAL)${NC}" ;;
                "git") echo -e "    ${GRAY}Needed for: Script updates${NC}" ;;
                "curl") echo -e "    ${GRAY}Needed for: Downloading updates${NC}" ;;
                "tmux") echo -e "    ${GRAY}Needed for: Terminal crash protection${NC}" ;;
                "notify-send") echo -e "    ${GRAY}Needed for: Desktop notifications (package: libnotify)${NC}" ;;
                "gifsicle") echo -e "    ${GRAY}Benefit: GIF size optimization (20-50% smaller)${NC}" ;;
                "jq") echo -e "    ${GRAY}Benefit: Enhanced auto-detection features${NC}" ;;
                "convert") echo -e "    ${GRAY}Benefit: AI perceptual hashing for duplicates (package: imagemagick)${NC}" ;;
                "parallel") echo -e "    ${GRAY}Needed for: TRUE parallel hashing (20-30x faster duplicate detection)${NC}" ;;
            esac
        else
            installed_required+=("$tool")
            # Get version info based on tool-specific flags (matches line 17738-17769)
            local version=""
            case "$tool" in
                "git")
                    version=$(git --version 2>/dev/null | head -1 || echo "unknown version")
                    ;;
                "curl")
                    version=$(curl --version 2>/dev/null | head -1 || echo "unknown version")
                    ;;
                "ffmpeg")
                    version=$(ffmpeg -version 2>/dev/null | head -1 | cut -d' ' -f1-3 || echo "unknown version")
                    ;;
                "tmux")
                    version=$(tmux -V 2>/dev/null || echo "unknown version")
                    ;;
                "notify-send")
                    version=$(notify-send --version 2>/dev/null | head -1 || echo "available")
                    ;;
                "gifsicle")
                    version=$(gifsicle --version 2>/dev/null | head -1 || echo "available")
                    ;;
                "jq")
                    version=$(jq --version 2>/dev/null || echo "available")
                    ;;
                "convert")
                    version=$(convert -version 2>/dev/null | head -1 | sed 's/Version: ImageMagick /ImageMagick /' || echo "available")
                    ;;
                "parallel")
                    version=$(parallel --version 2>/dev/null | head -1 || echo "available")
                    ;;
                *)
                    version=$("$tool" --version 2>/dev/null | head -1 2>/dev/null || echo "available")
                    ;;
            esac
            echo -e "  ${GREEN}âœ“${NC} ${BOLD}$tool${NC} - $version"
        fi
            done
            
            # Hardware acceleration check (matches line 17843-18006)
    
    if command -v ffmpeg >/dev/null 2>&1; then
        local ffmpeg_encoders=$(ffmpeg -encoders 2>/dev/null | grep -E "nvenc|qsv|vaapi|videotoolbox")
        local hw_found=false
        
        # NVIDIA NVENC
        if echo "$ffmpeg_encoders" | grep -q "h264_nvenc"; then
            hw_found=true
            echo -e "  ${GREEN}âœ“${NC} ${BOLD}NVIDIA NVENC${NC} - Hardware encoding available"
        elif lspci 2>/dev/null | grep -qi "nvidia"; then
            echo -e "  ${YELLOW}â—‹${NC} ${BOLD}NVIDIA GPU detected${NC} - NVENC ${YELLOW}not available in FFmpeg${NC}"
            hw_drivers_missing+=("nvidia-drivers")
        fi
        
        # AMD/Intel VAAPI
        if echo "$ffmpeg_encoders" | grep -q "h264_vaapi"; then
            hw_found=true
            echo -e "  ${GREEN}âœ“${NC} ${BOLD}VAAPI${NC} - Hardware encoding available (AMD/Intel)"
        elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
            echo -e "  ${YELLOW}â—‹${NC} ${BOLD}AMD GPU detected${NC} - VAAPI ${YELLOW}drivers may be missing${NC}"
            hw_drivers_missing+=("mesa-va-drivers")
        elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
            echo -e "  ${YELLOW}â—‹${NC} ${BOLD}Intel GPU detected${NC} - VAAPI ${YELLOW}drivers may be missing${NC}"
            hw_drivers_missing+=("intel-media-driver")
        fi
        
        # Intel QSV
        if echo "$ffmpeg_encoders" | grep -q "h264_qsv"; then
            hw_found=true
            echo -e "  ${GREEN}âœ“${NC} ${BOLD}Intel QSV${NC} - Hardware encoding available"
        fi
        
        if [[ "$hw_found" == false ]]; then
            echo -e "  ${YELLOW}âš ${NC}  ${YELLOW}No hardware acceleration detected${NC}"
            echo -e "    ${GRAY}CPU-only encoding will be used (slower)${NC}"
        fi
            else
                echo -e "  ${RED}âœ—${NC} ${YELLOW}Cannot check - FFmpeg not installed${NC}"
            fi
            
            needs_recheck=false
        fi
        
        # Display results (always show, only refresh when needs_recheck was true)
        clear
        print_header
        echo -e "${CYAN}${BOLD}ðŸ“¦ DEPENDENCY CHECK & MANAGEMENT${NC}\\n"
        
        echo -e "${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BLUE}${BOLD}REQUIRED DEPENDENCIES${NC}"
        echo -e "${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\\n"
        
        # Display tools status (showing cached results)
        for tool in "${required_tools[@]}"; do
            if [[ " ${installed_required[@]} " =~ " ${tool} " ]]; then
                echo -e "  ${GREEN}âœ“${NC} ${BOLD}$tool${NC} - installed"
            else
                echo -e "  ${RED}âœ—${NC} ${BOLD}$tool${NC} - ${YELLOW}MISSING${NC}"
            fi
        done
        
        echo -e "\n${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BLUE}${BOLD}HARDWARE ACCELERATION${NC}"
        echo -e "${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\\n"
        
        echo -e "  ${GREEN}âœ“${NC} Hardware checks shown during dependency scan"
        
        # Summary
        echo -e "\n${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BLUE}${BOLD}SUMMARY${NC}"
        echo -e "${BLUE}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\\n"
        
        echo -e "  ${GREEN}âœ“${NC} Tools installed: ${BOLD}${#installed_required[@]}${NC}/${BOLD}${#required_tools[@]}${NC}"
        [[ ${#missing_required[@]} -gt 0 ]] && echo -e "  ${RED}âœ—${NC} Missing tools: ${BOLD}${#missing_required[@]}${NC}"
        [[ ${#hw_drivers_missing[@]} -gt 0 ]] && echo -e "  ${YELLOW}!${NC} Missing HW drivers: ${BOLD}${#hw_drivers_missing[@]}${NC}"
    
    # Render options with WASD navigation
    echo -e "\n${CYAN}${BOLD}ACTIONS (W/S to navigate, Enter to select, q to go back)${NC}\n"
    for i in "${!options[@]}"; do
        if [[ $i -eq $selected ]]; then
            echo -e "  ${GREEN}> ${BOLD}${options[$i]}${NC}"
        else
            echo -e "    ${options[$i]}"
        fi
    done
    
    # Contextual help
    case $selected in
        0) echo -e "\n${GRAY}Installs all missing tools using your distro's package manager.${NC}" ;;
        1) echo -e "\n${GRAY}Installs VA-API/NVENC drivers appropriate for your GPU and distro.${NC}" ;;
        2) echo -e "\n${GRAY}Shows copy-paste commands to install tools manually.${NC}" ;;
        3) echo -e "\n${GRAY}Refreshes detection after you change anything.${NC}" ;;
        4) echo -e "\n${GRAY}Return to the main menu.${NC}" ;;
    esac
    
    show_tmux_controls
    
    # Single-key input (WASD + arrows + Enter/Space/q)
    local key=""
    read -rsn1 key 2>/dev/null
    
    # Handle escape sequences for arrow keys
    if [[ "$key" == $'\x1b' ]]; then
        read -rsn2 -t 0.001 key_rest
        key+="$key_rest"
    fi
    
    case "$key" in
        ''|$'\n'|$'\r'|' ') # Enter/Return/Space
            case $selected in
                0)
                    if [[ ${#missing_required[@]} -eq 0 ]]; then
                        echo -e "\n${GREEN}âœ“ All tools are already installed!${NC}"
                    else
                        echo -e "\n${CYAN}ðŸ”§ Installing missing tools...${NC}\n"
                        auto_install_dependencies "${missing_required[@]}"
                    fi
                    echo -e "\n${YELLOW}Press any key to continue...${NC}"; read -rsn1 ;;
                1)
                    if [[ ${#hw_drivers_missing[@]} -eq 0 ]]; then
                        echo -e "\n${GREEN}âœ“ Hardware acceleration is available or not applicable!${NC}"
                    else
                        echo -e "\n${CYAN}ðŸš€ Installing hardware acceleration drivers...${NC}\n"
                        if [[ -f /etc/os-release ]]; then
                            source /etc/os-release
                            local hw_install_cmd=""
                            case "${ID,,}" in
                                ubuntu|debian|pop|mint)
                                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                                        hw_install_cmd="sudo apt update && sudo apt install -y libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                                        hw_install_cmd="sudo apt update && sudo apt install -y mesa-va-drivers libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                                        hw_install_cmd="sudo apt update && sudo apt install -y intel-media-va-driver libva-utils"
                                    fi ;;
                                fedora|rhel|centos)
                                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                                        hw_install_cmd="sudo dnf install -y libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                                        hw_install_cmd="sudo dnf install -y libva-utils mesa-va-drivers"
                                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                                        hw_install_cmd="sudo dnf install -y intel-media-driver libva-utils"
                                    fi ;;
                                arch|manjaro)
                                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                                        hw_install_cmd="sudo pacman -S --needed libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                                        hw_install_cmd="sudo pacman -S --needed libva-mesa-driver libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                                        hw_install_cmd="sudo pacman -S --needed intel-media-driver libva-utils"
                                    fi ;;
                                opensuse*|suse)
                                    if lspci 2>/dev/null | grep -qi "nvidia"; then
                                        hw_install_cmd="sudo zypper install -y libva-vdpau-driver libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "amd.*radeon\|amd.*vga"; then
                                        hw_install_cmd="sudo zypper install -y Mesa-libva libva-utils"
                                    elif lspci 2>/dev/null | grep -qi "intel.*vga\|intel.*graphics"; then
                                        hw_install_cmd="sudo zypper install -y libva-intel-driver libva-utils"
                                    fi ;;
                            esac
                            if [[ -n "$hw_install_cmd" ]]; then
                                echo -e "${CYAN}Running: ${GRAY}$hw_install_cmd${NC}"; eval "$hw_install_cmd"
                                echo -e "\n${GREEN}âœ“ Hardware drivers installed!${NC}"
                                echo -e "${CYAN}ðŸ”„ Please restart the script to detect the new drivers.${NC}"
                            else
                                echo -e "${YELLOW}Could not determine installation command for your system${NC}"
                            fi
                        else
                            echo -e "${YELLOW}Could not detect distribution${NC}"
                        fi
                    fi
                    echo -e "\n${YELLOW}Press any key to continue...${NC}"; read -rsn1 ;;
                2)
                    show_manual_install_commands "${missing_required[@]}"
                    echo -e "\n${YELLOW}Press any key to continue...${NC}"; read -rsn1 ;;
                3)
                    needs_recheck=true  # Trigger dependency recheck on next loop
                    ;;
                4)
                    return 0 ;;
            esac ;;
        'w'|'W'|$'\x1b[A')
            selected=$((selected - 1)); [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1)) ;;
        's'|'S'|$'\x1b[B')
            selected=$((selected + 1)); [[ $selected -ge ${#options[@]} ]] && selected=0 ;;
        'q'|'Q')
            return 0 ;;
        *) : ;;
    esac
    done
}

# ðŸ“‹ Show manual installation commands
show_manual_install_commands() {
    local missing_deps=("$@")
    
    clear
    print_header
    echo -e "${CYAN}${BOLD}ðŸ“‹ MANUAL INSTALLATION COMMANDS${NC}\n"
    
    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        echo -e "${GREEN}âœ“ No missing dependencies!${NC}"
        return 0
    fi
    
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        
        echo -e "${BLUE}Detected distribution: ${BOLD}$NAME${NC}\n"
        
        case "${ID,,}" in
            ubuntu|debian|pop|mint)
                echo -e "${YELLOW}Installation commands for Debian/Ubuntu:${NC}\n"
                echo -e "${GRAY}sudo apt update${NC}"
                for dep in "${missing_deps[@]}"; do
                    local pkg=$(get_package_names "$dep")
                    echo -e "${GRAY}sudo apt install -y $pkg${NC}"
                done
                ;;
            fedora|rhel|centos)
                echo -e "${YELLOW}Installation commands for Fedora/RHEL:${NC}\n"
                for dep in "${missing_deps[@]}"; do
                    local pkg=$(get_package_names "$dep")
                    echo -e "${GRAY}sudo dnf install -y $pkg${NC}"
                done
                ;;
            arch|manjaro)
                echo -e "${YELLOW}Installation commands for Arch/Manjaro:${NC}\n"
                for dep in "${missing_deps[@]}"; do
                    local pkg=$(get_package_names "$dep")
                    echo -e "${GRAY}sudo pacman -S --needed $pkg${NC}"
                done
                ;;
            opensuse*|suse)
                echo -e "${YELLOW}Installation commands for openSUSE:${NC}\n"
                for dep in "${missing_deps[@]}"; do
                    local pkg=$(get_package_names "$dep")
                    echo -e "${GRAY}sudo zypper install -y $pkg${NC}"
                done
                ;;
            *)
                echo -e "${YELLOW}Distribution not recognized. Here are the package names:${NC}\n"
                for dep in "${missing_deps[@]}"; do
                    echo -e "  ${GRAY}â€¢ $dep${NC}"
                done
                ;;
        esac
    else
        echo -e "${YELLOW}Could not detect distribution. Here are the package names:${NC}\n"
        for dep in "${missing_deps[@]}"; do
            echo -e "  ${GRAY}â€¢ $dep${NC}"
        done
    fi
}

# ðŸ“ Manage log files
manage_log_files() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}ðŸ“ LOG FILE MANAGEMENT${NC}\n"
    
    init_log_directory >/dev/null 2>&1
    
    echo -e "${BLUE}Log Directory: ${BOLD}$LOG_DIR${NC}"
    echo -e "${YELLOW}Available actions:${NC}\n"
    
    echo -e "  ${GREEN}[1]${NC} View recent errors (formatted)"
    echo -e "  ${GREEN}[2]${NC} View error log (last 20 lines)"
    echo -e "  ${GREEN}[3]${NC} View conversion log (last 20 lines)"
    echo -e "  ${GREEN}[4]${NC} Clear all logs"
    echo -e "  ${GREEN}[5]${NC} Open log directory in file manager"
    echo -e "  ${GREEN}[6]${NC} Show log file sizes"
    echo -e "  ${GREEN}[0]${NC} Return to main menu\n"
    
    echo -e "${MAGENTA}Select an option: ${NC}"
    read -r choice
    
    case "$choice" in
        "1")
            echo -e "\n${CYAN}${BOLD}ðŸ” RECENT ERRORS (FORMATTED):${NC}\n"
            show_recent_errors 5
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "2")
            echo -e "\n${CYAN}Error Log (last 20 lines):${NC}"
            if [[ -f "$ERROR_LOG" ]]; then
                tail -20 "$ERROR_LOG"
            else
                echo -e "${YELLOW}No error log found${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "3")
            echo -e "\n${CYAN}Conversion Log (last 20 lines):${NC}"
            if [[ -f "$CONVERSION_LOG" ]]; then
                tail -20 "$CONVERSION_LOG"
            else
                echo -e "${YELLOW}No conversion log found${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "4")
            echo -ne "\n${RED}Are you sure you want to clear all logs? [y/N]: ${NC}"
            read -r confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                rm -f "$ERROR_LOG" "$CONVERSION_LOG" 2>/dev/null
                init_log_directory
                echo -e "${GREEN}âœ“ All logs cleared${NC}"
            else
                echo -e "${YELLOW}Operation cancelled${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "5")
            if command -v xdg-open >/dev/null 2>&1; then
                xdg-open "$LOG_DIR" 2>/dev/null
                echo -e "${GREEN}âœ“ Opening log directory in file manager${NC}"
            elif command -v nautilus >/dev/null 2>&1; then
                nautilus "$LOG_DIR" 2>/dev/null &
                echo -e "${GREEN}âœ“ Opening log directory in Nautilus${NC}"
            else
                echo -e "${YELLOW}No file manager found. Directory: $LOG_DIR${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "6")
            echo -e "\n${CYAN}Log File Sizes:${NC}"
            if [[ -f "$ERROR_LOG" ]]; then
                local error_size=$(du -h "$ERROR_LOG" | cut -f1)
                local error_lines=$(wc -l < "$ERROR_LOG")
                echo -e "  ${BLUE}Error Log: ${BOLD}$error_size ($error_lines lines)${NC}"
            fi
            if [[ -f "$CONVERSION_LOG" ]]; then
                local conv_size=$(du -h "$CONVERSION_LOG" | cut -f1)
                local conv_lines=$(wc -l < "$CONVERSION_LOG")
                echo -e "  ${BLUE}Conversion Log: ${BOLD}$conv_size ($conv_lines lines)${NC}"
            fi
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
        "0"|"")
            return
            ;;
        *)
            echo -e "${RED}Invalid option${NC}"
            echo -e "\n${YELLOW}Press any key to continue...${NC}"
            read -rsn1
            manage_log_files
            ;;
    esac
}

# ðŸ”§ Show system information
show_system_info() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}ðŸ”§ SYSTEM INFORMATION${NC}\n"
    
    echo -e "${YELLOW}System Dependencies:${NC}"
    
    # Check FFmpeg
    if command -v ffmpeg >/dev/null 2>&1; then
        local ffmpeg_version=$(ffmpeg -version 2>/dev/null | head -1 | cut -d' ' -f3)
        echo -e "  ${GREEN}âœ“ FFmpeg: ${BOLD}$ffmpeg_version${NC}"
    else
        echo -e "  ${RED}âŒ FFmpeg: Not installed${NC}"
    fi
    
    # Check FFprobe
    if command -v ffprobe >/dev/null 2>&1; then
        echo -e "  ${GREEN}âœ“ FFprobe: Available${NC}"
    else
        echo -e "  ${RED}âŒ FFprobe: Not installed${NC}"
    fi
    
    # Check optional tools
    if command -v gifsicle >/dev/null 2>&1; then
        local gifsicle_version=$(gifsicle --version 2>/dev/null | head -1 | grep -o '[0-9]\+\.[0-9]\+\.*[0-9]*')
        echo -e "  ${GREEN}âœ“ Gifsicle: ${BOLD}$gifsicle_version${NC} (optimization available)"
    else
        echo -e "  ${YELLOW}âš ï¸ Gifsicle: Not installed (optimization disabled)${NC}"
    fi
    
    if command -v jq >/dev/null 2>&1; then
        echo -e "  ${GREEN}âœ“ jq: Available (auto-detection enabled)${NC}"
    else
        echo -e "  ${YELLOW}âš ï¸ jq: Not installed (limited auto-detection)${NC}"
    fi
    
    echo -e "\n${YELLOW}Current Configuration:${NC}"
    echo -e "  ${BLUE}Quality: ${BOLD}$QUALITY${NC}"
    echo -e "  ${BLUE}Resolution: ${BOLD}$RESOLUTION${NC}"
    echo -e "  ${BLUE}Frame Rate: ${BOLD}${FRAMERATE}fps${NC}"
    echo -e "  ${BLUE}Aspect Ratio: ${BOLD}$ASPECT_RATIO${NC}"
    echo -e "  ${BLUE}Scaling: ${BOLD}$SCALING_ALGO${NC}"
    echo -e "  ${BLUE}Max Colors: ${BOLD}$MAX_COLORS${NC}"
    
    echo -e "\n${YELLOW}Advanced System Analysis:${NC}"
    
    # Enhanced CPU information
    local cpu_info=$(detect_cpu_architecture)
    local physical_cores=$(get_physical_cores)
    local logical_cores=$(get_logical_cores)
    local memory_gb=$(get_available_memory_gb)
    local cpu_scaling=$(detect_cpu_scaling)
    local governor=$(echo $cpu_scaling | cut -d',' -f1 | cut -d':' -f2)
    local current_freq=$(echo $cpu_scaling | cut -d',' -f2 | cut -d':' -f2)
    
    echo -e "  ${GREEN}ðŸ§® CPU Architecture:${NC}"
    echo -e "    ${BLUE}Model: ${BOLD}$(echo "$cpu_info" | cut -d'(' -f1)${NC}"
    if [[ "$cpu_info" == *"("* ]]; then
        local features=$(echo "$cpu_info" | grep -o '([^)]*)' | tr -d '()')
        echo -e "    ${BLUE}Features: ${BOLD}$features${NC}"
    fi
    echo -e "    ${BLUE}Physical cores: ${BOLD}$physical_cores${NC} | ${BLUE}Logical cores: ${BOLD}$logical_cores${NC}"
    [[ "$governor" != "unknown" ]] && echo -e "    ${BLUE}Power governor: ${BOLD}$governor${NC}"
    [[ "$current_freq" != "unknown" ]] && echo -e "    ${BLUE}Current frequency: ${BOLD}$current_freq${NC}"
    
    # Enhanced memory information
    if command -v free >/dev/null 2>&1; then
        local mem_total=$(free -h | awk '/^Mem:/ {print $2}')
        local mem_used=$(free -h | awk '/^Mem:/ {print $3}')
        local mem_available=$(free -h | awk '/^Mem:/ {print $7}')
        local mem_percent=$(free | awk '/^Mem:/ {printf "%.0f", $3*100/$2}')
        
        echo -e "  ${GREEN}ðŸ“¦ Memory Status:${NC}"
        echo -e "    ${BLUE}Total: ${BOLD}$mem_total${NC} | ${BLUE}Used: ${BOLD}$mem_used${NC} (${mem_percent}%) | ${BLUE}Available: ${BOLD}$mem_available${NC}"
    fi
    
    # Disk space with enhanced details
    local disk_total=$(df -h . | awk 'NR==2 {print $2}')
    local disk_used=$(df -h . | awk 'NR==2 {print $3}')
    local disk_available=$(df -h . | awk 'NR==2 {print $4}')
    local disk_percent=$(df . | awk 'NR==2 {print $5}')
    
    echo -e "  ${GREEN}ðŸ’¾ Storage Status:${NC}"
    echo -e "    ${BLUE}Total: ${BOLD}$disk_total${NC} | ${BLUE}Used: ${BOLD}$disk_used${NC} ($disk_percent) | ${BLUE}Available: ${BOLD}$disk_available${NC}"
    
    # Current CPU utilization
    local current_cpu=$(monitor_cpu_performance 2)
    echo -e "  ${GREEN}ðŸ“ˆ Current Performance:${NC}"
    echo -e "    ${BLUE}$current_cpu${NC} utilization"
    
    # Optimal settings recommendation
    local optimal_threads=$(calculate_optimal_ffmpeg_threads "$logical_cores" "$memory_gb")
    local optimal_jobs=$(calculate_optimal_parallel_jobs "$logical_cores" "$physical_cores" "$memory_gb")
    
    echo -e "  ${GREEN}âš™ï¸ Recommended Settings:${NC}"
    echo -e "    ${BLUE}FFmpeg threads: ${BOLD}$optimal_threads${NC} | ${BLUE}Parallel jobs: ${BOLD}$optimal_jobs${NC}"
    
    # Calculate max potential thread usage (parallel jobs * threads per job)
    local max_thread_usage=$((optimal_jobs * optimal_threads))
    # Calculate percentage of logical core utilization
    local thread_percent=$((max_thread_usage * 100 / logical_cores))
    
    echo -e "    ${BLUE}Max thread usage: ${BOLD}$max_thread_usage${NC} threads (${thread_percent}% of $logical_cores cores)"
    
    echo -e "\n${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# â“ Show interactive help
show_interactive_help() {
    clear
    print_header
    echo -e "${CYAN}${BOLD}â“ HELP & DOCUMENTATION${NC}\n"
    
    echo -e "${YELLOW}Welcome to Smart GIF Converter!${NC}\n"
    
    echo -e "${GREEN}${BOLD}ðŸŽ¬ Quick Start:${NC}"
    echo -e "  1. Place video files in the current directory"
    echo -e "  2. Choose 'Quick Mode' for default conversion"
    echo -e "  3. Or use 'Advanced Mode' to customize settings\n"
    
    echo -e "${GREEN}${BOLD}ðŸŽ¯ Supported Formats:${NC}"
    echo -e "  Input:  MP4, AVI, MOV, MKV, WebM"
    echo -e "  Output: GIF (with optional optimization)\n"
    
    echo -e "${GREEN}${BOLD}âš™ï¸ Quality Presets:${NC}"
    echo -e "  Low:    480p,  8fps  - Small files"
    echo -e "  Medium: 720p,  12fps - Balanced"
    echo -e "  High:   1080p, 15fps - Recommended"
    echo -e "  Ultra:  1440p, 20fps - High quality"
    echo -e "  Max:    4K,    24fps - Maximum quality\n"
    
    echo -e "${GREEN}${BOLD}ðŸ“ Aspect Ratios:${NC}"
    echo -e "  16:9 - Widescreen (YouTube standard)"
    echo -e "  4:3  - Classic TV format"
    echo -e "  1:1  - Square (Instagram)"
    echo -e "  21:9 - Ultra-wide cinematic"
    echo -e "  9:16 - Vertical (TikTok/Mobile)\n"
    
    echo -e "${GREEN}${BOLD}ðŸ›¡ï¸ Smart Features:${NC}"
    echo -e "  âœ“ Automatic file skipping (if already converted)"
    echo -e "  âœ“ Error handling with retry logic"
    echo -e "  âœ“ Progress tracking and statistics"
    echo -e "  âœ“ Comprehensive logging system"
    echo -e "  âœ“ Automatic palette optimization\n"
    
    echo -e "${BLUE}${BOLD}ðŸ“ Log Files:${NC}"
    echo -e "  Location: ~/.smart-gif-converter/"
    echo -e "  â€¢ errors.log - Error tracking"
    echo -e "  â€¢ conversions.log - Conversion history\n"
    
    echo -e "${YELLOW}Press any key to return to main menu...${NC}"
    read -rsn1
}

# ðŸš€ Start conversion process with robust error handling
start_conversion() {
    trace_function "start_conversion"
    
    echo -e "${BLUE}ðŸ”„ Starting robust conversion process...${NC}"
    
    # Validate environment before starting
    if ! validate_conversion_environment; then
        log_error "Environment validation failed" "" "Cannot proceed with conversion" "${BASH_LINENO[0]}" "start_conversion"
        return 1
    fi
    
    # Run pre-conversion validation and cleanup
    if ! perform_pre_conversion_validation; then
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "${YELLOW}ðŸ‘‹ Process stopped by user - no files converted${NC}"
        else
            echo -e "${YELLOW}ðŸ Validation completed - no conversion needed${NC}"
        fi
        return 0
    fi
    
    # Load previous progress to resume where we left off
    declare -A processed_files
    local has_previous_progress=false
    if load_progress processed_files; then
        has_previous_progress=true
    fi
    
    # Count video files and check for existing conversions
    local total_files=0
    local files_to_process=()
    local already_converted=0
    local resumed_files=0
    
    # If validation already found files needing conversion, use that list
    if [[ ${#conversion_needed[@]} -gt 0 ]]; then
        echo -e "${CYAN}ðŸ’¡ Using validation results: ${#conversion_needed[@]} files need conversion${NC}"
        for video_file in "${!conversion_needed[@]}"; do
            if [[ -f "$video_file" ]]; then
                files_to_process+=("$video_file")
                ((total_files++))
            fi
        done
        # Skip the rescan since we already know what needs conversion
    elif [[ -n "$ONLY_FILE" ]]; then
        if [[ -f "$ONLY_FILE" ]]; then
            if validate_video_file "$ONLY_FILE"; then
                files_to_process+=("$ONLY_FILE")
                total_files=1
                echo -e "${GREEN}ðŸ“„ Ready to convert (single file): $(basename \"$ONLY_FILE\")${NC}"
            else
                echo -e "${RED}âŒ Invalid input file: $ONLY_FILE${NC}"
                return 1
            fi
        else
            echo -e "${RED}âŒ File not found: $ONLY_FILE${NC}"
            return 1
        fi
    else
    # Show clean validation progress bar (no text, just bar)
    
    shopt -s nullglob
    local all_video_files=(*.mp4 *.avi *.mov *.mkv *.webm)
    local total_to_check=${#all_video_files[@]}
    local checked=0
    
    # Enable silent mode for validation phase
    VALIDATION_SILENT_MODE=true
    
    # Track cache hits/misses to show status
    CACHE_HITS=0
    CACHE_MISSES=0
    
    for file in "${all_video_files[@]}"; do
        # Check for interrupt during validation
        if [[ "$INTERRUPT_REQUESTED" == "true" ]]; then
            echo -e "\n  ${YELLOW}â¸ï¸  Validation interrupted by user${NC}"
            break
        fi
        
        # Skip zero-byte or very small files early to avoid repeated errors
        if [[ -f "$file" ]]; then
            local file_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
            if [[ $file_size -lt 1024 ]]; then
                ((checked++))
                ((total_files++))
                ((corrupt_input_files++))
                continue
            fi
        fi
        
        if [[ -f "$file" && -r "$file" ]]; then
            ((checked++))
            
            # Show progress bar if many files
            if [[ $total_to_check -gt 10 ]]; then
                local percent=$((checked * 100 / total_to_check))
                local filled=$((checked * 50 / total_to_check))
                local empty=$((50 - filled))
                
                # Build progress bar
                local bar=""
                for ((i=0; i<filled; i++)); do bar+="â–ˆ"; done
                for ((i=0; i<empty; i++)); do bar+="â–‘"; done
                
                # Determine status message based on cache usage
                local status_msg=""
                if [[ $CACHE_HITS -gt 0 && $CACHE_MISSES -eq 0 ]]; then
                    status_msg="${GREEN}Cached${NC}"
                elif [[ $CACHE_MISSES -gt 0 ]]; then
                    status_msg="${YELLOW}Validating${NC}"
                else
                    status_msg="${CYAN}Checking${NC}"
                fi
                
                # Truncate filename if too long (max 40 chars)
                local display_file="$(basename -- "$file")"
                if [[ ${#display_file} -gt 40 ]]; then
                    display_file="${display_file:0:37}..."
                fi
                
                # Single-line progress with status and filename
                printf "\r\033[K${BLUE}ðŸ” [${GREEN}%s${GRAY}%s${BLUE}] ${YELLOW}%3d%%${NC} ${GRAY}(%d/%d)${NC} %b ${GRAY}%s${NC}" "${bar:0:filled}" "${bar:filled:empty}" "$percent" "$checked" "$total_to_check" "$status_msg" "$display_file"
            fi
            
            ((total_files++)) || true
            local base_name=$(basename -- "$file")
            
            # Check if file was already processed in previous session
            if [[ -n "${processed_files[$base_name]:-}" ]]; then
                ((resumed_files++)) || true
                ((already_converted++)) || true
                continue
            fi
            
            # Check for duplicates first (silently during validation)
            if check_duplicate_output "$file"; then
                ((already_converted++)) || true
                ((skipped_files++)) || true
                log_conversion "SKIPPED" "$file" "${file%.*}.${OUTPUT_FORMAT}" "(already exists)"
            else
                # Only do basic validation for files we'll actually process
                if validate_video_file "$file"; then
                    files_to_process+=("$file")
                else
                    ((corrupt_input_files++)) || true
                fi
            fi
        fi
    done
    
    # Disable silent mode after validation
    VALIDATION_SILENT_MODE=false
    
    # Clear validation progress bar
    if [[ $total_to_check -gt 10 ]]; then
        printf "\r\033[K"
    fi
    
    shopt -u nullglob
    fi
    
    # Show resume info if applicable
    if [[ $has_previous_progress == true && $resumed_files -gt 0 ]]; then
        echo -e "${CYAN}ðŸ”„ Resuming from previous session: $resumed_files files already completed${NC}"
    fi
    
    if [[ $total_files -eq 0 ]]; then
        echo -e "${RED}âŒ No video files found in current directory${NC}"
        return 1
    fi
    
    if [[ ${#files_to_process[@]} -eq 0 ]]; then
        echo -e "${GREEN}âœ“ All $total_files video files already converted!${NC}"
        if [[ $already_converted -gt 0 ]]; then
            echo -e "${BLUE}ðŸ“ $already_converted files already exist as GIFs${NC}"
        fi
        return 0
    fi
    
    echo -e "${BLUE}ðŸŽ¯ Found $total_files video files total${NC}"
    echo -e "${GREEN}âœ“ $already_converted already converted, ${#files_to_process[@]} to process${NC}"
    echo -e "${YELLOW}âš™ï¸  Quality: $QUALITY | Resolution: $RESOLUTION | FPS: $FRAMERATE | Aspect: $ASPECT_RATIO${NC}"
    echo ""
    
    # Start dynamic file monitoring if enabled
    if [[ "$DYNAMIC_FILE_DETECTION" == "true" ]]; then
        # Get current files for monitoring baseline
        local all_current_files=()
        shopt -s nullglob
        for file in *.mp4 *.avi *.mov *.mkv *.webm; do
            [[ -f "$file" && -r "$file" ]] && all_current_files+=("$file")
        done
        shopt -u nullglob
        
        monitor_new_files "${all_current_files[@]}"
    fi
    
    # Process only the files that need conversion
    local current=0
    local files_to_convert=${#files_to_process[@]}
    
    if [[ "$PARALLEL_JOBS" -gt 1 && $files_to_convert -gt 1 ]]; then
        echo -e "${GREEN}ðŸš€ Starting parallel conversion with $PARALLEL_JOBS concurrent jobs${NC}"
        echo -e "${BLUE}Processing $files_to_convert files in parallel...${NC}\n"
        
        # Parallel processing using job control
        local job_count=0
        local active_jobs=()
        
        for file in "${files_to_process[@]}"; do
            # Check for graceful interrupt request
            if [[ "$INTERRUPT_REQUESTED" == true ]]; then
                echo -e "\n${YELLOW}ðŸ‘‹ Quitting... Waiting for current jobs to complete${NC}"
                break
            fi
            
            # Wait if we've reached max parallel jobs
            while [[ $job_count -ge $PARALLEL_JOBS ]]; do
                # Check for completed jobs
                for i in "${!active_jobs[@]}"; do
                    if ! kill -0 "${active_jobs[i]}" 2>/dev/null; then
                        # Job finished, remove from active list
                        unset "active_jobs[i]"
                        ((job_count--))
                    fi
                done
                # Compact array
                active_jobs=("${active_jobs[@]}")
                sleep 0.1
            done
            
            ((current++))
            
            # Show overall progress
            if [[ "$PROGRESS_BAR" == true ]]; then
                local percent=$((current * 100 / files_to_convert))
                local filled=$((current * 50 / files_to_convert))
                local empty=$((50 - filled))
                printf "\r${BLUE}Overall: ["
                for ((i=0; i<filled; i++)); do printf "â–ˆ"; done
                for ((i=0; i<empty; i++)); do printf "â–‘"; done
                printf "] %d%% (%d/%d) Processing...${NC}" $percent $current $files_to_convert
            fi
            
            # Start conversion in background with proper I/O redirection
            (
                # Redirect stdin to prevent terminal conflicts
                exec </dev/null
                # Set process group to handle signals properly
                set -m 2>/dev/null || true
                CURRENT_FILE="$file"
                convert_video "$file"
                CURRENT_FILE=""
            ) &
            
            local job_pid=$!
            active_jobs+=("$job_pid")
            ((job_count++))
            
            echo -e "${CYAN}Started job $current/$files_to_convert: $(basename -- "$file") (PID: $job_pid)${NC}"
        done
        
        # Wait for all remaining jobs to complete
        echo -e "\n${YELLOW}Waiting for all parallel jobs to complete...${NC}"
        for job_pid in "${active_jobs[@]}"; do
            if kill -0 "$job_pid" 2>/dev/null; then
                wait "$job_pid" 2>/dev/null || true
            fi
        done
        
    else
        # Sequential processing (original method)
        for file in "${files_to_process[@]}"; do
            # Check for graceful interrupt request
            if [[ "$INTERRUPT_REQUESTED" == true ]]; then
                echo -e "\n${YELLOW}ðŸ‘‹ Quitting... Stopping after completing current file${NC}"
                break
            fi
            
            ((current++))
            
            # Track current file for cleanup purposes
            CURRENT_FILE="$file"
            
            # Show overall progress with current file info
            if [[ "$PROGRESS_BAR" == true ]]; then
                show_progress $current $files_to_convert "$file" "Processing..."
            fi
            
            convert_video "$file"
            
            # Clear current file tracking when done
            CURRENT_FILE=""
        done
    fi
    
    # Final progress update - only show 100% if not interrupted
    if [[ "$PROGRESS_BAR" == true ]]; then
        if [[ "$INTERRUPT_REQUESTED" == true ]]; then
            # Show actual progress when interrupted
            local percent=$((current * 100 / files_to_convert))
            local filled=$((current * 50 / files_to_convert))
            local empty=$((50 - filled))
            printf "\r\033[K${YELLOW}Overall: ["
            for ((i=0; i<filled; i++)); do printf "â–ˆ"; done
            for ((i=0; i<empty; i++)); do printf "â–‘"; done
            printf "] %d%% (%d/%d) ${YELLOW}Interrupted${NC}\n\n" $percent $current $files_to_convert
        else
            # Show 100% completion for successful finish
            printf "\r\033[K${GREEN}Overall: ["
            printf "%50s" | tr ' ' 'â–“'
            printf "] 100%% (%d/%d) ${GREEN}Completed!${NC}\n\n" $files_to_convert $files_to_convert
        fi
    fi
    
    show_statistics
    
    # Show detailed error information if there were failures
    if [[ $failed_files -gt 0 ]]; then
        echo -e "${RED}âš ï¸  $failed_files file(s) failed to convert${NC}"
        echo -e "${YELLOW}ðŸ“‚ Log Directory: $LOG_DIR${NC}"
        echo -e "${BLUE}ðŸ“„ Error Log: $ERROR_LOG${NC}"
        echo -e "${BLUE}ðŸ“ˆ Conversion Log: $CONVERSION_LOG${NC}"
        echo ""
        
        # Show recent errors automatically
        show_recent_errors 3
        
        echo -e "\n${YELLOW}ðŸ”§ Troubleshooting Commands:${NC}"
        echo -e "  ${CYAN}View full error log:${NC} tail -50 \"$ERROR_LOG\""
        echo -e "  ${CYAN}View recent conversions:${NC} tail -20 \"$CONVERSION_LOG\""
        echo -e "  ${CYAN}Clear error log:${NC} > \"$ERROR_LOG\""
    fi
    
    if [[ $converted_files -gt 0 ]]; then
        echo -e "${GREEN}ðŸŽ‰ Conversion completed successfully!${NC}"
        if [[ $failed_files -eq 0 ]]; then
            echo -e "${GREEN}All files processed without errors${NC}"
        fi
    elif [[ $skipped_files -gt 0 && $failed_files -eq 0 ]]; then
        echo -e "${YELLOW}â„¹ï¸  No new files were converted (all up-to-date)${NC}"
    elif [[ $failed_files -gt 0 ]]; then
        echo -e "${RED}âŒ Some files failed to convert${NC}"
    else
        echo -e "${YELLOW}â„¹ï¸  No files were processed${NC}"
    fi
    
    # Show tmux controls footer
    show_tmux_controls
    
    # Check for any new files detected during conversion
    check_for_new_files
    
    # Stop file monitoring and clean up
    stop_file_monitoring
    
    # Ensure all ffmpeg processes are stopped
    kill_script_ffmpeg_processes
    
    # Save settings after successful run
    if [[ -n "$SETTINGS_FILE" ]]; then
        save_settings --silent
    fi
}

# ðŸŽ¡ Welcome screen with friendly introduction
show_welcome() {
    clear
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${CYAN}${BOLD}â•‘                    ðŸŽ¬ SMART GIF CONVERTER v10                     â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•‘                  ðŸ¤– AI-Powered Video to GIF Magic                  â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${GREEN}ðŸ‘‹ Welcome! Let me help you convert videos to amazing GIFs!${NC}"
    echo -e "${BLUE}ðŸ’» This tool automatically optimizes everything for you.${NC}"
    echo ""
    
    # System detection with friendly messages
    echo -e "${YELLOW}ðŸ” Detecting your system capabilities...${NC}"
    local cpu_cores=$(nproc 2>/dev/null || echo "4")
    local total_ram=$(free -h 2>/dev/null | awk '/^Mem:/ {print $2}' || echo "unknown")
    local gpu_status="ðŸš« No GPU acceleration"
    
    # Check for GPU acceleration
    if command -v nvidia-smi >/dev/null 2>&1 && nvidia-smi >/dev/null 2>&1; then
        local gpu_name=$(nvidia-smi --query-gpu=name --format=csv,noheader,nounits 2>/dev/null | head -1)
        gpu_status="ðŸš€ NVIDIA GPU: ${gpu_name:-Unknown}"
    elif [[ -d /sys/class/drm ]] && ls /sys/class/drm/card*/device/vendor 2>/dev/null | xargs cat | grep -q "0x1002\|0x8086"; then
        gpu_status="ðŸš€ AMD/Intel GPU detected"
    fi
    
    echo -e "  ${GREEN}âœ“ CPU:${NC} ${BOLD}${cpu_cores} cores${NC} - Perfect for fast conversions!"
    echo -e "  ${GREEN}âœ“ RAM:${NC} ${BOLD}${total_ram}${NC} - Great for handling large videos!"
    echo -e "  ${GREEN}âœ“ GPU:${NC} ${gpu_status}"
    echo ""
    
    # Check for video files in current directory
    local video_count=0
    shopt -s nullglob
    for ext in mp4 avi mov mkv webm; do
        local files=(*."$ext")
        video_count=$((video_count + ${#files[@]}))
    done
    shopt -u nullglob
    
    if [[ $video_count -gt 0 ]]; then
        echo -e "${GREEN}ðŸ“¹ Found ${BOLD}${video_count}${NC}${GREEN} video file(s) ready to convert!${NC}"
        echo -e "${CYAN}ðŸŽ¯ I'll automatically optimize each one for the best results.${NC}"
    else
        echo -e "${YELLOW}ðŸ“ No video files found in current directory.${NC}"
        echo -e "${BLUE}ðŸ“Œ Tip: Place video files (mp4, avi, mov, mkv, webm) here and run again!${NC}"
    fi
    echo ""
    
    # Show first-time setup if needed
    if [[ ! -f "$SETTINGS_FILE" ]]; then
        show_first_time_setup
    else
        show_quick_tips
    fi
}

# ðŸŽ† First time setup wizard
show_first_time_setup() {
    echo -e "${MAGENTA}${BOLD}ðŸŽ† FIRST TIME SETUP - Let's get you started!${NC}\n"
    
    echo -e "${BLUE}ðŸ¤” What type of content do you usually convert?${NC}"
    echo -e "  ${GREEN}[1]${NC} Anime/Animation (optimized for cartoons)"
    echo -e "  ${GREEN}[2]${NC} Movies/TV Shows (live action content)"
    echo -e "  ${GREEN}[3]${NC} Screen recordings (tutorials, gameplay)"
    echo -e "  ${GREEN}[4]${NC} Mixed content (I'll use smart AI detection)"
    echo -e "  ${GREEN}[5]${NC} Skip setup (use defaults)\\n"
    
    echo -en "${MAGENTA}Your choice [1-5]:${NC} "
    read -r setup_choice
    
    case "$setup_choice" in
        "1")
            QUALITY="high"
            MAX_COLORS="128"
            DITHER_MODE="floyd_steinberg"
            AI_MODE="content"
            CONTENT_TYPE_PREFERENCE="animation"
            echo -e "\n${GREEN}âœ“ Optimized for anime/animation content!${NC}"
            ;;
        "2")
            QUALITY="medium"
            MAX_COLORS="256"
            DITHER_MODE="bayer"
            AI_MODE="motion"
            CONTENT_TYPE_PREFERENCE="movie"
            echo -e "\n${GREEN}âœ“ Optimized for movies and live action!${NC}"
            ;;
        "3")
            QUALITY="high"
            MAX_COLORS="64"
            DITHER_MODE="none"
            FRAMERATE="10"
            AI_MODE="quality"
            CONTENT_TYPE_PREFERENCE="screencast"
            echo -e "\n${GREEN}âœ“ Optimized for screen recordings!${NC}"
            ;;
        "4")
            # Enable FULL AI system with all advanced features
            AI_ENABLED=true
            AI_MODE="smart"
            AI_AUTO_QUALITY=true  # Let AI choose quality per video
            AI_SCENE_ANALYSIS=true
            AI_VISUAL_SIMILARITY=true
            AI_SMART_CROP=true
            AI_DYNAMIC_FRAMERATE=true
            AI_QUALITY_SCALING=true
            AI_CONTENT_FINGERPRINT=true
            AI_CACHE_ENABLED=true
            AI_TRAINING_ENABLED=true
            CONTENT_TYPE_PREFERENCE="mixed"
            echo -e "\n${GREEN}âœ“ ðŸ§  Full AI system activated with learning enabled!${NC}"
            echo -e "${CYAN}   â€¢ Smart content detection and classification${NC}"
            echo -e "${CYAN}   â€¢ Automatic quality optimization per video${NC}"
            echo -e "${CYAN}   â€¢ Advanced scene analysis and frame rate adjustment${NC}"
            echo -e "${CYAN}   â€¢ Intelligent caching for faster re-processing${NC}"
            echo -e "${CYAN}   â€¢ AI learning from successful conversions${NC}"
            ;;
        *)
            echo -e "\n${YELLOW}âœ“ Using balanced default settings.${NC}"
            ;;
    esac
    
    # Actually save the settings to file
    init_log_directory  # Ensure settings directory exists
    save_settings
    
    echo -e "\n${CYAN}ðŸ’¾ Settings saved! You can change them anytime in Advanced Mode.${NC}\n"
    sleep 2
}

# ðŸ“š Quick tips for returning users
show_quick_tips() {
    local tips=(
        "ðŸš€ Pro tip: AI Quick Mode analyzes each video automatically!"
        "âš™ï¸ Advanced Mode has 15+ settings you can customize!"
        "ðŸ“Š Check Statistics to see your conversion history!"
        "ðŸ”§ Use 'c' in Advanced Mode for custom FFmpeg settings!"
        "ðŸ’¾ Your settings are automatically saved between runs!"
    )
    
    local random_tip=${tips[$RANDOM % ${#tips[@]}]}
    echo -e "${CYAN}ðŸ’¡ ${random_tip}${NC}\n"
}

# ðŸ“± Get responsive help text based on screen size
get_responsive_help_text() {
    local short_text="$1"
    local long_text="$2"
    local layout_mode="$3"
    
    case $layout_mode in
        "mobile")
            echo "$short_text"
            ;;
        "tablet")
            # Use medium-length text
            local medium_text=$(echo "$long_text" | cut -c1-50)
            if [[ ${#long_text} -gt 50 ]]; then
                echo "${medium_text}..."
            else
                echo "$long_text"
            fi
            ;;
        *)
            echo "$long_text"
            ;;
    esac
}

# ðŸ“‹ Show tmux controls footer (displays consistently across all screens)
show_tmux_controls() {
    # Only show if running in tmux
    if [[ -n "$TMUX" ]]; then
        echo ""
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${CYAN}${BOLD}ðŸ“‹ TMUX SESSION CONTROLS${NC}"
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${BLUE}Useful commands:${NC}"
        echo -e "  ${GREEN}Ctrl+b then d${NC}     - Detach (keeps session running)"
        echo -e "  ${GREEN}exit${NC}              - Close this pane/window"
        echo -e "  ${GREEN}tmux ls${NC}           - List all sessions"
        if [[ -n "$TMUX_PANE" ]]; then
            local session_name=$(tmux display-message -p '#S' 2>/dev/null || echo "unknown")
            echo -e "  ${GREEN}tmux attach -t ${session_name}${NC} - Reattach to this session"
        fi
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    fi
}

# ðŸŽª Function to print fancy headers (simplified for menus)
print_header() {
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘                ðŸŽ¬ SMART GIF CONVERTER v10                  â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•‘                AI-Powered Video to GIF Magic                  â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# ðŸ“‹ Function to show help
show_help() {
    cat << EOF
${BOLD}ðŸŽ¬ SMART GIF CONVERTER - Advanced Usage Guide${NC}

${YELLOW}BASIC USAGE:${NC}
    $0 [OPTIONS]

${YELLOW}QUALITY PRESETS:${NC}
    --preset low        Low quality, small files (480p, 8fps)
    --preset medium     Balanced quality (720p, 12fps)
    --preset high       High quality (1080p, 15fps) [DEFAULT]
    --preset ultra      Ultra quality (1440p, 20fps)
    --preset max        Maximum quality (4K, 24fps)
    --ai | --ai-smart    Enable comprehensive AI analysis (all modes)
    --ai-mode MODE       AI analysis mode: smart|content|motion|quality
    --ai-content         Focus on content type detection and optimization
    --ai-motion          Focus on motion analysis and frame rate optimization
    --ai-quality         Focus on source quality analysis and preservation
    --ai-confidence N    AI confidence threshold (0-100, default: 70)

${YELLOW}ADVANCED OPTIONS:${NC}
    --resolution WxH    Custom resolution (e.g., 1920x1080)
    --fps N             Frame rate (1-60)
    --quality MODE      Quality mode: low|medium|high|ultra|max
    --aspect RATIO      Aspect ratio: original|16:9|4:3|1:1|21:9
    --scaling ALGO      Scaling: bilinear|bicubic|lanczos|neighbor
    --palette MODE      Palette: auto|custom|web|grayscale
    --colors N          Max colors (16-256)
    --dither MODE       Dithering: none|floyd|bayer|sierra
    --jobs N            Parallel processing jobs (1-16)
    --single-threaded   Disable parallel processing (use only 1 job)
    --parallel-jobs N   Set number of concurrent conversion jobs
    --threads N         FFmpeg thread count (auto-detected by default)
    --gpu-enable        Force enable GPU acceleration
    --gpu-disable       Disable GPU acceleration (CPU only)
    --format FORMAT     Output: gif|webp|apng
    --force             Force re-conversion of existing files
    --backup            Backup original files
    --optimize          Auto-optimize output files
    --optimize-aggressive    Aggressive optimization (try multiple strategies)
    --optimize-conservative  Conservative optimization (basic only)
    --optimize-target N      Target size ratio (default: 20% of original)
    --aggressive-optimization   Ultra-aggressive: 15MB limit, 15% target ratio
    --conservative-optimization Conservative: 75MB limit, 50% target ratio
    --enable-smart-sizing    Enable intelligent size reduction (default: on)
    --disable-smart-sizing   Disable automatic size optimization
    --disable-size-optimization  Disable all size optimizations
    --silent            Minimal output
    --verbose           Detailed logging
    --no-progress       Disable progress bars
    --debug             Enable debug mode with detailed error info
    --max-retries N     Maximum retry attempts (default: 2)
    --interactive|-i        Interactive mode with selection menus
    --kill-ffmpeg           Kill all running ffmpeg processes
    --stop-all              Stop all ffmpeg processes and exit immediately
    --skip-validation       Skip output validation for faster processing
    --show-settings         Show current settings and their saved location
    --show-progress         Show current conversion progress from autosave
    --clear-progress        Clear saved progress (start fresh)
    --test-termination      Test process group termination system
    --dynamic-detection     Monitor for new video files during conversion
    --monitor-files         Same as --dynamic-detection
    --monitor-interval N    File monitoring check interval in seconds (default: 10)
    --no-dynamic-detection  Disable dynamic file monitoring
    --no-monitor            Same as --no-dynamic-detection

${YELLOW}SMART FEATURES:${NC}
    --auto-detect       Auto-detect optimal settings per video
    --ai-status         Show AI cache, training, and health diagnostics
    --ai-stats          Same as --ai-status
    --clean-cache       Clean cache: remove duplicates and deleted files
    --batch-optimize    Optimize all files after conversion
    --size-limit MB     Target file size limit
    --duration-limit S  Maximum GIF duration (clips longer videos)
    --smart-crop        Intelligent cropping for better composition
    --denoise           Apply noise reduction
    --stabilize         Video stabilization
    --enhance           Color/contrast enhancement

${YELLOW}ERROR HANDLING:${NC}
    --debug             Show detailed error information
    --max-retries N     Set maximum retry attempts per file
    Automatic features: Input validation, retry logic, cleanup on exit
    Logs saved to: ~/.smart-gif-converter/ (errors.log & conversions.log)

${YELLOW}CONFIGURATION:${NC}
    --config FILE       Use custom config file
    --save-config       Save current settings as default
    --reset-config      Reset to factory defaults
    --show-config       Display current configuration
    --show-settings     Show current settings and their saved location
    --debug-settings    Detailed settings diagnostics and troubleshooting
    --check-permissions Check and fix file/directory permissions
    --fix-permissions   Same as --check-permissions
    --file FILE         Convert only the specified video file (path or name)
    --show-logs         Show log directory and file information
    --check-cache       Check validation cache integrity and status
    --validate-cache    Same as --check-cache
    --clear-cache       Clear validation cache (creates backup)
    
${YELLOW}SETTINGS PERSISTENCE:${NC}
    The script automatically remembers your settings!
    â€¢ Settings are saved to: ~/.smart-gif-converter/settings.conf
    â€¢ Any changes via command line or interactive mode are auto-saved
    â€¢ Settings persist between runs - no need to set them again

${YELLOW}EXAMPLES:${NC}
    $0 --interactive                    # Interactive mode with menus
    $0 --preset ultra --aspect 16:9     # Command line mode
    $0 -i --auto-detect                 # Interactive + auto-detect
    $0 --resolution 1280x720 --fps 10   # Custom settings

EOF
}

# ðŸ”§ Load configuration and settings
load_config() {
    # First try to load saved settings from log directory
    if load_settings 2>/dev/null; then
        # Check if settings file needs upgrade (missing notification settings or intervals)
        # Count how many notification settings exist
        local notify_count=$(grep "^NOTIFY_" "$SETTINGS_FILE" 2>/dev/null | wc -l | tr -d ' ')
        [[ -z "$notify_count" ]] && notify_count=0
        
        # We should have 10 NOTIFY_ settings total
        if [[ $notify_count -lt 10 ]]; then
            echo -e "${YELLOW}ðŸ”„ Upgrading settings file with notification options... ($notify_count/10 found)${NC}"
            save_settings --silent
            echo -e "${GREEN}âœ“ Settings upgraded successfully! All notification options now available.${NC}"
            sleep 2
        fi
        return 0
    fi
    
    # Fallback to old config file
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        echo -e "${GREEN}âœ“ Loaded configuration from $CONFIG_FILE${NC}"
        # Migrate to new settings format
        save_settings --silent
        return 0
    fi
    
    echo -e "${YELLOW}â„¹ï¸ Using default settings (will be saved after first use)${NC}"
    # Save defaults for first-time users
    save_settings --silent
    return 1
}

# ðŸ’¾ Save settings to log directory
save_settings() {
    # Properly handle flags and output path so we never write to a file named "--silent"
    local silent=false
    local settings_file="$SETTINGS_FILE"

    # Support optional "--silent" flag as first arg
    if [[ "$1" == "--silent" ]]; then
        silent=true
        shift
    fi
    # Optional explicit output path (rare; used by legacy save_config)
    if [[ -n "$1" ]]; then
        settings_file="$1"
    fi
    
    cat > "$settings_file" << EOF
# Smart GIF Converter Settings - Auto-saved $(date)
# This file remembers your last used settings
RESOLUTION="$RESOLUTION"
FRAMERATE="$FRAMERATE"
QUALITY="$QUALITY"
ASPECT_RATIO="$ASPECT_RATIO"
SCALING_ALGO="$SCALING_ALGO"
DITHER_MODE="$DITHER_MODE"
MAX_COLORS="$MAX_COLORS"
PALETTE_MODE="$PALETTE_MODE"
PARALLEL_JOBS="$PARALLEL_JOBS"
OUTPUT_FORMAT="$OUTPUT_FORMAT"
AUTO_OPTIMIZE="$AUTO_OPTIMIZE"
OPTIMIZE_AGGRESSIVE="$OPTIMIZE_AGGRESSIVE"
OPTIMIZE_TARGET_RATIO="$OPTIMIZE_TARGET_RATIO"
BACKUP_ORIGINAL="$BACKUP_ORIGINAL"
SKIP_VALIDATION="$SKIP_VALIDATION"
PROGRESS_BAR="$PROGRESS_BAR"
FORCE_CONVERSION="$FORCE_CONVERSION"
DEBUG_MODE="$DEBUG_MODE"
MAX_RETRIES="$MAX_RETRIES"
AI_ENABLED="$AI_ENABLED"
AI_MODE="$AI_MODE"
AI_CONFIDENCE_THRESHOLD="$AI_CONFIDENCE_THRESHOLD"
CONTENT_TYPE_PREFERENCE="$CONTENT_TYPE_PREFERENCE"
AI_AUTO_QUALITY="$AI_AUTO_QUALITY"
AI_SCENE_ANALYSIS="$AI_SCENE_ANALYSIS"
AI_VISUAL_SIMILARITY="$AI_VISUAL_SIMILARITY"
AI_SMART_CROP="$AI_SMART_CROP"
AI_DYNAMIC_FRAMERATE="$AI_DYNAMIC_FRAMERATE"
AI_QUALITY_SCALING="$AI_QUALITY_SCALING"
AI_CONTENT_FINGERPRINT="$AI_CONTENT_FINGERPRINT"
AI_DISCOVERY_ENABLED="$AI_DISCOVERY_ENABLED"
AI_DISCOVERY_AUTO_SELECT="$AI_DISCOVERY_AUTO_SELECT"
AI_DISCOVERY_REMEMBER_CHOICE="$AI_DISCOVERY_REMEMBER_CHOICE"
AI_CACHE_ENABLED="$AI_CACHE_ENABLED"
AI_CACHE_MAX_AGE_DAYS="$AI_CACHE_MAX_AGE_DAYS"
AI_TRAINING_ENABLED="$AI_TRAINING_ENABLED"
AI_GENERATION="$AI_GENERATION"
AI_LEARNING_RATE="$AI_LEARNING_RATE"
AI_CONFIDENCE_MIN="$AI_CONFIDENCE_MIN"
AI_TRAINING_MIN_SAMPLES="$AI_TRAINING_MIN_SAMPLES"
MAX_GIF_SIZE_MB="$MAX_GIF_SIZE_MB"
AUTO_REDUCE_QUALITY="$AUTO_REDUCE_QUALITY"
SMART_SIZE_DOWN="$SMART_SIZE_DOWN"
GPU_ACCELERATION="$GPU_ACCELERATION"
FFMPEG_THREADS="$FFMPEG_THREADS"
PARALLEL_JOBS="$PARALLEL_JOBS"
OUTPUT_DIRECTORY="$OUTPUT_DIRECTORY"
OUTPUT_DIR_MODE="$OUTPUT_DIR_MODE"
NOTIFY_ENABLED="$NOTIFY_ENABLED"
NOTIFY_SESSION_START="$NOTIFY_SESSION_START"
NOTIFY_SESSION_FOUND="$NOTIFY_SESSION_FOUND"
NOTIFY_CONVERSION_COMPLETE="$NOTIFY_CONVERSION_COMPLETE"
NOTIFY_CONVERSION_PROGRESS="$NOTIFY_CONVERSION_PROGRESS"
NOTIFY_PROGRESS_INTERVAL="$NOTIFY_PROGRESS_INTERVAL"
NOTIFY_ERROR="$NOTIFY_ERROR"
NOTIFY_REMINDER_ENABLED="$NOTIFY_REMINDER_ENABLED"
NOTIFY_REMINDER_INTERVAL="$NOTIFY_REMINDER_INTERVAL"
NOTIFY_TERMINAL_CLOSED="$NOTIFY_TERMINAL_CLOSED"
EOF
    
    if [[ "$silent" != true ]]; then
        echo -e "${GREEN}ðŸ’¾ Settings saved to $settings_file${NC}"
    fi
}

# ðŸ“ Load settings from log directory
load_settings() {
    local settings_file="${1:-$SETTINGS_FILE}"
    
    if [[ -f "$settings_file" ]]; then
        # Source the settings file safely
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ $key =~ ^[[:space:]]*# ]] && continue
            [[ -z $key ]] && continue
            
            # Remove quotes from value
            value=$(echo "$value" | sed 's/^"\|"$//g')
            
            # Set the variable
            case "$key" in
                RESOLUTION) RESOLUTION="$value" ;;
                FRAMERATE) FRAMERATE="$value" ;;
                QUALITY) QUALITY="$value" ;;
                ASPECT_RATIO) ASPECT_RATIO="$value" ;;
                SCALING_ALGO) SCALING_ALGO="$value" ;;
                DITHER_MODE) DITHER_MODE="$value" ;;
                MAX_COLORS) MAX_COLORS="$value" ;;
                PALETTE_MODE) PALETTE_MODE="$value" ;;
                PARALLEL_JOBS) PARALLEL_JOBS="$value" ;;
                OUTPUT_FORMAT) OUTPUT_FORMAT="$value" ;;
                AUTO_OPTIMIZE) AUTO_OPTIMIZE="$value" ;;
                OPTIMIZE_AGGRESSIVE) OPTIMIZE_AGGRESSIVE="$value" ;;
                OPTIMIZE_TARGET_RATIO) OPTIMIZE_TARGET_RATIO="$value" ;;
                BACKUP_ORIGINAL) BACKUP_ORIGINAL="$value" ;;
                SKIP_VALIDATION) SKIP_VALIDATION="$value" ;;
                PROGRESS_BAR) PROGRESS_BAR="$value" ;;
                FORCE_CONVERSION) FORCE_CONVERSION="$value" ;;
                DEBUG_MODE) DEBUG_MODE="$value" ;;
                MAX_RETRIES) MAX_RETRIES="$value" ;;
                AI_ENABLED) AI_ENABLED="$value" ;;
                AI_MODE) AI_MODE="$value" ;;
                AI_CONFIDENCE_THRESHOLD) AI_CONFIDENCE_THRESHOLD="$value" ;;
                CONTENT_TYPE_PREFERENCE) CONTENT_TYPE_PREFERENCE="$value" ;;
                AI_AUTO_QUALITY) AI_AUTO_QUALITY="$value" ;;
                AI_SCENE_ANALYSIS) AI_SCENE_ANALYSIS="$value" ;;
                AI_VISUAL_SIMILARITY) AI_VISUAL_SIMILARITY="$value" ;;
                AI_SMART_CROP) AI_SMART_CROP="$value" ;;
                AI_DYNAMIC_FRAMERATE) AI_DYNAMIC_FRAMERATE="$value" ;;
                AI_QUALITY_SCALING) AI_QUALITY_SCALING="$value" ;;
                AI_CONTENT_FINGERPRINT) AI_CONTENT_FINGERPRINT="$value" ;;
                AI_DISCOVERY_ENABLED) AI_DISCOVERY_ENABLED="$value" ;;
                AI_DISCOVERY_AUTO_SELECT) AI_DISCOVERY_AUTO_SELECT="$value" ;;
                AI_DISCOVERY_REMEMBER_CHOICE) AI_DISCOVERY_REMEMBER_CHOICE="$value" ;;
                AI_CACHE_ENABLED) AI_CACHE_ENABLED="$value" ;;
                AI_CACHE_MAX_AGE_DAYS) AI_CACHE_MAX_AGE_DAYS="$value" ;;
                AI_TRAINING_ENABLED) AI_TRAINING_ENABLED="$value" ;;
                AI_GENERATION) AI_GENERATION="$value" ;;
                AI_LEARNING_RATE) AI_LEARNING_RATE="$value" ;;
                AI_CONFIDENCE_MIN) AI_CONFIDENCE_MIN="$value" ;;
                AI_TRAINING_MIN_SAMPLES) AI_TRAINING_MIN_SAMPLES="$value" ;;
                OUTPUT_DIRECTORY) OUTPUT_DIRECTORY="$value" ;;
                OUTPUT_DIR_MODE) OUTPUT_DIR_MODE="$value" ;;
                FFMPEG_THREADS) FFMPEG_THREADS="$value" ;;
                NOTIFY_ENABLED) NOTIFY_ENABLED="$value" ;;
                NOTIFY_SESSION_START) NOTIFY_SESSION_START="$value" ;;
                NOTIFY_SESSION_FOUND) NOTIFY_SESSION_FOUND="$value" ;;
                NOTIFY_CONVERSION_COMPLETE) NOTIFY_CONVERSION_COMPLETE="$value" ;;
                NOTIFY_CONVERSION_PROGRESS) NOTIFY_CONVERSION_PROGRESS="$value" ;;
                NOTIFY_PROGRESS_INTERVAL) NOTIFY_PROGRESS_INTERVAL="$value" ;;
                NOTIFY_ERROR) NOTIFY_ERROR="$value" ;;
                NOTIFY_REMINDER_ENABLED) NOTIFY_REMINDER_ENABLED="$value" ;;
                NOTIFY_REMINDER_INTERVAL) NOTIFY_REMINDER_INTERVAL="$value" ;;
                NOTIFY_TERMINAL_CLOSED) NOTIFY_TERMINAL_CLOSED="$value" ;;
            esac
        done < "$settings_file"
        
        echo -e "${GREEN}ðŸ“ Loaded saved settings from $settings_file${NC}"
        return 0
    fi
    return 1
}

# ðŸ’¾ Save configuration (legacy function for backward compatibility)
save_config() {
    save_settings
}

# ðŸ“ Interactive aspect ratio selection
select_aspect_ratio() {
    echo -e "\n${CYAN}${BOLD}ðŸ“ SELECT ASPECT RATIO:${NC}"
    echo -e "${YELLOW}Choose your preferred aspect ratio:${NC}\n"
    
    local options=(
        "16:9 (Widescreen - Most common, YouTube standard)"
        "4:3 (Classic TV/Monitor format)"
        "1:1 (Square - Instagram/Social media)"
        "21:9 (Ultra-wide cinematic)"
        "9:16 (Vertical - Mobile/TikTok)"
        "Original (Keep source aspect ratio)"
    )
    
    local aspect_values=("16:9" "4:3" "1:1" "21:9" "9:16" "original")
    
    for i in "${!options[@]}"; do
        local num=$((i + 1))
        if [[ "${aspect_values[$i]}" == "$ASPECT_RATIO" ]]; then
            echo -e "  ${GREEN}[$num] âœ“ ${options[$i]}${NC} ${BOLD}(Current)${NC}"
        else
            echo -e "  ${BLUE}[$num]${NC}   ${options[$i]}"
        fi
    done
    
    echo -e "\n${MAGENTA}Enter your choice [1-${#options[@]}] or press Enter for current (${ASPECT_RATIO}): ${NC}"
    read -r choice
    
    if [[ -z "$choice" ]]; then
        echo -e "${GREEN}âœ“ Using current aspect ratio: $ASPECT_RATIO${NC}"
        return
    fi
    
    if [[ "$choice" =~ ^[1-6]$ ]]; then
        local index=$((choice - 1))
        ASPECT_RATIO="${aspect_values[$index]}"
        echo -e "${GREEN}âœ“ Selected aspect ratio: $ASPECT_RATIO${NC}"
        
        # Auto-save settings when aspect ratio changes
        if [[ -n "$SETTINGS_FILE" ]]; then
            save_settings --silent
        fi
    else
        echo -e "${RED}âŒ Invalid choice. Using current: $ASPECT_RATIO${NC}"
    fi
}

# ðŸŽ›ï¸ Interactive quality preset selection
select_quality_preset() {
    echo -e "\n${CYAN}${BOLD}âš™ï¸ SELECT QUALITY PRESET:${NC}"
    echo -e "${YELLOW}Choose your preferred quality level:${NC}\n"
    
    local presets=(
        "Low (480p, 8fps) - Small files, fast processing"
        "Medium (720p, 12fps) - Balanced quality and size"
        "High (1080p, 15fps) - Great quality, standard choice"
        "Ultra (1440p, 20fps) - Excellent quality, larger files"
        "Max (4K, 24fps) - Maximum quality, very large files"
    )
    
    local preset_values=("low" "medium" "high" "ultra" "max")
    
    for i in "${!presets[@]}"; do
        local num=$((i + 1))
        if [[ "${preset_values[$i]}" == "$QUALITY" ]]; then
            echo -e "  ${GREEN}[$num] âœ“ ${presets[$i]}${NC} ${BOLD}(Current)${NC}"
        else
            echo -e "  ${BLUE}[$num]${NC}   ${presets[$i]}"
        fi
    done
    
    echo -e "\n${MAGENTA}Enter your choice [1-${#presets[@]}] or press Enter for current ($QUALITY): ${NC}"
    read -r choice
    
    if [[ -z "$choice" ]]; then
        echo -e "${GREEN}âœ“ Using current quality: $QUALITY${NC}"
        return
    fi
    
    if [[ "$choice" =~ ^[1-5]$ ]]; then
        local index=$((choice - 1))
        apply_preset "${preset_values[$index]}"
        echo -e "${GREEN}âœ“ Selected quality: $QUALITY (${RESOLUTION}, ${FRAMERATE}fps)${NC}"
        
        # Settings are auto-saved by apply_preset function
    else
        echo -e "${RED}âŒ Invalid choice. Using current: $QUALITY${NC}"
    fi
}

# ðŸ“Š Enhanced overall progress bar with animations
show_progress() {
    local current=$1
    local total=$2
    local filename="$3"
    local status="$4"

    # Guard against zero/invalid totals
    if [[ -z "$total" || "$total" -le 0 ]]; then total=1; fi
    if [[ -z "$current" || "$current" -lt 0 ]]; then current=0; fi
    if [[ "$current" -gt "$total" ]]; then current=$total; fi

    # Compute percentage with rounding and filled length for a 50-char bar
    local percent_str=$(awk -v c="$current" -v t="$total" 'BEGIN { printf("%.1f", (c*100.0)/t) }')
    local filled=$(awk -v p="${percent_str}" 'BEGIN { printf("%d", (p*50/100)+0.5) }')
    if [[ "$filled" -gt 50 ]]; then filled=50; fi
    local empty=$((50 - filled))

    # Choose ASCII if terminal likely can't render Unicode blocks
    local use_unicode=1
    if locale 2>/dev/null | grep -qi -E "LC_CTYPE=.*(C|POSIX)"; then use_unicode=0; fi
    if [[ -n "$PROGRESS_ASCII" && "$PROGRESS_ASCII" == "true" ]]; then use_unicode=0; fi

    local ch_done="#"; local ch_rem="."
    if [[ $use_unicode -eq 1 ]]; then ch_done="â–ˆ"; ch_rem="â–‘"; fi

    printf "\r\033[K${CYAN}${BOLD}Overall Progress:${NC} ${BLUE}["
    for ((i=0; i<filled; i++)); do printf "%s" "$ch_done"; done
    for ((i=0; i<empty; i++)); do printf "%s" "$ch_rem"; done
    printf "${BLUE}]${NC} ${MAGENTA}${BOLD}%s%%%s ${CYAN}(%d/%d)${NC}" "$percent_str" "$NC" "$current" "$total"

    if [[ -n "$filename" ]]; then
        echo ""
        local truncated_name=$(basename -- "$filename")
        if [[ ${#truncated_name} -gt 50 ]]; then
            truncated_name="${truncated_name:0:47}..."
        fi
        printf "  ${BLUE}âž¤${NC} ${YELLOW}%s:${NC} ${BOLD}%s${NC}" "$status" "$truncated_name"
    fi
}

# ðŸ“ˆ Show conversion progress for individual files
show_file_progress() {
    local step="$1"
    local total_steps=3
    local description="$2"
    local percent=$((step * 100 / total_steps))
    local filled=$((percent / 5))
    local empty=$((20 - filled))
    
    printf "\r  ${MAGENTA}File: ["
    printf "%${filled}s" | tr ' ' 'â–ˆ'
    printf "%${empty}s" | tr ' ' 'â–’'
    printf "] %d%% ${CYAN}%s${NC}" $percent "$description"
}

# ðŸŒ¨ Build video filter chain
build_filter_chain() {
    local file="$1"
    local filters="fps=${FRAMERATE}"
    
    # Aspect ratio handling
    case "$ASPECT_RATIO" in
        "16:9")
            filters+=",scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "4:3")
            local w=$(echo $RESOLUTION | cut -d: -f1)
            local h=$((w * 3 / 4))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "1:1")
            local size=$(echo $RESOLUTION | cut -d: -f1)
            filters+=",scale=${size}:${size}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${size}:${size}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "21:9")
            local w=$(echo $RESOLUTION | cut -d: -f1)
            local h=$((w * 9 / 21))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "9:16")
            local h=$(echo $RESOLUTION | cut -d: -f2)
            local w=$((h * 9 / 16))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "original")
            filters+=",scale=${RESOLUTION}:flags=${SCALING_ALGO}"
            ;;
        *)
            filters+=",scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
    esac
    
    # Add palette generation
    case "$PALETTE_MODE" in
        "custom")
            filters+=",palettegen=max_colors=${MAX_COLORS}:reserve_transparent=0"
            ;;
        "web")
            filters+=",palettegen=max_colors=216:reserve_transparent=0"
            ;;
        "grayscale")
            filters+=",colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3,palettegen=max_colors=${MAX_COLORS}"
            ;;
    esac
    
    echo "$filters"
}

# ðŸŽ¯ Main conversion function with error handling
convert_video() {
    # Temporarily disable exit-on-error for this function
    set +e
    
    local file="$1"
    local base_name="$(basename -- "${file%.*}")"
    
    # Ensure output directory exists
    if [[ ! -d "$OUTPUT_DIRECTORY" ]]; then
        mkdir -p "$OUTPUT_DIRECTORY" 2>/dev/null || {
            log_error "Cannot create output directory" "$OUTPUT_DIRECTORY" "Permission denied or invalid path" "${BASH_LINENO[0]}" "convert_video"
            echo -e "\n${RED}âŒ Error: Cannot create output directory: $OUTPUT_DIRECTORY${NC}"
            return 1
        }
    fi
    
    # Build output file path in OUTPUT_DIRECTORY
    # Get absolute path for clarity
    local abs_output_dir="$(cd "$OUTPUT_DIRECTORY" 2>/dev/null && pwd || realpath -m "$OUTPUT_DIRECTORY" 2>/dev/null || echo "$OUTPUT_DIRECTORY")"
    local output_file="$OUTPUT_DIRECTORY/$base_name.${OUTPUT_FORMAT}"
    local palette_file="${file%.*}_palette.png"
    local retry_count=0
    local conversion_success=false
    
    # LOG: Show where file will be saved
    echo -e "  ${BLUE}ðŸ’¾ Output destination: ${CYAN}$abs_output_dir/${NC}"
    echo -e "  ${GRAY}ðŸ“‚ Full path: $abs_output_dir/$base_name.${OUTPUT_FORMAT}${NC}"
    
    # Validate input file
    if [[ ! -f "$file" ]]; then
        log_error "Input file does not exist" "$file"
        echo -e "\n${RED}âŒ Error: File '$file' not found${NC}"
        ((failed_files++))
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log_error "Cannot read input file (permission denied)" "$file"
        echo -e "\n${RED}âŒ Error: Cannot read file '$file' (permission denied)${NC}"
        ((failed_files++))
        return 1
    fi
    
    # Check if file is actually a video
    if ! ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_type -of csv=p=0 -- "$file" 2>/dev/null | grep -q "video"; then
        log_error "File is not a valid video" "$file"
        echo -e "\n${RED}âŒ Error: '$file' is not a valid video file${NC}"
        ((failed_files++))
        return 1
    fi
    
    # Skip if file exists and is newer (unless force mode)
    if [[ -f "$output_file" && "$output_file" -nt "$file" && "$FORCE_CONVERSION" != true ]]; then
        echo -e "\n${YELLOW}â­ï¸  Skipping: $(basename -- "$file") (already converted)${NC}"
        log_conversion "SKIPPED" "$file" "$output_file" "(already exists)"
        ((skipped_files++))
        return 0
    fi
    
    echo ""
    echo -e "${GREEN}âœ¨ Converting: ${BOLD}$(basename -- "$file")${NC}"
    
    # Auto-detect settings if enabled
    if [[ "$AUTO_DETECT" == true ]]; then
        auto_detect_settings "$file"
    fi
    
    # Smart GIF size estimation and optimization (always enabled)
    estimate_and_optimize_gif_settings "$file"
    
    # Backup original if requested (only on first attempt)
    if [[ "$BACKUP_ORIGINAL" == true ]]; then
        if ! cp "$file" "${file}.backup" 2>/dev/null; then
            log_error "Failed to create backup" "$file"
            echo -e "  ${YELLOW}âš ï¸  Warning: Could not create backup${NC}"
        fi
    fi
    
    # Step 1: Generate palette
    show_file_progress 1 "Analyzing video & generating palette..."
    local filter_chain=$(build_filter_chain "$file")
    
    if ! ffmpeg -i -- "$file" -vf "$filter_chain" -y -- "$palette_file" -loglevel error 2>/dev/null; then
        log_error "Failed to generate palette" "$file"
        echo -e "\n  ${RED}âŒ Failed to generate palette${NC}"
        cleanup_temp_files "${file%.*}"
        ((failed_files++))
        return 1
    fi
    
    # Step 2: Convert to GIF with palette
    show_file_progress 2 "Converting with ${QUALITY} quality settings..."
    # Fix dithering mode for FFmpeg paletteuse filter
    local dither_option=""
    case "$DITHER_MODE" in
        "floyd") dither_option="dither=floyd_steinberg" ;;
        "bayer") dither_option="dither=bayer:bayer_scale=3" ;;
        "none") dither_option="dither=none" ;;
        *) dither_option="dither=bayer:bayer_scale=3" ;;  # default
    esac
    
    local conversion_filter="fps=${FRAMERATE},scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black[x];[x][1:v]paletteuse=$dither_option"
    
    if ! ffmpeg -i -- "$file" -i -- "$palette_file" -lavfi "$conversion_filter" -y -- "$output_file" -loglevel error 2>/dev/null; then
        log_error "Failed to convert to GIF" "$file"
        echo -e "\n  ${RED}âŒ Conversion failed${NC}"
        cleanup_temp_files "${file%.*}"
        ((failed_files++))
        return 1
    fi
    
    # Step 3: Post-processing and optimization
    show_file_progress 3 "Finalizing and optimizing..."
    
    # Verify output file was created and has content
    if [[ ! -f "$output_file" ]]; then
        log_error "Output file was not created" "$file"
        echo -e "\n  ${RED}âŒ Error: Output file was not created${NC}"
        cleanup_temp_files "${file%.*}"
        ((failed_files++))
        return 1
    fi
    
    local file_size=$(stat -c%s -- "$output_file" 2>/dev/null || echo "0")
    if [[ $file_size -eq 0 ]]; then
        log_error "Output file is empty" "$file"
        echo -e "\n  ${RED}âŒ Error: Output file is empty${NC}"
        rm -f "$output_file"
        cleanup_temp_files "${file%.*}"
        ((failed_files++))
        return 1
    fi
    
    # Show file size comparison
    local original_size=$(stat -c%s -- "$file" 2>/dev/null || echo "0")
    local converted_size=$file_size
    local ratio_pct_str=$(compute_ratio_percent "$converted_size" "$original_size")
    
    # Auto-optimize if enabled
    if [[ "$AUTO_OPTIMIZE" == true && "$OUTPUT_FORMAT" == "gif" ]]; then
        if command -v gifsicle >/dev/null 2>&1; then
            if ! gifsicle -O3 "$output_file" -o "${output_file}.tmp" 2>/dev/null; then
                log_error "GIF optimization failed, using unoptimized version" "$file"
                echo -e "  ${YELLOW}âš ï¸  Warning: Optimization failed, using unoptimized GIF${NC}"
            else
                mv "${output_file}.tmp" "$output_file" 2>/dev/null
            fi
        fi
    fi
    
    printf "\r  ${GREEN}âœ“ Completed: ${BOLD}$(basename \"$output_file\")${NC} ${MAGENTA}($(numfmt --to=iec $converted_size) - ${ratio_pct_str})${NC}\n"
    
    # Log successful conversion
    log_conversion "SUCCESS" "$file" "$output_file" "($(numfmt --to=iec $converted_size) - ${ratio_pct_str})"
    
    ((converted_files++))
    
    # Always cleanup temporary files
    cleanup_temp_files "${file%.*}"
    
    # Re-enable exit-on-error
    set -e
}

# ðŸ“¥ Show final statistics
show_statistics() {
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    
    echo ""
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}${BOLD}                        ðŸ“Š STATISTICS                         ${NC}"
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}${BOLD} ${GREEN}âœ“ Converted:${NC} %-10s ${YELLOW}â­ Skipped:${NC} %-10s ${RED}âŒ Failed:${NC} %-6s ${CYAN}${BOLD} ${NC}" "$converted_files" "$skipped_files" "$failed_files"
    echo -e "${CYAN}${BOLD} ${BLUE}ðŸ“ Total files:${NC} %-8s ${MAGENTA}â± Duration:${NC} %02d:%02d:%02d                ${CYAN}${BOLD} ${NC}" "$total_files" "$hours" "$minutes" "$seconds"
    echo -e "${CYAN}${BOLD} ${YELLOW}âš™ Quality:${NC} %-12s ${BLUE}ðŸ“ Resolution:${NC} %-12s        ${CYAN}${BOLD} ${NC}" "$QUALITY" "$RESOLUTION"
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# ðŸŽšï¸ Apply quality preset
apply_preset() {
    case "$1" in
        "low")
            RESOLUTION="854:480"
            FRAMERATE="8"
            MAX_COLORS="128"
            SCALING_ALGO="bilinear"
            ;;
        "medium")
            RESOLUTION="1280:720"
            FRAMERATE="12"
            MAX_COLORS="192"
            SCALING_ALGO="bicubic"
            ;;
        "high")
            RESOLUTION="1920:1080"
            FRAMERATE="15"
            MAX_COLORS="256"
            SCALING_ALGO="lanczos"
            ;;
        "ultra")
            RESOLUTION="2560:1440"
            FRAMERATE="20"
            MAX_COLORS="256"
            SCALING_ALGO="lanczos"
            ;;
        "max")
            RESOLUTION="3840:2160"
            FRAMERATE="24"
            MAX_COLORS="256"
            SCALING_ALGO="lanczos"
            ;;
    esac
    QUALITY="$1"
    
    # Auto-save settings when preset changes
    if [[ -n "$SETTINGS_FILE" ]]; then
        save_settings --silent
    fi
}

# ðŸ§  Auto-detect optimal settings based on input video
auto_detect_settings() {
    local file="$1"
    local info=$(ffprobe -v quiet -print-format json -show_format -show_streams -- "$file" 2>/dev/null)
    
    if [[ $? -eq 0 ]]; then
        local width=$(echo "$info" | jq -r '.streams[0].width // empty')
        local height=$(echo "$info" | jq -r '.streams[0].height // empty')
        local duration=$(echo "$info" | jq -r '.format.duration // empty' | cut -d. -f1)
        local bitrate=$(echo "$info" | jq -r '.format.bit_rate // empty')
        
        # Auto-adjust resolution based on source
        if [[ -n "$width" && -n "$height" ]]; then
            if (( width * height > 3686400 )); then  # > 1080p
                apply_preset "ultra"
            elif (( width * height > 2073600 )); then  # > 720p
                apply_preset "high"
            elif (( width * height > 921600 )); then   # > 480p
                apply_preset "medium"
            else
                apply_preset "low"
            fi
        fi
        
        # Adjust framerate for long videos
        if [[ -n "$duration" && $duration -gt 30 ]]; then
            FRAMERATE="10"
        elif [[ -n "$duration" && $duration -gt 60 ]]; then
            FRAMERATE="8"
        fi
        
        echo -e "${BLUE}ðŸ§  Auto-detected settings: ${QUALITY} quality, ${FRAMERATE}fps${NC}"
    fi
}

# ðŸŽ¨ Build video filter chain
build_filter_chain() {
    local file="$1"
    local filters="fps=${FRAMERATE}"
    
    # Simple scaling approach that works reliably
    case "$ASPECT_RATIO" in
        "16:9")
            filters+=",scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "4:3")
            local w=$(echo $RESOLUTION | cut -d: -f1)
            local h=$((w * 3 / 4))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "1:1")
            local size=$(echo $RESOLUTION | cut -d: -f1)
            filters+=",scale=${size}:${size}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${size}:${size}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "21:9")
            local w=$(echo $RESOLUTION | cut -d: -f1)
            local h=$((w * 9 / 21))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "9:16")
            local h=$(echo $RESOLUTION | cut -d: -f2)
            local w=$((h * 9 / 16))
            filters+=",scale=${w}:${h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
        "original")
            # Keep original proportions, only downscale if too large
            local max_w=$(echo $RESOLUTION | cut -d: -f1)
            local max_h=$(echo $RESOLUTION | cut -d: -f2)
            filters+=",scale=${max_w}:${max_h}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO}"
            ;;
        *)
            filters+=",scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black"
            ;;
    esac
    
    # Add palette generation
    case "$PALETTE_MODE" in
        "custom")
            filters+=",palettegen=max_colors=${MAX_COLORS}:reserve_transparent=0"
            ;;
        "web")
            filters+=",palettegen=max_colors=216:reserve_transparent=0"
            ;;
        "grayscale")
            filters+=",colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3,palettegen=max_colors=${MAX_COLORS}"
            ;;
    esac
    
    echo "$filters"
}

# ðŸ“Š Show overall progress bar
show_progress() {
    local current=$1
    local total=$2
    local filename="$3"
    local status="$4"
    
    # Guard against zero/invalid totals  
    if [[ -z "$total" || "$total" -le 0 ]]; then total=1; fi
    if [[ -z "$current" || "$current" -lt 0 ]]; then current=0; fi
    if [[ "$current" -gt "$total" ]]; then current=$total; fi
    
    local percent=$((current * 100 / total))
    local filled=$((percent / 2))
    local empty=$((50 - filled))
    
    # Clear line and show progress
    printf "\r\033[K${CYAN}Overall: ["
    for ((i=0; i<filled; i++)); do printf "â–“"; done
    for ((i=0; i<empty; i++)); do printf "â–‘"; done
    printf "] %d%% (%d/%d) ${YELLOW}%s${NC}" $percent $current $total "$status"
    
    # Show current file being processed
    if [[ -n "$filename" ]]; then
        echo ""
        printf "${BLUE}ðŸŽ¬ Processing: ${NC}%s" "$(basename -- "$filename")"
    fi
}

# ðŸ“ˆ Show conversion progress for individual files
show_file_progress() {
    local step="$1"
    local total_steps=3
    local description="$2"
    local percent=$((step * 100 / total_steps))
    local filled=$((percent / 5))
    local empty=$((20 - filled))
    
    printf "\r  ${MAGENTA}File: ["
    printf "%${filled}s" | tr ' ' 'â–ˆ'
    printf "%${empty}s" | tr ' ' 'â–’'
    printf "] %d%% ${CYAN}%s${NC}" $percent "$description"
}

# ðŸŒ€ Show animated spinner with enhanced visuals
show_spinner() {
    local pid=$1
    local description="$2"
    local spinchars="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local i=0
    local start_time=$(date +%s)
    
    while kill -0 $pid 2>/dev/null; do
        local char="${spinchars:$((i % ${#spinchars})):1}"
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        
        printf "\r  ${YELLOW}%s ${CYAN}%s ${GRAY}[%02d:%02d]${NC}" "$char" "$description" "$mins" "$secs"
        sleep 0.1
        ((i++))
    done
    
    local total_time=$(($(date +%s) - start_time))
    local total_mins=$((total_time / 60))
    local total_secs=$((total_time % 60))
    printf "\r  ${GREEN}âœ“ ${CYAN}%s ${GREEN}[%02d:%02d]${NC}\n" "$description" "$total_mins" "$total_secs"
}

# ðŸ“Š Live animated progress bar with ffmpeg progress parsing
show_live_progress() {
    local pid=$1
    local description="$2"
    local input_file="$3"
    local progress_file="/tmp/ffmpeg_progress_$$_$(date +%s).log"
    local start_time=$(date +%s)
    local total_duration=0
    
    # Get video duration for percentage calculation
    if [[ -n "$input_file" && -f "$input_file" ]]; then
        total_duration=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$input_file" 2>/dev/null | cut -d. -f1 || echo "0")
    fi
    
    local frame=0
    local spinchars="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    
    while kill -0 $pid 2>/dev/null; do
        local char="${spinchars:$((frame % ${#spinchars})):1}"
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        
        # Create animated progress bar
        local bar_width=30
        local filled=$((elapsed % bar_width))
        local progress_bar=""
        
        for ((i=0; i<bar_width; i++)); do
            if [[ $i -eq $filled ]]; then
                progress_bar+="${YELLOW}â–¶${NC}"
            elif [[ $i -lt $filled ]]; then
                progress_bar+="${GREEN}â–“${NC}"
            else
                progress_bar+="${GRAY}â–’${NC}"
            fi
        done
        
        printf "\r  ${char} ${CYAN}%s${NC} [%s] ${GRAY}%02d:%02d${NC}" "$description" "$progress_bar" "$mins" "$secs"
        sleep 0.15
        ((frame++))
    done
    
    local total_time=$(($(date +%s) - start_time))
    local total_mins=$((total_time / 60))
    local total_secs=$((total_time % 60))
    
    # Final completed progress bar
    local completed_bar=""
    for ((i=0; i<30; i++)); do
        completed_bar+="${GREEN}â–“${NC}"
    done
    
    printf "\r  ${GREEN}âœ“${NC} ${CYAN}%s${NC} [%s] ${GREEN}%02d:%02d${NC}\n" "$description" "$completed_bar" "$total_mins" "$total_secs"
    
    # Cleanup
    rm -f "$progress_file" 2>/dev/null
}

# ðŸŽ¬ Advanced ffmpeg progress with real-time stats
show_ffmpeg_progress() {
    local pid=$1
    local description="$2"
    local input_file="$3"
    local start_time=$(date +%s)
    local frame=0
    local last_fps=0
    
    # Animation characters for different stages
    local spinchars="ðŸŽ¬ðŸŽ¥ðŸŽžï¸ðŸŽªðŸŽ­ðŸŽ¨ðŸŽ¯ðŸŽ²ðŸŽ¸ðŸŽº"
    
    while kill -0 $pid 2>/dev/null; do
        local char="${spinchars:$((frame % ${#spinchars})):1}"
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))
        
        # Create pulsing progress bar
        local bar_width=25
        local pulse_pos=$((elapsed % (bar_width * 2)))
        if [[ $pulse_pos -gt $bar_width ]]; then
            pulse_pos=$((bar_width * 2 - pulse_pos))
        fi
        
        local progress_bar=""
        for ((i=0; i<bar_width; i++)); do
            if [[ $i -eq $pulse_pos ]]; then
                progress_bar+="${YELLOW}â—${NC}"
            elif [[ $((i - pulse_pos)) -le 2 && $((i - pulse_pos)) -ge -2 ]]; then
                progress_bar+="${BLUE}â–“${NC}"
            else
                progress_bar+="${GRAY}â–’${NC}"
            fi
        done
        
        # Show processing stats
        printf "\r  %s ${CYAN}%s${NC} [%s] ${MAGENTA}%02d:%02d${NC} ${YELLOW}Processing...${NC}" \
               "$char" "$description" "$progress_bar" "$mins" "$secs"
        
        sleep 0.2
        ((frame++))
    done
    
    local total_time=$(($(date +%s) - start_time))
    local total_mins=$((total_time / 60))
    local total_secs=$((total_time % 60))
    
    # Final success bar
    local success_bar=""
    for ((i=0; i<25; i++)); do
        success_bar+="${GREEN}â–ˆ${NC}"
    done
    
    printf "\r  ${GREEN}ðŸŽ‰${NC} ${CYAN}%s${NC} [%s] ${GREEN}%02d:%02d Complete!${NC}\n" \
           "$description" "$success_bar" "$total_mins" "$total_secs"
}

# ðŸŽ¯ Main conversion function with bulletproof error handling
convert_video() {
    local file="$1"
    trace_function "convert_video"
    
    # Input validation with detailed logging
    if [[ -z "$file" ]]; then
        log_error "No input file provided to convert_video" "" "" "${BASH_LINENO[0]}" "convert_video"
        return 1
    fi
    
    echo -e "${CYAN}âš™ï¸ Starting robust conversion for: $(basename -- "$file")${NC}"
    
    # Wrap the entire conversion in a try-catch like structure
    {
        _convert_video_internal "$file"
    } || {
        local exit_code=$?
        log_error "Conversion function failed" "$file" "Internal conversion failed with exit code $exit_code" "${BASH_LINENO[0]}" "convert_video"
        return $exit_code
    }
}

# Internal conversion function with all the logic
_convert_video_internal() {
    
    local file="$1"
    local base_name=$(basename -- "${file%.*}")
    
    # Ensure output directory exists
    if [[ ! -d "$OUTPUT_DIRECTORY" ]]; then
        mkdir -p "$OUTPUT_DIRECTORY" 2>/dev/null || {
            log_error "Cannot create output directory" "$OUTPUT_DIRECTORY" "Permission denied or invalid path" "${BASH_LINENO[0]}" "_convert_video_internal"
            echo -e "\n${RED}âŒ Error: Cannot create output directory: $OUTPUT_DIRECTORY${NC}"
            ((failed_files++))
            return 1
        }
    fi
    
    # Build output path using OUTPUT_DIRECTORY
    local final_output_file="$OUTPUT_DIRECTORY/$base_name.${OUTPUT_FORMAT}"
    
    # Skip if output file already exists (unless FORCE_CONVERSION is enabled)
    if [[ -f "$final_output_file" && "$FORCE_CONVERSION" != "true" ]]; then
        # Check if output is newer than input
        if [[ "$final_output_file" -nt "$file" ]]; then
            echo -e "\n${YELLOW}â­ï¸  Skipping: $(basename -- "$file") (already converted)${NC}"
            echo -e "  ${GRAY}ðŸ’¾ Output exists: $final_output_file${NC}"
            log_conversion "SKIPPED" "$file" "$final_output_file" "(already exists)"
            ((skipped_files++))
            return 0
        fi
    fi
    
    # Use RAM-optimized temp directory for all intermediate files
    local temp_palette_file=$(get_temp_file_path "${base_name}_palette" "png")
    local temp_output_file=$(get_temp_file_path "${base_name}_temp" "${OUTPUT_FORMAT}")
    local retry_count=0
    local conversion_success=false
    
    # Validate input file
    if [[ ! -f "$file" ]]; then
        log_error "Input file does not exist" "$file"
        echo -e "\n${RED}âŒ Error: File '$file' not found${NC}"
        ((failed_files++))
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log_error "Cannot read input file (permission denied)" "$file"
        echo -e "\n${RED}âŒ Error: Cannot read file '$file' (permission denied)${NC}"
        ((failed_files++))
        return 1
    fi
    
    # Check if file is actually a video
    if ! ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_type -of csv=p=0 -- "$file" 2>/dev/null | grep -q "video"; then
        log_error "File is not a valid video" "$file"
        echo -e "\n${RED}âŒ Error: '$file' is not a valid video file${NC}"
        ((failed_files++))
        return 1
    fi
    
    # Duplicate check is now handled upstream in start_conversion()
    # Files reaching this function are guaranteed to need conversion
    
    echo ""
    local media_brief=$(probe_media_brief "$file")
    echo -e "${GREEN}âœ¨ Converting: ${BOLD}$(basename \"$file\")${NC}"
    # Log concise media info
    { echo "[$(date '+%Y-%m-%d %H:%M:%S')] INPUT: $(basename \"$file\") info=${media_brief}"; } >> "$ERROR_LOG" 2>/dev/null || true
    
    # Retry loop for conversion
    while [[ $retry_count -le $MAX_RETRIES && $conversion_success == false ]]; do
        # Check for interrupt request at start of each retry
        if [[ "$INTERRUPT_REQUESTED" == true ]]; then
            # Clean up temp files
            cleanup_temp_files "${file%.*}"
            
            # Delete incomplete output GIF if it exists
            if [[ -f "$final_output_file" ]]; then
                local output_size=$(stat -c%s -- "$final_output_file" 2>/dev/null || echo "0")
                # If GIF is suspiciously small or was just created, delete it
                if [[ $output_size -lt 1000 ]] || [[ "$final_output_file" -nt "$file" ]]; then
                    rm -f "$final_output_file" 2>/dev/null
                    echo -e "  ${YELLOW}ðŸ§¹ Cleaned up incomplete: $(basename -- "$final_output_file")${NC}"
                fi
            fi
            
            # Silently stop without error messages
            return 130  # Standard exit code for SIGINT
        fi
        
        if [[ $retry_count -gt 0 ]]; then
            echo -e "  ${YELLOW}â™¾ï¸ Retry attempt $retry_count/$MAX_RETRIES${NC}"
            sleep 1
        fi
        
        # AI-lite: analyze content once per file (first attempt only)
        if [[ "$AI_ENABLED" == true && $retry_count -eq 0 ]]; then
            echo -e "  ${CYAN}ðŸ¤– AI: analyzing content for smart defaults...${NC}"
            echo -e "  ${BLUE}ðŸ¤– Using AI generation: ${BOLD}$AI_GENERATION${NC}"
            ai_smart_analyze "$file"
        fi
        
        # Clean up any previous attempt files
        cleanup_temp_files "${file%.*}"
        
        # Auto-detect settings if enabled
        if [[ "$AUTO_DETECT" == true ]]; then
            auto_detect_settings "$file"
        fi
        
        # Backup original if requested (only on first attempt)
        if [[ "$BACKUP_ORIGINAL" == true && $retry_count -eq 0 ]]; then
            if ! cp "$file" "${file}.backup" 2>/dev/null; then
                log_error "Failed to create backup" "$file"
                echo -e "  ${YELLOW}âš ï¸  Warning: Could not create backup${NC}"
            fi
        fi
        
        # Step 1: Generate palette
        local filter_chain=$(build_filter_chain "$file")
        
        # If AI suggested a crop, inject it before scaling
        if [[ -n "$CROP_FILTER" ]]; then
            # Insert crop right after fps, before scale
            if [[ "$filter_chain" == fps=* ]]; then
                # Use bash string manipulation instead of sed to avoid quoting issues
                local fps_part="${filter_chain%%,*}"
                local rest_part="${filter_chain#*,}"
                if [[ "$fps_part" == "$filter_chain" ]]; then
                    # No comma found, just fps filter
                    filter_chain="${fps_part},${CROP_FILTER}"
                else
                    # Has more filters after fps
                    filter_chain="${fps_part},${CROP_FILTER},${rest_part}"
                fi
            else
                filter_chain="$CROP_FILTER,$filter_chain"
            fi
        fi
        
        # Safe palette generation with comprehensive error handling
        local ffmpeg_error_file="${temp_palette_file}.error"
        
        # Run ffmpeg in foreground with progress monitoring
        echo -e "\033[2mðŸŽ¦ Starting palette generation (foreground)\033[0m"
        
        echo -e "  ðŸŽ¦ Analyzing video & generating palette..."
        
        # Keep signal handling active for interruption
        # trap '' INT TERM HUP PIPE ERR
        
        # Run ffmpeg (attempt ladder)
        local ffmpeg_exit_code=0
        local cmd1="env -i PATH=\"$PATH\" HOME=\"$HOME\" ffmpeg $FFMPEG_INPUT_OPTS -i \"$file\" -vf \"$filter_chain\" -threads $FFMPEG_THREADS $FFMPEG_MEMORY_OPTS -frames:v 1 -update 1 -y \"$temp_palette_file\" -loglevel error"
        local palette_start_ts=$(date +%s)
        ffmpeg_exit_code=$(run_ffmpeg_safely "$cmd1" "$ffmpeg_error_file" 25)
        local palette_end_ts=$(date +%s)
        local palette_elapsed=$((palette_end_ts - palette_start_ts))
        # Log attempt detail
        { echo "[$(date '+%Y-%m-%d %H:%M:%S')] PALETTE ATTEMPT #1 chain='$filter_chain' elapsed=${palette_elapsed}s"; } >> "$ERROR_LOG" 2>/dev/null || true
        
        # If failed, try simpler palettegen without pad/scale
        if [[ $ffmpeg_exit_code -ne 0 || ! -s "$temp_palette_file" ]]; then
            local simple_chain="fps=${FRAMERATE},palettegen=max_colors=${MAX_COLORS}:reserve_transparent=0"
            local cmd2="env -i PATH=\"$PATH\" HOME=\"$HOME\" ffmpeg $FFMPEG_INPUT_OPTS -i \"$file\" -vf \"$simple_chain\" -threads $FFMPEG_THREADS $FFMPEG_MEMORY_OPTS -frames:v 1 -update 1 -y \"$temp_palette_file\" -loglevel error"
            local palette_start_ts2=$(date +%s)
            ffmpeg_exit_code=$(run_ffmpeg_safely "$cmd2" "$ffmpeg_error_file" 20)
            local palette_end_ts2=$(date +%s)
            { echo "[$(date '+%Y-%m-%d %H:%M:%S')] PALETTE ATTEMPT #2 chain='$simple_chain' elapsed=$((palette_end_ts2 - palette_start_ts2))s"; } >> "$ERROR_LOG" 2>/dev/null || true
        fi
        
        # If still failed, try minimal palettegen
        if [[ $ffmpeg_exit_code -ne 0 || ! -s "$temp_palette_file" ]]; then
            local cmd3="env -i PATH=\"$PATH\" HOME=\"$HOME\" ffmpeg $FFMPEG_INPUT_OPTS -i \"$file\" -vf \"palettegen=max_colors=${MAX_COLORS}:reserve_transparent=0\" -threads $FFMPEG_THREADS $FFMPEG_MEMORY_OPTS -frames:v 1 -update 1 -y \"$temp_palette_file\" -loglevel error"
            local palette_start_ts3=$(date +%s)
            ffmpeg_exit_code=$(run_ffmpeg_safely "$cmd3" "$ffmpeg_error_file" 15)
            local palette_end_ts3=$(date +%s)
            { echo "[$(date '+%Y-%m-%d %H:%M:%S')] PALETTE ATTEMPT #3 chain='palettegen' elapsed=$((palette_end_ts3 - palette_start_ts3))s"; } >> "$ERROR_LOG" 2>/dev/null || true
        fi
        
        # Signal handling remains active throughout palette generation
        # (no need to re-enable since we didn't disable)
        
        # Check if palette generation was successful
        local palette_success=false
        if [[ $ffmpeg_exit_code -eq 0 && -f "$temp_palette_file" ]]; then
            local palette_size=$(stat -c%s -- "$temp_palette_file" 2>/dev/null || echo "0")
            if [[ $palette_size -gt 50 ]]; then
                palette_success=true
                printf "\r  ${GREEN}âœ“ Palette generation completed ($(numfmt --to=iec $palette_size))${NC}\n"
            fi
        fi
        
        # Clean up FFmpeg output file after success
        if [[ $palette_success == true ]]; then
            rm -f "$ffmpeg_error_file" 2>/dev/null || true
        fi
        
        # Only fail if palette generation genuinely failed
        if [[ $palette_success != true ]]; then
            local ffmpeg_error="Unknown FFmpeg error"
            local ffmpeg_output=""
            local is_genuine_error=false
            
            # Determine if this is a genuine error or just FFmpeg being slow/resource-constrained
            if [[ $ffmpeg_exit_code -ne 0 ]]; then
                is_genuine_error=true
            elif [[ ! -f "$temp_palette_file" ]]; then
                is_genuine_error=true
            elif [[ -f "$temp_palette_file" ]]; then
                local palette_size=$(stat -c%s -- "$temp_palette_file" 2>/dev/null || echo "0")
                if [[ $palette_size -le 50 ]]; then
                    is_genuine_error=true
                fi
            fi
            
            # Capture detailed error information and log it properly - but only if it's a genuine error
            local diagnosis=""
            if [[ $is_genuine_error == true && -f "$ffmpeg_error_file" && -s "$ffmpeg_error_file" ]]; then
                ffmpeg_error="$(summarize_ffmpeg_error "$ffmpeg_error_file")"
                diagnosis="$ffmpeg_error"
                # Append full FFmpeg output to error log with clear separation
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ==================== FFMPEG OUTPUT ===================="
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FILE: $file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] COMMAND: ffmpeg -i \"$file\" -vf \"$filter_chain\" -frames:v 1 -update 1 -y \"$temp_palette_file\" -loglevel info"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXIT CODE: $ffmpeg_exit_code ($(explain_exit_code $ffmpeg_exit_code))"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] PALETTE FILE EXISTS: $([[ -f "$temp_palette_file" ]] && echo "YES" || echo "NO")"
                    [[ -f "$temp_palette_file" ]] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] PALETTE SIZE: $(stat -c%s -- "$temp_palette_file" 2>/dev/null || echo "0") bytes"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DIAGNOSIS: $diagnosis"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FFMPEG FULL OUTPUT:"
                    cat "$ffmpeg_error_file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
                    echo ""
                } >> "$ERROR_LOG" 2>/dev/null || true
            elif [[ $is_genuine_error == true ]]; then
                ffmpeg_error="No FFmpeg output captured"
                diagnosis="$(explain_exit_code $ffmpeg_exit_code)"
                # Log the fact that we couldn't capture output
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ==================== FFMPEG ERROR ===================="
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FILE: $file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: No FFmpeg output file created"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXIT CODE: $ffmpeg_exit_code ($(explain_exit_code $ffmpeg_exit_code))"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR FILE: $ffmpeg_error_file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
                    echo ""
                } >> "$ERROR_LOG" 2>/dev/null || true
            fi
            
            # Only log and retry if this is genuinely an error
            if [[ $is_genuine_error == true ]]; then
                # Log with comprehensive details
                log_error "FFmpeg palette generation failed (attempt $((retry_count + 1)))" "$file" "Cause: ${diagnosis:-$(explain_exit_code $ffmpeg_exit_code)}" "${BASH_LINENO[0]}" "_convert_video_internal"
                
                # User-friendly terminal output
                echo -e "  ${RED}âš ï¸ FFmpeg palette generation failed${NC}"
                if [[ -n "$diagnosis" ]]; then
                    echo -e "  ${RED}ðŸ” Cause: $diagnosis${NC}"
                fi
                echo -e "  ${YELLOW}ðŸ“‹ Full log: $ERROR_LOG${NC}"
                
                # Cleanup
                rm -f "$ffmpeg_error_file" 2>/dev/null || true
                
                ((retry_count++))
                if [[ $retry_count -gt $MAX_RETRIES ]]; then
                    echo -e "\n  ${RED}âŒ Failed to generate palette after $MAX_RETRIES attempts${NC}"
                    cleanup_temp_files "${file%.*}"
                    ((failed_files++))
                    return 1
                fi
                continue
            else
                # This was not a genuine error - FFmpeg probably succeeded but the script's detection failed
                # Let's wait a moment and re-check the palette file
                echo -e "  ${YELLOW}â³ Waiting for palette file to be fully written...${NC}"
                sleep 2
                
                # Re-check palette file
                if [[ -f "$temp_palette_file" ]]; then
                    local final_palette_size=$(stat -c%s -- "$temp_palette_file" 2>/dev/null || echo "0")
                    if [[ $final_palette_size -gt 50 ]]; then
                        palette_success=true
                        printf "  ${GREEN}âœ“ Palette generation completed ($(numfmt --to=iec $final_palette_size))${NC}\n"
                        rm -f "$ffmpeg_error_file" 2>/dev/null || true
                    fi
                fi
                
                # If still not successful after waiting, then retry
                if [[ $palette_success != true ]]; then
                    echo -e "  ${YELLOW}âš ï¸ Palette file still not ready, retrying...${NC}"
                    rm -f "$ffmpeg_error_file" 2>/dev/null || true
                    ((retry_count++))
                    if [[ $retry_count -gt $MAX_RETRIES ]]; then
                        echo -e "\n  ${RED}âŒ Failed to generate palette after $MAX_RETRIES attempts${NC}"
                        cleanup_temp_files "${file%.*}"
                        ((failed_files++))
                        return 1
                    fi
                    continue
                fi
            fi
        fi
        
        # Step 2: Convert to GIF with palette
        local prefix_filters="fps=${FRAMERATE}"
        if [[ -n "$CROP_FILTER" ]]; then prefix_filters+=",$CROP_FILTER"; fi
        # Fix dithering mode for FFmpeg paletteuse filter
        local dither_option=""
        case "$DITHER_MODE" in
            "floyd") dither_option="dither=floyd_steinberg" ;;
            "bayer") dither_option="dither=bayer:bayer_scale=3" ;;
            "none") dither_option="dither=none" ;;
            *) dither_option="dither=bayer:bayer_scale=3" ;;  # default
        esac
        
        local conversion_filter="${prefix_filters},scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black[x];[x][1:v]paletteuse=$dither_option"
        
        # Safe GIF conversion with comprehensive error handling
        local conversion_error_file="${temp_output_file}.error"
        
        # Run ffmpeg conversion in foreground with progress monitoring
        echo -e "\033[2mðŸŽ¥ Starting GIF conversion (foreground)\033[0m"
        
        echo -e "  ðŸŽ¥ Converting with ${QUALITY} quality..."
        
        # Keep signal handling active for interruption
        # trap '' INT TERM HUP PIPE ERR
        
        # Run ffmpeg conversion (with per-file progress)
        local conversion_exit_code=0
        local conv_start_ts=$(date +%s)
        if convert_with_progress "$file" "$temp_palette_file" "$temp_output_file" "$conversion_filter" "$conversion_error_file"; then
            conversion_exit_code=0
        else
            conversion_exit_code=$?
        fi
        local conv_end_ts=$(date +%s)
        { echo "[$(date '+%Y-%m-%d %H:%M:%S')] CONVERSION ATTEMPT #1 filter='$conversion_filter' elapsed=$((conv_end_ts - conv_start_ts))s"; } >> "$ERROR_LOG" 2>/dev/null || true
        
        # Fallback: one-shot filter_complex (no temp palette file) with progress
        if [[ $conversion_exit_code -ne 0 || ! -s "$temp_output_file" ]]; then
            # Fix dithering mode for one-shot conversion
            local oneshot_dither_option=""
            case "$DITHER_MODE" in
                "floyd") oneshot_dither_option="dither=floyd_steinberg" ;;
                "bayer") oneshot_dither_option="dither=bayer:bayer_scale=3" ;;
                "none") oneshot_dither_option="dither=none" ;;
                *) oneshot_dither_option="dither=bayer:bayer_scale=3" ;;  # default
            esac
            
            local fc="[0:v]fps=${FRAMERATE},scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black,split[a][b];[a]palettegen=max_colors=${MAX_COLORS}:reserve_transparent=0[p];[b][p]paletteuse=$oneshot_dither_option"
            local conv_start_ts2=$(date +%s)
            # For one-shot, create special variant that doesn't use palette input
            if convert_with_progress_oneshot "$file" "$temp_output_file" "$fc" "$conversion_error_file"; then
                conversion_exit_code=0
            else
                conversion_exit_code=$?
            fi
            local conv_end_ts2=$(date +%s)
            { echo "[$(date '+%Y-%m-%d %H:%M:%S')] CONVERSION ATTEMPT #2 (one-shot) elapsed=$((conv_end_ts2 - conv_start_ts2))s"; } >> "$ERROR_LOG" 2>/dev/null || true
        fi
        
        # Signal handling remains active throughout conversion
        # (no need to re-enable since we didn't disable)
        
        echo -e "  âœ“ GIF conversion completed"
        
        # Check if ffmpeg failed
        if [[ $conversion_exit_code -ne 0 ]]; then
            local conversion_error="Unknown conversion error"
            
            # Capture detailed error information and log it properly
            local conv_diagnosis=""
            if [[ -f "$conversion_error_file" && -s "$conversion_error_file" ]]; then
                conversion_error="$(summarize_ffmpeg_error "$conversion_error_file")"
                conv_diagnosis="$conversion_error"
                
                # Append full FFmpeg output to error log with clear separation
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ==================== FFMPEG GIF CONVERSION OUTPUT ===================="
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FILE: $file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] COMMAND: ffmpeg -i \"$file\" -i \"$temp_palette_file\" -lavfi \"$conversion_filter\" -y \"$temp_output_file\" -loglevel info"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXIT CODE: $conversion_exit_code ($(explain_exit_code $conversion_exit_code))"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] OUTPUT FILE EXISTS: $([[ -f "$temp_output_file" ]] && echo "YES" || echo "NO")"
                    [[ -f "$temp_output_file" ]] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] OUTPUT SIZE: $(stat -c%s -- "$temp_output_file" 2>/dev/null || echo "0") bytes"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DIAGNOSIS: $conv_diagnosis"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FFMPEG FULL OUTPUT:"
                    cat "$conversion_error_file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
                    echo ""
                } >> "$ERROR_LOG" 2>/dev/null || true
            else
                conversion_error="No FFmpeg output captured for conversion"
                conv_diagnosis="$(explain_exit_code $conversion_exit_code)"
                {
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ==================== FFMPEG GIF CONVERSION ERROR ===================="
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FILE: $file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: No FFmpeg output file created"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXIT CODE: $conversion_exit_code ($(explain_exit_code $conversion_exit_code))"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR FILE: $conversion_error_file"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
                    echo ""
                } >> "$ERROR_LOG" 2>/dev/null || true
            fi
            
            # Only log and show errors if not interrupted
            if [[ "$INTERRUPT_REQUESTED" != true ]]; then
                log_error "FFmpeg GIF conversion failed (attempt $((retry_count + 1)))" "$file" "Cause: ${conv_diagnosis:-$(explain_exit_code $conversion_exit_code)}" "${BASH_LINENO[0]}" "_convert_video_internal"
                
                # User-friendly terminal output
                echo -e "  ${RED}âš ï¸ FFmpeg GIF conversion failed${NC}"
                if [[ -n "$conv_diagnosis" ]]; then
                    echo -e "  ${RED}ðŸ” Cause: $conv_diagnosis${NC}"
                fi
                echo -e "  ${YELLOW}ðŸ“‹ Full log: $ERROR_LOG${NC}"
            fi
            
            # Cleanup
            rm -f "$conversion_error_file" 2>/dev/null || true
            
            ((retry_count++))
            if [[ $retry_count -gt $MAX_RETRIES ]]; then
                echo -e "\n  ${RED}âŒ Failed to convert after $MAX_RETRIES attempts${NC}"
                cleanup_temp_files "${file%.*}"
                ((failed_files++))
                return 1
            fi
            continue
        fi
        
        # If we reach here, conversion was successful
        conversion_success=true
    done
    
    # Post-conversion processing
    if [[ $conversion_success == true ]]; then
    
        # Step 3: Post-processing and optimization
        echo -e "\n  ${BLUE}ðŸ”„ Post-processing and validation...${NC}"
        
        # Output file validation (can be skipped for speed)
        if [[ "$SKIP_VALIDATION" == "true" ]]; then
            echo -e "  ${YELLOW}âš¡ Skipping validation for speed${NC}"
            if [[ -f "$temp_output_file" ]]; then
                local file_size=$(stat -c%s -- "$temp_output_file" 2>/dev/null || echo "0")
                if [[ $file_size -gt 100 ]]; then
                    echo -e "  ${GREEN}âœ“ GIF created: $(numfmt --to=iec $file_size)${NC}"
                else
                    echo -e "  ${RED}âŒ Output file too small: $file_size bytes${NC}"
                    cleanup_temp_files "${file%.*}"
                    ((failed_files++))
                    return 1
                fi
            else
                echo -e "  ${RED}âŒ No output file created${NC}"
                cleanup_temp_files "${file%.*}"
                ((failed_files++))
                return 1
            fi
        else
            # Full validation
            if ! validate_output_file "$temp_output_file" "$file"; then
                # Handle the corrupt output file
                if [[ -f "$temp_output_file" ]]; then
                    handle_corrupt_file "$temp_output_file" "$file" "Corrupt GIF output"
                    ((corrupt_output_files++)) || true
                fi
                cleanup_temp_files "${file%.*}"
                ((failed_files++))
                return 1
            fi
        fi
        
        # Step 4: Smart AI Decision - Check if compression is truly needed
        local temp_gif_size_mb=$(($(stat -c%s -- "$temp_output_file" 2>/dev/null || echo 0) / 1024 / 1024))
        local compress_needed=false
        local compression_reason=""
        
        # AI Smart Analysis: Decide whether to compromise quality or accept large file
        if [[ "$temp_gif_size_mb" -gt "$MAX_GIF_SIZE_MB" ]]; then
            # Get video metadata for smart decision
            local video_duration=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$file" 2>/dev/null | cut -d. -f1)
            local video_bitrate=$(ffprobe -v error -show_entries format=bit_rate -of csv=p=0 "$file" 2>/dev/null)
            local current_width=$(echo "$RESOLUTION" | cut -d':' -f1)
            local current_height=$(echo "$RESOLUTION" | cut -d':' -f2)
            
            # AI Decision Logic: When NOT to compromise
            local should_preserve_quality=false
            
            # Rule 1: High-res content (1080p+) should not be compromised
            if [[ $current_width -ge 1920 || $current_height -ge 1080 ]]; then
                should_preserve_quality=true
                compression_reason="High-resolution output (${current_width}x${current_height}) - preserving quality"
            fi
            
            # Rule 2: Short videos (<10 seconds) can accept larger files
            if [[ $video_duration -lt 10 && $temp_gif_size_mb -lt $((MAX_GIF_SIZE_MB * 3)) ]]; then
                should_preserve_quality=true
                compression_reason="Short duration (${video_duration}s) - acceptable large file for quality"
            fi
            
            # Rule 3: Premium quality preset should not be compromised
            if [[ "$QUALITY" == "ultra" || "$QUALITY" == "max" ]]; then
                if [[ $temp_gif_size_mb -lt $((MAX_GIF_SIZE_MB * 2)) ]]; then
                    should_preserve_quality=true
                    compression_reason="${QUALITY} quality preset - minimal compromise acceptable"
                fi
            fi
            
            # Rule 4: If size is only slightly over limit (10-30%), accept it
            local size_ratio=$((temp_gif_size_mb * 100 / MAX_GIF_SIZE_MB))
            if [[ $size_ratio -lt 130 ]]; then
                should_preserve_quality=true
                compression_reason="Only $((size_ratio - 100))% over limit - accepting for quality"
            fi
            
            # Decide: Compress only if truly necessary
            if [[ "$should_preserve_quality" == true ]]; then
                echo -e "  ${YELLOW}â„¹ï¸  GIF size: ${temp_gif_size_mb}MB (limit: ${MAX_GIF_SIZE_MB}MB)${NC}"
                echo -e "  ${GREEN}ðŸ§  AI Decision: Quality preserved - $compression_reason${NC}"
                compress_needed=false
            else
                echo -e "  ${RED}âš ï¸  GIF size (${temp_gif_size_mb}MB) significantly exceeds limit (${MAX_GIF_SIZE_MB}MB)${NC}"
                echo -e "  ${BLUE}ðŸ¤– AI Decision: Compression needed - $(( (size_ratio - 100) / 10 ))0% over limit${NC}"
                compress_needed=true
            fi
        fi
        
        if [[ "$compress_needed" == true ]]; then
            echo -e "  ${RED}âš ï¸  GIF size (${temp_gif_size_mb}MB) exceeds limit (${MAX_GIF_SIZE_MB}MB)${NC}"
            echo -e "  ${BLUE}ðŸ¤– AI Taking Control: Applying intelligent adaptive compression...${NC}"
            
            # AI-controlled adaptive compression with intelligent reduction strategy
            local emergency_temp="${TEMP_WORK_DIR}/${base_name}_emergency.${OUTPUT_FORMAT}"
            local emergency_palette="${TEMP_WORK_DIR}/${base_name}_emergency_palette.png"
            
            # Calculate target size ratio to fit within limit
            local size_ratio=$((temp_gif_size_mb * 100 / MAX_GIF_SIZE_MB))
            local reduction_factor=$((size_ratio / 100 + 1))  # How many times over limit
            
            # AI Strategy: Progressively reduce parameters based on size overage
            local emerg_fps=$FRAMERATE
            local emerg_colors=$MAX_COLORS
            local emerg_resolution="$RESOLUTION"
            
            # Determine aggressive level based on how much we exceed
            local aggressive_level=1
            if [[ $size_ratio -gt 400 ]]; then aggressive_level=4; fi  # >4x limit
            if [[ $size_ratio -gt 300 ]]; then aggressive_level=3; fi  # 3-4x limit
            if [[ $size_ratio -gt 150 ]]; then aggressive_level=2; fi  # 1.5-3x limit
            
            # AI Optimization Pass 1: Reduce FPS aggressively
            case $aggressive_level in
                4) emerg_fps=$((FRAMERATE / 4)); [[ $emerg_fps -lt 4 ]] && emerg_fps=4 ;;
                3) emerg_fps=$((FRAMERATE / 3)); [[ $emerg_fps -lt 5 ]] && emerg_fps=5 ;;
                2) emerg_fps=$((FRAMERATE / 2)); [[ $emerg_fps -lt 6 ]] && emerg_fps=6 ;;
                *) emerg_fps=$((FRAMERATE - 2)); [[ $emerg_fps -lt 8 ]] && emerg_fps=8 ;;
            esac
            
            # AI Optimization Pass 2: Reduce color palette
            case $aggressive_level in
                4) emerg_colors=$((MAX_COLORS / 4)); [[ $emerg_colors -lt 16 ]] && emerg_colors=16 ;;
                3) emerg_colors=$((MAX_COLORS / 3)); [[ $emerg_colors -lt 24 ]] && emerg_colors=24 ;;
                2) emerg_colors=$((MAX_COLORS / 2)); [[ $emerg_colors -lt 32 ]] && emerg_colors=32 ;;
                *) emerg_colors=$((MAX_COLORS * 80 / 100)); [[ $emerg_colors -lt 48 ]] && emerg_colors=48 ;;
            esac
            
            # AI Optimization Pass 3: Reduce resolution proportionally
            local current_width=$(echo "$RESOLUTION" | cut -d':' -f1)
            local current_height=$(echo "$RESOLUTION" | cut -d':' -f2)
            local res_factor=100
            case $aggressive_level in
                4) res_factor=40 ;;  # 40% of original
                3) res_factor=50 ;;  # 50% of original
                2) res_factor=65 ;;  # 65% of original
                *) res_factor=80 ;;  # 80% of original
            esac
            
            local emerg_width=$((current_width * res_factor / 100))
            local emerg_height=$((current_height * res_factor / 100))
            # Round to nearest even number (required for video codecs)
            emerg_width=$((emerg_width / 2 * 2))
            emerg_height=$((emerg_height / 2 * 2))
            emerg_resolution="${emerg_width}:${emerg_height}"
            
            echo -e "    ${YELLOW}ðŸ¤– AI Compression Level ${aggressive_level}: ${emerg_resolution}, ${emerg_fps}fps, ${emerg_colors} colors${NC}"
            echo -e "    ${CYAN}AI Strategy: Reducing size by ${res_factor}% resolution, ${emerg_fps}fps framerate, ${emerg_colors} colors${NC}"
            
            # Generate emergency palette
            local emerg_filter_chain="fps=${emerg_fps},scale=${emerg_resolution}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${emerg_resolution}:(ow-iw)/2:(oh-ih)/2:black,palettegen=max_colors=${emerg_colors}:reserve_transparent=0"
            
            if ffmpeg -i "$file" -vf "$emerg_filter_chain" -threads $FFMPEG_THREADS -frames:v 1 -update 1 -y "$emergency_palette" -loglevel error 2>/dev/null; then
                # Generate emergency GIF with corrected dithering syntax
                local emerg_dither_option=""
                case "$DITHER_MODE" in
                    "floyd") emerg_dither_option="dither=floyd_steinberg" ;;
                    "bayer") emerg_dither_option="dither=bayer:bayer_scale=3" ;;
                    "none") emerg_dither_option="dither=none" ;;
                    *) emerg_dither_option="dither=bayer:bayer_scale=3" ;;  # default
                esac
                
                local emerg_conv_filter="fps=${emerg_fps},scale=${emerg_resolution}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${emerg_resolution}:(ow-iw)/2:(oh-ih)/2:black[x];[x][1:v]paletteuse=$emerg_dither_option"
                
                if ffmpeg -i "$file" -i "$emergency_palette" -lavfi "$emerg_conv_filter" -threads $FFMPEG_THREADS -nostats -nostdin -loglevel error -y "$emergency_temp" 2>/dev/null; then
                    local emergency_size_mb=$(($(stat -c%s -- "$emergency_temp" 2>/dev/null || echo 0) / 1024 / 1024))
                    echo -e "    ${GREEN}âœ“ Emergency compression: ${emergency_size_mb}MB${NC}"
                    
                    # Use emergency version if significantly smaller
                    if [[ "$emergency_size_mb" -lt "$((temp_gif_size_mb / 2))" ]]; then
                        mv "$emergency_temp" "$temp_output_file"
                        echo -e "    ${GREEN}âœ“ Using emergency compressed version${NC}"
                    else
                        rm -f "$emergency_temp"
                        echo -e "    ${YELLOW}Emergency compression didn't help enough, keeping original${NC}"
                    fi
                fi
                rm -f "$emergency_palette"
            fi
        fi
        
        # Step 5: Move completed GIF from temp to final location
        echo -e "  ${BLUE}ðŸ“¦ Moving completed GIF to final location...${NC}"
        if mv "$temp_output_file" "$final_output_file" 2>/dev/null; then
            # Get absolute path for logging
            local abs_final_path="$(cd "$(dirname "$final_output_file")" 2>/dev/null && pwd)/$(basename "$final_output_file")"
            echo -e "  ${GREEN}âœ“ GIF saved: $(basename -- "$final_output_file")${NC}"
            echo -e "  ${GRAY}ðŸ’¾ Saved to: $abs_final_path${NC}"
        
        # ðŸ§  AI Training: Learn from successful conversion
        if [[ "$AI_ENABLED" == true ]]; then
            local content_type="$(echo "$AI_CONTENT_CACHE" | grep -o 'content_type=[^[:space:]]*' | cut -d'=' -f2 || echo 'unknown')"
            local motion_level="$(echo "$AI_CONTENT_CACHE" | grep -o 'motion=[^[:space:]]*' | cut -d'=' -f2 || echo 'medium')"
            local complexity_score="$(echo "$AI_CONTENT_CACHE" | grep -o 'complexity=[^[:space:]]*' | cut -d'=' -f2 || echo '50')"
            
            # Get video properties for training
            local video_info=$(get_video_properties "$file")
            local duration=$(echo "$video_info" | cut -d'|' -f1)
            local width=$(echo "$video_info" | cut -d'|' -f2)
            local height=$(echo "$video_info" | cut -d'|' -f3)
            
            # Train AI with successful settings
            train_ai_model "$file" "$content_type" "$width" "$height" "$duration" \
                          "$motion_level" "$complexity_score" "$FRAMERATE" \
                          "$DITHER_MODE" "$MAX_COLORS" "${CROP_FILTER:-none}" "success"
            
            echo -e "  ðŸ§  ${GREEN}AI learned from successful conversion${NC}"
        fi
        else
            echo -e "  ${RED}âŒ Failed to move GIF to final location${NC}"
            cleanup_temp_files "${file%.*}"
            ((failed_files++))
            return 1
        fi
        
        # Show file size comparison
        local original_size=$(stat -c%s -- "$file" 2>/dev/null || echo "1")
        local converted_size=$(stat -c%s -- "$final_output_file" 2>/dev/null || echo "0")
        local ratio=0
        if [[ $original_size -gt 0 ]]; then
            ratio=$((converted_size * 100 / original_size))
        fi
        
        # Enhanced Auto-optimization with multiple strategies
        if [[ "$AUTO_OPTIMIZE" == true && "$OUTPUT_FORMAT" == "gif" ]]; then
            # Check for interrupt before optimization
            if [[ "$INTERRUPT_REQUESTED" == true ]]; then
                echo -e "  ${YELLOW}ðŸ‘‹ Skipping optimization due to interrupt${NC}"
                ((converted_files++))
                return 0
            fi
            
            local original_size=$converted_size
            local best_file="$final_output_file"
            local best_size=$original_size
            local optimization_applied=false
            
            echo -e "  ${BLUE}ðŸŽ¯ Starting intelligent GIF optimization...${NC}"
            
            # Strategy 1: gifsicle optimization (if available)
            if command -v gifsicle >/dev/null 2>&1; then
                echo -e "  ${BLUE}âš™ï¸ Trying gifsicle optimization...${NC}"
                
                # Progress animation
                (
                    local frame=0
                    local spinchars="âš™ï¸ðŸ”§âš¡ðŸ”ðŸ”„"
                    while sleep 0.2; do
                        local char="${spinchars:$((frame % ${#spinchars})):1}"
                        printf "\r  %s ${CYAN}Gifsicle optimization...${NC}" "$char"
                        ((frame++))
                    done
                ) &
                local opt_progress_pid=$!
                
                # Try different optimization levels
                local gifsicle_success=false
                for opt_level in "-O3" "-O2" "-O1"; do
                    # Check for interrupt during optimization
                    if [[ "$INTERRUPT_REQUESTED" == true ]]; then
                        kill $opt_progress_pid 2>/dev/null || true
                        wait $opt_progress_pid 2>/dev/null || true
                        printf "\r  ${YELLOW}ðŸ‘‹ Optimization interrupted${NC}\n"
                        ((converted_files++))
                        return 0
                    fi
                    
                    local temp_file="${final_output_file}.gifsicle.tmp"
                    if timeout 30 gifsicle $opt_level "$final_output_file" -o "$temp_file" 2>/dev/null; then
                        local new_size=$(stat -c%s -- "$temp_file" 2>/dev/null || echo "0")
                        if [[ $new_size -gt 100 && $new_size -lt $best_size ]]; then
                            best_file="$temp_file"
                            best_size=$new_size
                            gifsicle_success=true
                            break
                        fi
                        rm -f "$temp_file" 2>/dev/null
                    fi
                done
                
                kill $opt_progress_pid 2>/dev/null || true
                wait $opt_progress_pid 2>/dev/null || true
                
                if [[ $gifsicle_success == true ]]; then
                    local savings=$(( (original_size - best_size) * 100 / original_size ))
                    printf "\r  ${GREEN}âœ“ Gifsicle: $(numfmt --to=iec $best_size) (-${savings}%%)${NC}\n"
                    optimization_applied=true
                else
                    printf "\r  ${YELLOW}âš ï¸ Gifsicle: No improvement found${NC}\n"
                fi
            fi
            
            # Strategy 2: FFmpeg re-encoding with different settings (if gifsicle didn't help enough)
            local target_threshold=$((original_size * OPTIMIZE_TARGET_RATIO / 100))
            local should_try_ffmpeg=false
            
            if [[ "$OPTIMIZE_AGGRESSIVE" == "true" ]]; then
                # Aggressive mode: try FFmpeg if we haven't reached target ratio
                [[ $best_size -gt $target_threshold ]] && should_try_ffmpeg=true
            else
                # Conservative mode: only try FFmpeg if gifsicle didn't save much
                local conservative_threshold=$((original_size * 90 / 100))
                [[ $best_size -gt $conservative_threshold ]] && should_try_ffmpeg=true
            fi
            
            if [[ $should_try_ffmpeg == true ]]; then
                # Check for interrupt before FFmpeg optimization
                if [[ "$INTERRUPT_REQUESTED" == true ]]; then
                    printf "\r  ${YELLOW}ðŸ‘‹ Skipping FFmpeg re-optimization due to interrupt${NC}\n"
                    # Apply best result so far before exiting
                    if [[ "$best_file" != "$final_output_file" && -f "$best_file" ]]; then
                        mv "$best_file" "$final_output_file" 2>/dev/null
                    fi
                    ((converted_files++))
                    return 0
                fi
                
                echo -e "  ${BLUE}ðŸ”„ Trying FFmpeg re-optimization...${NC}"
                
                # Progress animation
                (
                    local frame=0
                    local spinchars="ðŸ”„âš™ï¸ðŸŽ›ï¸ðŸ”§ðŸ“"
                    while sleep 0.3; do
                        local char="${spinchars:$((frame % ${#spinchars})):1}"
                        printf "\r  %s ${CYAN}FFmpeg re-optimization...${NC}" "$char"
                        ((frame++))
                    done
                ) &
                local ffmpeg_progress_pid=$!
                
                # Try re-encoding with slightly reduced quality for size savings
                local temp_palette="${final_output_file}.reopt_palette.png"
                local temp_output="${final_output_file}.reopt.tmp"
                local reopt_colors=$((MAX_COLORS * 85 / 100))  # Reduce colors by 15%
                
                # Generate new palette with fewer colors
                local reopt_filter="fps=${FRAMERATE},scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black,palettegen=max_colors=${reopt_colors}:reserve_transparent=0"
                
                # Use background process for palette generation and track it
                ffmpeg $FFMPEG_INPUT_OPTS -i "$file" -vf "$reopt_filter" $FFMPEG_MEMORY_OPTS -frames:v 1 -update 1 -y "$temp_palette" -loglevel error </dev/null >/dev/null 2>&1 &
                local palette_pid=$!
                SCRIPT_FFMPEG_PIDS+=("$palette_pid")
                
                # Wait for palette generation and remove from tracking
                wait $palette_pid
                local palette_result=$?
                
                # Remove from tracking array
                local new_pids=()
                for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
                    if [[ "$pid" != "$palette_pid" ]]; then
                        new_pids+=("$pid")
                    fi
                done
                SCRIPT_FFMPEG_PIDS=("${new_pids[@]}")
                
                if [[ $palette_result -eq 0 && -f "$temp_palette" ]]; then
                    # Re-encode with new palette
                    local reopt_conversion_filter="fps=${FRAMERATE},scale=${RESOLUTION}:force_original_aspect_ratio=decrease:flags=${SCALING_ALGO},pad=${RESOLUTION}:(ow-iw)/2:(oh-ih)/2:black[x];[x][1:v]paletteuse=dither=${DITHER_MODE}:bayer_scale=2"
                    
                    # Use background process for reencoding and track it
                    ffmpeg $FFMPEG_INPUT_OPTS -i "$file" -i "$temp_palette" -lavfi "$reopt_conversion_filter" $FFMPEG_MEMORY_OPTS -y "$temp_output" -loglevel error </dev/null >/dev/null 2>&1 &
                    local reopt_pid=$!
                    SCRIPT_FFMPEG_PIDS+=("$reopt_pid")
                    
                    # Wait for reencoding and remove from tracking
                    wait $reopt_pid
                    local reopt_result=$?
                    
                    # Remove from tracking array
                    local new_pids2=()
                    for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
                        if [[ "$pid" != "$reopt_pid" ]]; then
                            new_pids2+=("$pid")
                        fi
                    done
                    SCRIPT_FFMPEG_PIDS=("${new_pids2[@]}")
                    
                    if [[ $reopt_result -eq 0 ]]; then
                        local reopt_size=$(stat -c%s -- "$temp_output" 2>/dev/null || echo "0")
                        if [[ $reopt_size -gt 100 && $reopt_size -lt $best_size ]]; then
                            # Clean up previous best file if it's a temp file
                            [[ "$best_file" != "$final_output_file" ]] && rm -f "$best_file" 2>/dev/null
                            best_file="$temp_output"
                            best_size=$reopt_size
                            optimization_applied=true
                        else
                            rm -f "$temp_output" 2>/dev/null
                        fi
                    fi
                    rm -f "$temp_palette" 2>/dev/null
                fi
                
                kill $ffmpeg_progress_pid 2>/dev/null || true
                wait $ffmpeg_progress_pid 2>/dev/null || true
                
                if [[ "$best_file" != "$final_output_file" && -f "$best_file" ]]; then
                    local savings=$(( (original_size - best_size) * 100 / original_size ))
                    printf "\r  ${GREEN}âœ“ FFmpeg reopt: $(numfmt --to=iec $best_size) (-${savings}%%)${NC}\n"
                else
                    printf "\r  ${YELLOW}âš ï¸ FFmpeg reopt: No improvement${NC}\n"
                fi
            fi
            
            # Apply the best optimization result
            if [[ "$best_file" != "$final_output_file" && -f "$best_file" ]]; then
                mv "$best_file" "$final_output_file" 2>/dev/null
                converted_size=$best_size
                local total_savings=$(( (original_size - best_size) * 100 / original_size ))
                echo -e "  ${GREEN}ðŸŽ‰ Optimization complete: $(numfmt --to=iec $best_size) (saved ${total_savings}%%)${NC}"
            else
                if [[ $optimization_applied == false ]]; then
                    echo -e "  ${CYAN}â„¹ï¸ No optimization tools available or no improvements found${NC}"
                fi
                # Clean up any temp files
                rm -f "${final_output_file}".*.tmp 2>/dev/null
            fi
        fi
        
        printf "\r  ${GREEN}âœ“ Completed: ${BOLD}$(basename -- "$final_output_file")${NC} ${MAGENTA}($(numfmt --to=iec $converted_size) - ${ratio}%% of original)${NC}\n"
        
        # Log successful conversion
        log_conversion "SUCCESS" "$file" "$final_output_file" "($(numfmt --to=iec $converted_size) - ${ratio}% of original)"
        
        ((converted_files++))
    else
        echo -e "\n  ${RED}âŒ Conversion failed after all attempts${NC}"
        log_conversion "FAILED" "$file" "$final_output_file" "(failed after $MAX_RETRIES attempts)"
        ((failed_files++))
    fi
    
    # Always cleanup temporary files
    cleanup_temp_files "${file%.*}"
    
    # Immediate cleanup of any lingering processes for this conversion
    local immediate_cleanup_count=0
    local remaining_pids=()
    for pid in "${SCRIPT_FFMPEG_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            remaining_pids+=("$pid")
        else
            ((immediate_cleanup_count++))
        fi
    done
    SCRIPT_FFMPEG_PIDS=("${remaining_pids[@]}")
    
    if [[ $immediate_cleanup_count -gt 0 ]]; then
        echo -e "  ${BLUE}ðŸ§¹ Cleaned up $immediate_cleanup_count completed processes${NC}"
    fi
    
    echo -e "${CYAN}âœ“ Finished processing: $(basename -- "$1")${NC}"
}

# ðŸ“ˆ Show final statistics
show_statistics() {
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    
    echo ""
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘                        ðŸ“Š STATISTICS                         â•‘${NC}"
    echo -e "${CYAN}${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${NC}"
    printf "${CYAN}${BOLD}â•‘${NC} ${GREEN}âœ“ Converted:${NC} %-10s ${YELLOW}â­ Skipped:${NC} %-10s ${RED}âœ— Failed:${NC} %-6s ${CYAN}${BOLD}â•‘${NC}\n" "$converted_files" "$skipped_files" "$failed_files"
    printf "${CYAN}${BOLD}â•‘${NC} ${BLUE}ðŸ“ Total files:${NC} %-8s ${MAGENTA}â± Duration:${NC} %02d:%02d:%02d                ${CYAN}${BOLD}â•‘${NC}\n" "$total_files" "$hours" "$minutes" "$seconds"
    printf "${CYAN}${BOLD}â•‘${NC} ${YELLOW}âš™ Quality:${NC} %-12s ${BLUE}ðŸ“ Resolution:${NC} %-12s        ${CYAN}${BOLD}â•‘${NC}\n" "$QUALITY" "$RESOLUTION"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# ðŸŽ† Main execution with robust error handling
main() {
    # Self-integrity check - detect if script was modified
    local script_path="${BASH_SOURCE[0]}"
    local script_hash_cache="$HOME/.smart-gif-converter/.script_hash"
    local current_hash=$(md5sum "$script_path" 2>/dev/null | cut -d' ' -f1)
    
    if [[ -f "$script_hash_cache" ]]; then
        local cached_hash=$(cat "$script_hash_cache" 2>/dev/null)
        if [[ "$current_hash" != "$cached_hash" ]]; then
            echo -e "${YELLOW}âš ï¸ Script modified - clearing validation cache for safety${NC}"
            rm -f "$HOME/.smart-gif-converter/validation_cache.db" 2>/dev/null
            echo "$current_hash" > "$script_hash_cache"
        fi
    else
        # First run or cache missing - save hash
        mkdir -p "$(dirname "$script_hash_cache")" 2>/dev/null
        echo "$current_hash" > "$script_hash_cache"
    fi
    
    # Initialize error handling system
    trace_function "main"
    
    # Enhanced signal handling for graceful interruption
    trap 'handle_crash $LINENO' ERR
    trap 'handle_interrupt' INT  # Graceful interrupt (allows current file to finish)
    trap 'cleanup_on_exit 143' TERM
    trap 'emergency_exit' HUP PIPE
    trap 'finish_script' EXIT  # Normal cleanup on successful exit
    
    # Enable debug mode for better error tracking
    [[ "$DEBUG_MODE" == true ]] && set -x
    
    # Initialize log directory and files (sets SETTINGS_FILE)
    init_log_directory
    
    # Initialize fast hash system (xxhash/blake3/md5 detection)
    init_hash_system
    
    # Log a one-time settings snapshot for better diagnostics
    log_settings_snapshot_once
    
    print_header
    
    # ðŸ” Syntax validation check - verify script integrity
    echo -e "${BLUE}ðŸ” Validating script syntax...${NC}"
    if bash -n "$script_path" 2>/dev/null; then
        echo -e "  ${GREEN}âœ“ Syntax check passed${NC}"
    else
        echo -e "  ${RED}âŒ SYNTAX ERROR DETECTED!${NC}"
        echo -e "  ${YELLOW}Running detailed check...${NC}"
        bash -n "$script_path" 2>&1 | head -20
        echo -e "\n${RED}Script contains syntax errors. Please fix before continuing.${NC}"
        exit 1
    fi
    
    # ðŸ› ï¸ Detect development mode (Git repository detection)
    detect_dev_mode 2>/dev/null || true
    
    # Initialize release fingerprint system (track installed version integrity)
    load_release_fingerprint 2>/dev/null || true
    
    # Automatic update check
    # Automatically skipped if DEV_MODE=true
    # NOTE: Run synchronously to avoid background prompts interfering with
    #       dependency and hardware detection input handling.
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BLUE}ðŸ” Performing system checks...${NC}"
    check_for_updates
    
    check_dependencies
    validate_environment
    echo -e "${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    # GPU acceleration and parallel processing setup
    detect_gpu_acceleration
    setup_parallel_processing
    
    # Show optimization status
    echo -e "${BLUE}ðŸ§  Smart Optimization Status:${NC}"
    if [[ "$SMART_SIZE_DOWN" == "true" ]]; then
        echo -e "  ${GREEN}âœ“ Smart sizing: ENABLED${NC} (automatic size reduction)"
    else
        echo -e "  ${YELLOW}âš ï¸  Smart sizing: DISABLED${NC}"
    fi
    if [[ "$AUTO_OPTIMIZE" == "true" ]]; then
        local opt_mode=$([[ "$OPTIMIZE_AGGRESSIVE" == "true" ]] && echo "Aggressive" || echo "Conservative")
        echo -e "  ${GREEN}âœ“ Auto-optimize: ENABLED${NC} ($opt_mode mode)"
        echo -e "  ${CYAN}  â†’ Target: ${OPTIMIZE_TARGET_RATIO}% of original, Max: ${MAX_GIF_SIZE_MB}MB${NC}"
    else
        echo -e "  ${YELLOW}âš ï¸  Auto-optimize: DISABLED${NC}"
    fi
    echo ""
    
    # Skip corrupted GIF check in interactive mode (available in validation menu)
    # detect_corrupted_gifs  # This causes hangs in interactive mode
    
    load_config || true  # Don't fail if no config exists
    
    # First-run check: prompt for output directory ONLY if settings file doesn't exist
    if [[ ! -f "$SETTINGS_FILE" ]]; then
        # True first run - no settings file exists
        clear
        print_header
        echo -e "${CYAN}${BOLD}ðŸŽ‰ WELCOME TO SMART GIF CONVERTER!${NC}\n"
        echo -e "${BLUE}Before we begin, let's set up where your GIF files will be saved.${NC}\n"
        
        # Only ask in interactive mode
        if [[ $# -eq 0 ]]; then
            local selected=0
            local options=(
                "./converted_gifs - Keep videos & GIFs organized (recommended)"
                "Pictures folder - Save to system Pictures directory"
                "Script directory - Save where convert.sh is located"
                "Custom path - Choose your own location"
            )
            local descriptions=(
                "Creates a 'converted_gifs' subfolder next to your videos"
                "Saves to $HOME/Pictures/GIFs - easy to find in file manager"
                "Saves to the same folder where this script file lives"
                "Browse with file picker or type any path you want"
            )
            
            while true; do
                clear
                print_header
                
                echo -e "${CYAN}${BOLD}ðŸŽ‰ WELCOME TO SMART GIF CONVERTER!${NC}\n"
                echo -e "${BLUE}Before we begin, let's set up where your GIF files will be saved.${NC}\n"
                
                echo -e "${YELLOW}ðŸ’¾ Where would you like to save converted GIF files?${NC}"
                echo -e "${GRAY}(You can change this later from the main menu)${NC}"
                echo -e "${YELLOW}ðŸŽ¹ Navigation: ${GREEN}w${NC}=Up ${GREEN}s${NC}=Down ${GREEN}Enter${NC}=Select${NC}\n"
                
                # Display options with highlight
                for i in "${!options[@]}"; do
                    if [[ $i -eq $selected ]]; then
                        echo -e "  ${GREEN}${BOLD}âž¤ ${options[$i]}${NC}"
                        echo -e "    ${CYAN}ðŸ’¡ ${descriptions[$i]}${NC}"
                    else
                        echo -e "  ${GRAY}  ${options[$i]}${NC}"
                    fi
                done
                
                echo ""
                
                # Read key
                read -rsn1 key 2>/dev/null || read -r key
                
                case "$key" in
                    $'\x1b')  # Arrow keys
                        read -rsn2 -t 0.1 key
                        case "$key" in
                            '[A') # Up
                                selected=$((selected - 1))
                                [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                                ;;
                            '[B') # Down
                                selected=$((selected + 1))
                                [[ $selected -ge ${#options[@]} ]] && selected=0
                                ;;
                        esac
                        ;;
                    'w'|'W') # Up
                        selected=$((selected - 1))
                        [[ $selected -lt 0 ]] && selected=$((${#options[@]}-1))
                        sleep 0.1
                        ;;
                    's'|'S') # Down
                        selected=$((selected + 1))
                        [[ $selected -ge ${#options[@]} ]] && selected=0
                        sleep 0.1
                        ;;
                    ''|$'\n'|$'\r'|' ') # Enter/Space
                        break
                        ;;
                esac
            done
            
            local output_choice=$((selected + 1))
            
            case "$output_choice" in
                "1")
                    OUTPUT_DIRECTORY="./converted_gifs"
                    OUTPUT_DIR_MODE="default"
                    echo -e "\n${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY${NC}"
                    echo -e "  ${CYAN}ðŸ’¡ Directory will be created automatically during conversion${NC}"
                    ;;
                "2")
                    OUTPUT_DIRECTORY="$HOME/Pictures/GIFs"
                    OUTPUT_DIR_MODE="pictures"
                    mkdir -p "$OUTPUT_DIRECTORY" 2>/dev/null || {
                        echo -e "\n${RED}âŒ Cannot create Pictures/GIFs directory, using default${NC}"
                        OUTPUT_DIRECTORY="./converted_gifs"
                        OUTPUT_DIR_MODE="default"
                    }
                    echo -e "\n${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY${NC}"
                    ;;
                "3")
                    # Current directory (where user is running the script FROM)
                    OUTPUT_DIRECTORY="$(pwd)"
                    OUTPUT_DIR_MODE="current"
                    echo -e "\n${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY${NC}"
                    echo -e "  ${CYAN}ðŸ’¡ Same folder as your video files (current directory)${NC}"
                    ;;
                "4")
                    # Script directory (where the script is located)
                    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
                    OUTPUT_DIRECTORY="$script_dir"
                    OUTPUT_DIR_MODE="script"
                    echo -e "\n${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY${NC}"
                    echo -e "  ${CYAN}ðŸ’¡ Same folder as convert.sh script${NC}"
                    ;;
                "5")
                    # Try to use file picker first
                    local picker=$(detect_file_picker)
                    local custom_path=""
                    
                    if [[ "$picker" != "none" ]]; then
                        echo -e "\n${CYAN}Opening file picker to select directory...${NC}"
                        sleep 0.5
                        custom_path=$(browse_for_directory)
                        
                        if [[ -z "$custom_path" ]]; then
                            echo -e "${YELLOW}No directory selected. Enter path manually or press Enter to use default:${NC}"
                            echo -ne "${YELLOW}Path: ${NC}"
                            read -r custom_path
                            custom_path="${custom_path/#\~/$HOME}"
                        fi
                    else
                        echo -e "\n${CYAN}Enter the directory path where GIFs should be saved:${NC}"
                        echo -e "${GRAY}(No file picker found - install zenity, kdialog, yad, or python3-tk for GUI)${NC}"
                        echo -e "${GRAY}Common paths: $HOME/Pictures, $HOME/Downloads, $HOME/Videos${NC}"
                        echo -ne "${YELLOW}Path (or press Enter for default ./converted_gifs): ${NC}"
                        read -r custom_path
                        custom_path="${custom_path/#\~/$HOME}"
                        
                        # If empty, use default
                        if [[ -z "$custom_path" ]]; then
                            custom_path="./converted_gifs"
                        fi
                    fi
                    
                    if [[ -n "$custom_path" ]]; then
                        if [[ ! -d "$custom_path" ]]; then
                            echo -ne "\n${YELLOW}Directory doesn't exist. Create it? [Y/n]: ${NC}"
                            read -r create_confirm
                            if [[ ! "$create_confirm" =~ ^[Nn]$ ]]; then
                                mkdir -p "$custom_path" 2>/dev/null && {
                                    OUTPUT_DIRECTORY="$custom_path"
                                    OUTPUT_DIR_MODE="custom"
                                    echo -e "${GREEN}âœ“ Created and will use: $OUTPUT_DIRECTORY${NC}"
                                } || {
                                    echo -e "${RED}âŒ Cannot create directory, using default${NC}"
                                    OUTPUT_DIRECTORY="./converted_gifs"
                                    OUTPUT_DIR_MODE="default"
                                }
                            else
                                OUTPUT_DIRECTORY="./converted_gifs"
                                OUTPUT_DIR_MODE="default"
                                echo -e "${YELLOW}Using default directory${NC}"
                            fi
                        else
                            OUTPUT_DIRECTORY="$custom_path"
                            OUTPUT_DIR_MODE="custom"
                            echo -e "${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY${NC}"
                        fi
                    else
                        OUTPUT_DIRECTORY="./converted_gifs"
                        OUTPUT_DIR_MODE="default"
                        echo -e "${YELLOW}Using default directory${NC}"
                    fi
                    ;;
                *)
                    OUTPUT_DIRECTORY="./converted_gifs"
                    OUTPUT_DIR_MODE="default"
                    echo -e "\n${GREEN}âœ“ GIFs will be saved to: $OUTPUT_DIRECTORY (default)${NC}"
                    ;;
            esac
            
            # Save the choice
            save_settings --silent
            echo -e "${BLUE}ðŸ’¾ Your choice has been saved and can be changed anytime from the main menu.${NC}"
            sleep 2
        fi
    fi
    
    # Store original argument count before parsing (for menu decision later)
    # Exclude --no-tmux as it's an internal flag that shouldn't prevent menu display
    local original_arg_count=$#
    local has_meaningful_args=false
    for arg in "$@"; do
        if [[ "$arg" != "--no-tmux" ]]; then
            has_meaningful_args=true
            break
        fi
    done
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --file)
                ONLY_FILE="$2"
                shift 2
                ;;
            --ai|--ai-smart)
                AI_ENABLED=true
                AI_MODE="smart"
                shift
                ;;
            --ai-mode)
                AI_MODE="$2"
                shift 2
                ;;
            --ai-content)
                AI_ENABLED=true
                AI_MODE="content"
                shift
                ;;
            --ai-motion)
                AI_ENABLED=true
                AI_MODE="motion"
                shift
                ;;
            --ai-quality)
                AI_ENABLED=true
                AI_MODE="quality"
                shift
                ;;
            --ai-confidence)
                AI_CONFIDENCE_THRESHOLD="$2"
                shift 2
                ;;
            --preset)
                apply_preset "$2"
                shift 2
                ;;
            --anime|--artwork)
                # Anime/artwork optimized preset
                RESOLUTION="854:480"
                FRAMERATE="10"
                MAX_COLORS="96"
                QUALITY="anime"
                echo -e "${GREEN}ðŸŽ¨ Applied anime/artwork optimized preset${NC}"
                shift
                ;;
            --resolution)
                RESOLUTION="$2"
                shift 2
                # Auto-save when resolution changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --fps)
                FRAMERATE="$2"
                shift 2
                # Auto-save when framerate changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --aspect)
                ASPECT_RATIO="$2"
                shift 2
                # Auto-save when aspect ratio changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --force)
                FORCE_CONVERSION=true
                shift
                # Auto-save when force mode changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --auto-detect)
                AUTO_DETECT=true
                shift
                ;;
            --optimize-aggressive)
                OPTIMIZE_AGGRESSIVE=true
                shift
                # Auto-save when optimization setting changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --optimize-conservative)
                OPTIMIZE_AGGRESSIVE=false
                shift
                # Auto-save when optimization setting changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --optimize-target)
                OPTIMIZE_TARGET_RATIO="$2"
                shift 2
                # Auto-save when optimization setting changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --debug)
                DEBUG_MODE=true
                shift
                # Auto-save when debug mode changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --max-retries)
                MAX_RETRIES="$2"
                shift 2
                # Auto-save when retry count changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --skip-validation)
                SKIP_VALIDATION=true
                shift
                # Auto-save when validation setting changes
                if [[ -n "$SETTINGS_FILE" ]]; then save_settings --silent; fi
                ;;
            --single-threaded)
                PARALLEL_JOBS=1
                shift
                ;;
            --parallel-jobs)
                PARALLEL_JOBS="$2"
                shift 2
                ;;
            --gpu-enable)
                GPU_ACCELERATION="true"
                shift
                ;;
            --gpu-disable)
                GPU_ACCELERATION="false"
                shift
                ;;
            --threads)
                FFMPEG_THREADS="$2"
                shift 2
                ;;
            --max-size)
                MAX_GIF_SIZE_MB="$2"
                shift 2
                ;;
            --target-ratio)
                OPTIMIZE_TARGET_RATIO="$2"
                shift 2
                ;;
            --disable-size-optimization)
                AUTO_REDUCE_QUALITY=false
                SMART_SIZE_DOWN=false
                shift
                ;;
            --enable-smart-sizing)
                SMART_SIZE_DOWN=true
                AUTO_REDUCE_QUALITY=true
                shift
                ;;
            --disable-smart-sizing)
                SMART_SIZE_DOWN=false
                shift
                ;;
            --aggressive-optimization)
                OPTIMIZE_AGGRESSIVE=true
                MAX_GIF_SIZE_MB=15
                OPTIMIZE_TARGET_RATIO=15
                shift
                ;;
            --conservative-optimization)
                OPTIMIZE_AGGRESSIVE=false
                MAX_GIF_SIZE_MB=75
                OPTIMIZE_TARGET_RATIO=50
                shift
                ;;
            --dynamic-detection|--monitor-files)
                DYNAMIC_FILE_DETECTION=true
                shift
                ;;
            --monitor-interval)
                FILE_MONITOR_INTERVAL="$2"
                shift 2
                ;;
            --no-dynamic-detection|--no-monitor)
                DYNAMIC_FILE_DETECTION=false
                shift
                ;;
            --kill-ffmpeg)
                echo -e "${RED}${BOLD}ðŸ”« Killing all ffmpeg processes...${NC}\n"
                local ffmpeg_pids=($(pgrep -f ffmpeg 2>/dev/null || true))
                if [[ ${#ffmpeg_pids[@]} -eq 0 ]]; then
                    echo -e "${GREEN}âœ“ No ffmpeg processes are currently running${NC}"
                else
                    echo -e "${YELLOW}Found ${#ffmpeg_pids[@]} ffmpeg process(es), sending SIGTERM...${NC}"
                    for pid in "${ffmpeg_pids[@]}"; do
                        if kill -TERM "$pid" 2>/dev/null; then
                            echo -e "  ${GREEN}âœ“ Terminated PID $pid${NC}"
                        else
                            echo -e "  ${RED}âŒ Failed to terminate PID $pid${NC}"
                        fi
                    done
                    sleep 2
                    
                    # Check for remaining processes and force kill if needed
                    local remaining_pids=($(pgrep -f ffmpeg 2>/dev/null || true))
                    if [[ ${#remaining_pids[@]} -gt 0 ]]; then
                        echo -e "${RED}Force killing ${#remaining_pids[@]} remaining process(es)...${NC}"
                        for pid in "${remaining_pids[@]}"; do
                            if kill -KILL "$pid" 2>/dev/null; then
                                echo -e "  ${GREEN}âœ“ Force killed PID $pid${NC}"
                            fi
                        done
                    fi
                fi
                exit 0
                ;;
            --stop-all)
                echo -e "${RED}${BOLD}ðŸš« STOPPING ALL FFMPEG PROCESSES...${NC}\n"
                # Kill all ffmpeg processes (not just script ones)
                local all_ffmpeg_pids=($(pgrep ffmpeg 2>/dev/null || true))
                if [[ ${#all_ffmpeg_pids[@]} -eq 0 ]]; then
                    echo -e "${GREEN}âœ“ No ffmpeg processes running${NC}"
                else
                    echo -e "${YELLOW}ðŸ”„ Terminating ${#all_ffmpeg_pids[@]} ffmpeg process(es)...${NC}"
                    for pid in "${all_ffmpeg_pids[@]}"; do
                        if kill -TERM "$pid" 2>/dev/null; then
                            echo -e "  ${GREEN}âœ“ Terminated PID $pid${NC}"
                        fi
                    done
                    sleep 2
                    
                    # Force kill any survivors
                    local remaining_pids=($(pgrep ffmpeg 2>/dev/null || true))
                    if [[ ${#remaining_pids[@]} -gt 0 ]]; then
                        echo -e "${RED}Force killing ${#remaining_pids[@]} stubborn process(es)...${NC}"
                        for pid in "${remaining_pids[@]}"; do
                            kill -KILL "$pid" 2>/dev/null
                            echo -e "  ${YELLOW}âš¡ Force killed PID $pid${NC}"
                        done
                    fi
                    echo -e "${GREEN}âœ… All ffmpeg processes stopped${NC}"
                fi
                exit 0
                ;;
            --clear-progress)
                echo -e "${YELLOW}ðŸ—‹ Clearing conversion progress...${NC}"
                clear_progress
                exit 0
                ;;
            --show-progress)
                if [[ -f "$PROGRESS_FILE" ]]; then
                    echo -e "${CYAN}${BOLD}ðŸ“Š CONVERSION PROGRESS${NC}\\n"
                    echo -e "${BLUE}Progress File: $PROGRESS_FILE${NC}"
                    echo -e "\n${YELLOW}Recent Progress:${NC}"
                    tail -20 "$PROGRESS_FILE" | grep -E "SUCCESS|FAILED|SKIPPED" | while read line; do
                        if [[ $line == *"SUCCESS"* ]]; then
                            echo -e "  ${GREEN}âœ“ $line${NC}"
                        elif [[ $line == *"FAILED"* ]]; then
                            echo -e "  ${RED}âŒ $line${NC}"
                        elif [[ $line == *"SKIPPED"* ]]; then
                            echo -e "  ${YELLOW}â­ $line${NC}"
                        fi
                    done
                else
                    echo -e "${YELLOW}â„¹ï¸ No progress file found${NC}"
                fi
                exit 0
                ;;
            --ai-status|--ai-stats)
                echo -e "${CYAN}${BOLD}ðŸ¤– AI SYSTEM STATUS${NC}\\\\n"
                show_ai_status
                exit 0
                ;;
            --clean-cache)
                echo -e "${CYAN}${BOLD}ðŸ§¹ CLEANING AI CACHE${NC}\\n"
                init_ai_cache >/dev/null 2>&1
                cleanup_ai_cache
                echo -e "\n${GREEN}âœ“ Cache cleanup complete!${NC}"
                exit 0
                ;;
            --show-settings)
                echo -e "${CYAN}${BOLD}ðŸ”§ CURRENT SETTINGS${NC}\\\\n"
                local settings_display="$(echo "$SETTINGS_FILE" | sed "s|$HOME|~|g")"
                local config_display="$(echo "$CONFIG_FILE" | sed "s|$HOME|~|g")"
                local clickable_settings=$(make_clickable_path "$SETTINGS_FILE" "$settings_display")
                local clickable_config=$(make_clickable_path "$CONFIG_FILE" "$config_display")
                echo -e "${YELLOW}Settings Location:${NC} $clickable_settings"
                echo -e "${YELLOW}Backup Config:${NC} $clickable_config\\n"
                
                echo -e "${GREEN}${BOLD}Quality & Output:${NC}"
                echo -e "  ${BLUE}Quality Preset:${NC} $QUALITY"
                echo -e "  ${BLUE}Resolution:${NC} $RESOLUTION"
                echo -e "  ${BLUE}Frame Rate:${NC} ${FRAMERATE}fps"
                echo -e "  ${BLUE}Aspect Ratio:${NC} $ASPECT_RATIO"
                echo -e "  ${BLUE}Output Format:${NC} $OUTPUT_FORMAT"
                
                echo -e "\n${GREEN}${BOLD}Processing Options:${NC}"
                echo -e "  ${BLUE}Auto Optimize:${NC} $AUTO_OPTIMIZE"
                if [[ "$AUTO_OPTIMIZE" == "true" ]]; then
                    echo -e "  ${BLUE}Optimization Mode:${NC} $([[ "$OPTIMIZE_AGGRESSIVE" == "true" ]] && echo "Aggressive" || echo "Conservative")"
                    echo -e "  ${BLUE}Target Size Ratio:${NC} ${OPTIMIZE_TARGET_RATIO}%"
                fi
                echo -e "  ${BLUE}Skip Validation:${NC} $SKIP_VALIDATION"
                echo -e "  ${BLUE}Force Conversion:${NC} $FORCE_CONVERSION"
                echo -e "  ${BLUE}Backup Original:${NC} $BACKUP_ORIGINAL"
                echo -e "  ${BLUE}Progress Bar:${NC} $PROGRESS_BAR"
                echo -e "  ${BLUE}Debug Mode:${NC} $DEBUG_MODE"
                echo -e "  ${BLUE}Max Retries:${NC} $MAX_RETRIES"
                echo -e "  ${BLUE}Dynamic File Detection:${NC} $DYNAMIC_FILE_DETECTION"
                [[ "$DYNAMIC_FILE_DETECTION" == "true" ]] && echo -e "  ${BLUE}Monitor Interval:${NC} ${FILE_MONITOR_INTERVAL}s"
                
                echo -e "\n${GREEN}${BOLD}Advanced:${NC}"
                echo -e "  ${BLUE}Scaling Algorithm:${NC} $SCALING_ALGO"
                echo -e "  ${BLUE}Dither Mode:${NC} $DITHER_MODE"
                echo -e "  ${BLUE}Max Colors:${NC} $MAX_COLORS"
                echo -e "  ${BLUE}Palette Mode:${NC} $PALETTE_MODE"
                
                if [[ -f "$SETTINGS_FILE" ]]; then
                    local mod_time=$(stat -c %Y -- "$SETTINGS_FILE" 2>/dev/null || echo "0")
                    local readable_time=$(date -d "@$mod_time" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
                    echo -e "\n${YELLOW}â„¹ï¸ Settings file last updated: $readable_time${NC}"
                else
                    echo -e "\n${YELLOW}âš ï¸ No settings file found (will be created on first use)${NC}"
                fi
                exit 0
                ;;
            --debug-settings)
                echo -e "${CYAN}${BOLD}ðŸ› SETTINGS PERSISTENCE DIAGNOSTICS${NC}\n"
                echo -e "${YELLOW}${BOLD}=== FILE PATHS ===${NC}"
                echo -e "${BLUE}Settings file:${NC} $SETTINGS_FILE"
                echo -e "${BLUE}Legacy config:${NC} $CONFIG_FILE"
                echo -e "${BLUE}Settings directory:${NC} $(dirname "$SETTINGS_FILE")"
                echo -e "${BLUE}Working directory:${NC} $(pwd)"
                
                echo -e "\n${YELLOW}${BOLD}=== DIRECTORY STATUS ===${NC}"
                local settings_dir="$(dirname "$SETTINGS_FILE")"
                if [[ -d "$settings_dir" ]]; then
                    echo -e "${GREEN}âœ“ Settings directory exists${NC}"
                    echo -e "  ${BLUE}Permissions:${NC} $(ls -ld "$settings_dir" | awk '{print $1}')"
                    echo -e "  ${BLUE}Owner:${NC} $(ls -ld "$settings_dir" | awk '{print $3 ":" $4}')"
                    echo -e "  ${BLUE}Writable:${NC} $([ -w "$settings_dir" ] && echo "${GREEN}YES${NC}" || echo "${RED}NO${NC}")"
                    echo -e "  ${BLUE}Readable:${NC} $([ -r "$settings_dir" ] && echo "${GREEN}YES${NC}" || echo "${RED}NO${NC}")"
                else
                    echo -e "${RED}âŒ Settings directory does NOT exist${NC}"
                    echo -e "  ${YELLOW}Will be created on first save${NC}"
                fi
                
                echo -e "\n${YELLOW}${BOLD}=== SETTINGS FILE STATUS ===${NC}"
                if [[ -f "$SETTINGS_FILE" ]]; then
                    echo -e "${GREEN}âœ“ Settings file exists${NC}"
                    echo -e "  ${BLUE}Path:${NC} $(make_clickable_path "$SETTINGS_FILE" "$SETTINGS_FILE")"
                    echo -e "  ${BLUE}Size:${NC} $(stat -c%s -- "$SETTINGS_FILE" 2>/dev/null || echo '0') bytes"
                    echo -e "  ${BLUE}Permissions:${NC} $(ls -l "$SETTINGS_FILE" | awk '{print $1}')"
                    echo -e "  ${BLUE}Owner:${NC} $(ls -l "$SETTINGS_FILE" | awk '{print $3 ":" $4}')"
                    echo -e "  ${BLUE}Readable:${NC} $([ -r "$SETTINGS_FILE" ] && echo "${GREEN}YES${NC}" || echo "${RED}NO${NC}")"
                    echo -e "  ${BLUE}Writable:${NC} $([ -w "$SETTINGS_FILE" ] && echo "${GREEN}YES${NC}" || echo "${RED}NO${NC}")"
                    echo -e "  ${BLUE}Modified:${NC} $(stat -c%y "$SETTINGS_FILE" 2>/dev/null | cut -d'.' -f1)"
                    
                    echo -e "\n${YELLOW}${BOLD}=== FILE VALIDATION ===${NC}"
                    local line_count=$(wc -l < "$SETTINGS_FILE")
                    echo -e "  ${BLUE}Total lines:${NC} $line_count"
                    
                    if grep -q "OUTPUT_DIRECTORY=" "$SETTINGS_FILE" 2>/dev/null; then
                        local saved_output_dir=$(grep "OUTPUT_DIRECTORY=" "$SETTINGS_FILE" | cut -d'=' -f2 | tr -d '"')
                        echo -e "  ${GREEN}âœ“ OUTPUT_DIRECTORY found in file${NC}"
                        echo -e "    ${BLUE}Saved value:${NC} $saved_output_dir"
                        echo -e "    ${BLUE}Current value:${NC} $OUTPUT_DIRECTORY"
                        if [[ "$saved_output_dir" == "$OUTPUT_DIRECTORY" ]]; then
                            echo -e "    ${GREEN}âœ“ Values match${NC}"
                        else
                            echo -e "    ${YELLOW}âš ï¸ Values differ!${NC}"
                        fi
                    else
                        echo -e "  ${RED}âŒ OUTPUT_DIRECTORY NOT found in file${NC}"
                        echo -e "    ${YELLOW}File may be corrupted${NC}"
                    fi
                    
                    if grep -q "QUALITY=" "$SETTINGS_FILE" 2>/dev/null; then
                        local saved_quality=$(grep "QUALITY=" "$SETTINGS_FILE" | head -1 | cut -d'=' -f2 | tr -d '"')
                        echo -e "  ${GREEN}âœ“ QUALITY found in file${NC}"
                        echo -e "    ${BLUE}Saved value:${NC} $saved_quality"
                        echo -e "    ${BLUE}Current value:${NC} $QUALITY"
                    fi
                    
                    echo -e "\n${YELLOW}${BOLD}=== FILE CONTENT SAMPLE ===${NC}"
                    echo -e "${GRAY}First 10 lines:${NC}"
                    head -10 "$SETTINGS_FILE" | while IFS= read -r line; do
                        echo -e "  ${GRAY}$line${NC}"
                    done
                else
                    echo -e "${RED}âŒ Settings file does NOT exist${NC}"
                    echo -e "  ${YELLOW}This is normal for first run${NC}"
                    echo -e "  ${YELLOW}File will be created automatically${NC}"
                fi
                
                echo -e "\n${YELLOW}${BOLD}=== LEGACY CONFIG ===${NC}"
                if [[ -f "$CONFIG_FILE" ]]; then
                    echo -e "${YELLOW}âš ï¸ Legacy config file exists${NC}"
                    echo -e "  ${BLUE}Path:${NC} $CONFIG_FILE"
                    echo -e "  ${BLUE}Size:${NC} $(stat -c%s -- "$CONFIG_FILE" 2>/dev/null || echo '0') bytes"
                    echo -e "  ${CYAN}ðŸ’¡ Consider migrating with: ./convert.sh --save-config${NC}"
                else
                    echo -e "${GREEN}âœ“ No legacy config file - using new settings format${NC}"
                fi
                
                echo -e "\n${YELLOW}${BOLD}=== CURRENT VALUES ===${NC}"
                echo -e "  ${BLUE}OUTPUT_DIRECTORY:${NC} $OUTPUT_DIRECTORY"
                echo -e "  ${BLUE}OUTPUT_DIR_MODE:${NC} $OUTPUT_DIR_MODE"
                echo -e "  ${BLUE}QUALITY:${NC} $QUALITY"
                echo -e "  ${BLUE}RESOLUTION:${NC} $RESOLUTION"
                echo -e "  ${BLUE}FRAMERATE:${NC} $FRAMERATE"
                
                echo -e "\n${YELLOW}${BOLD}=== BACKUP FILES ===${NC}"
                if [[ -f "${SETTINGS_FILE}.backup" ]]; then
                    echo -e "${GREEN}âœ“ Backup exists:${NC} ${SETTINGS_FILE}.backup"
                    echo -e "  ${BLUE}Modified:${NC} $(stat -c%y "${SETTINGS_FILE}.backup" 2>/dev/null | cut -d'.' -f1)"
                else
                    echo -e "${GRAY}No backup file found${NC}"
                fi
                
                echo -e "\n${YELLOW}${BOLD}=== WRITE TEST ===${NC}"
                local test_file="${SETTINGS_FILE}.write_test.$$"
                if echo "test" > "$test_file" 2>/dev/null; then
                    echo -e "${GREEN}âœ“ Write permissions OK${NC}"
                    rm -f "$test_file" 2>/dev/null
                else
                    echo -e "${RED}âŒ Cannot write to settings directory${NC}"
                    echo -e "  ${YELLOW}This will prevent settings from being saved${NC}"
                fi
                
                echo -e "\n${YELLOW}${BOLD}=== RECOMMENDATIONS ===${NC}"
                if [[ ! -f "$SETTINGS_FILE" ]]; then
                    echo -e "${CYAN}ðŸ’¡ Run the script in interactive mode to create settings${NC}"
                    echo -e "   ${GRAY}Command: ./convert.sh${NC}"
                elif [[ ! -r "$SETTINGS_FILE" ]]; then
                    echo -e "${RED}âš ï¸ Fix read permissions:${NC}"
                    echo -e "   ${GRAY}chmod u+r \"$SETTINGS_FILE\"${NC}"
                elif [[ ! -w "$(dirname "$SETTINGS_FILE")" ]]; then
                    echo -e "${RED}âš ï¸ Fix write permissions on directory:${NC}"
                    echo -e "   ${GRAY}chmod u+w \"$(dirname "$SETTINGS_FILE")\"${NC}"
                else
                    echo -e "${GREEN}âœ“ Settings persistence is properly configured${NC}"
                fi
                
                exit 0
                ;;
            --check-permissions|--fix-permissions)
                init_log_directory >/dev/null 2>&1
                echo -e "${CYAN}${BOLD}ðŸ”’ CHECKING FILE PERMISSIONS${NC}\n"
                check_and_fix_permissions
                exit 0
                ;;
            --test-termination)
                echo -e "${CYAN}${BOLD}ðŸ§ª TESTING PROCESS GROUP TERMINATION${NC}\n"
                echo -e "${YELLOW}Process Group ID: $SCRIPT_PGID${NC}"
                echo -e "${YELLOW}Script PID: $SCRIPT_PID${NC}"
                echo -e "${YELLOW}Terminal Bound: $TERMINAL_BOUND${NC}\n"
                
                echo -e "${BLUE}Starting test ffmpeg processes...${NC}"
                # Start a few test ffmpeg processes in background for testing
                for i in {1..3}; do
                    (
                        ffmpeg -f lavfi -i testsrc=duration=30:size=320x240:rate=1 -y "/tmp/test_$i.mp4" 2>/dev/null
                    ) &
                    local test_pid=$!
                    echo -e "  ${GREEN}âœ“ Started test ffmpeg $i as PID $test_pid${NC}"
                    SCRIPT_FFMPEG_PIDS+=("$test_pid")
                done
                
                echo -e "\n${YELLOW}Test processes started. Try one of these:${NC}"
                echo -e "  ${CYAN}1. Press Ctrl+C to test interrupt handling${NC}"
                echo -e "  ${CYAN}2. Close this terminal to test terminal disconnect${NC}"
                echo -e "  ${CYAN}3. Kill this script from another terminal${NC}"
                echo -e "\n${MAGENTA}Waiting 30 seconds or until interrupted...${NC}"
                
                # Wait and show process status
                for ((i=1; i<=30; i++)); do
                    echo -ne "\r${BLUE}Waiting... ${i}/30s - Active ffmpeg: $(pgrep ffmpeg | wc -l)${NC}"
                    sleep 1
                done
                
                echo -e "\n${GREEN}Test completed - cleaning up${NC}"
                kill_entire_process_group TERM
                sleep 2
                kill_entire_process_group KILL
                echo -e "${GREEN}âœ“ All test processes should be terminated${NC}"
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version|-v)
                show_version_info
                exit 0
                ;;
            --check-update)
                check_for_updates
                exit 0
                ;;
            --update)
                manual_update
                exit 0
                ;;
            --save-config)
                save_config
                exit 0
                ;;
            --show-logs)
                init_log_directory >/dev/null 2>&1
                echo -e "${CYAN}${BOLD}ðŸ“ LOG DIRECTORY INFORMATION:${NC}\n"
                local log_dir_display="$(echo "$LOG_DIR" | sed "s|$HOME|~|g")"
                local error_log_display="$(echo "$ERROR_LOG" | sed "s|$HOME|~|g")"
                local conv_log_display="$(echo "$CONVERSION_LOG" | sed "s|$HOME|~|g")"
                local clickable_log_dir=$(make_clickable_path "$LOG_DIR" "$log_dir_display")
                local clickable_error_log=$(make_clickable_path "$ERROR_LOG" "$error_log_display")
                local clickable_conv_log=$(make_clickable_path "$CONVERSION_LOG" "$conv_log_display")
                echo -e "${YELLOW}Log Directory:${NC} $clickable_log_dir"
                echo -e "${YELLOW}Error Log:${NC} $clickable_error_log"
                echo -e "${YELLOW}Conversion Log:${NC} $clickable_conv_log\n"
                
                if [[ -f "$ERROR_LOG" ]]; then
                    local error_lines=$(wc -l < "$ERROR_LOG")
                    echo -e "${GREEN}âœ“ Error log exists ($error_lines lines)${NC}"
                else
                    echo -e "${YELLOW}âš  No error log found${NC}"
                fi
                
                if [[ -f "$CONVERSION_LOG" ]]; then
                    local conv_lines=$(wc -l < "$CONVERSION_LOG")
                    echo -e "${GREEN}âœ“ Conversion log exists ($conv_lines lines)${NC}"
                else
                    echo -e "${YELLOW}âš  No conversion log found${NC}"
                fi
                
                echo -e "\n${BLUE}Commands to view logs:${NC}"
                echo -e "  tail -f \"$ERROR_LOG\"       # Follow error log"
                echo -e "  tail -20 \"$CONVERSION_LOG\"  # Last 20 conversions"
                echo -e "  ls -la \"$LOG_DIR\"         # List all log files"
                exit 0
                ;;
            --check-cache|--validate-cache)
                init_log_directory >/dev/null 2>&1
                local validation_cache="$LOG_DIR/validation_cache.db"
                echo -e "${CYAN}${BOLD}ðŸ›¡ï¸ VALIDATION CACHE CHECK:${NC}\n"
                
                if [[ ! -f "$validation_cache" ]]; then
                    echo -e "${YELLOW}âš ï¸ No validation cache found${NC}"
                    echo -e "${BLUE}â„¹ï¸ Cache will be created on first validation${NC}"
                    exit 0
                fi
                
                local cache_size=$(stat -c%s -- "$validation_cache" 2>/dev/null | numfmt --to=iec)
                local cache_entries=$(grep -c '|' "$validation_cache" 2>/dev/null || echo "0")
                echo -e "${YELLOW}Cache Location:${NC} $(make_clickable_path "$validation_cache" "${validation_cache/$HOME/~}")"
                echo -e "${YELLOW}Cache Size:${NC} $cache_size ($cache_entries entries)"
                
                # Validate cache format
                local corrupted=0
                local valid=0
                local invalid=0
                
                while IFS='|' read -r filepath filesize mtime status; do
                    [[ "$filepath" =~ ^# ]] && continue  # Skip comments
                    if [[ -z "$filepath" || -z "$filesize" || -z "$mtime" || ! "$status" =~ ^(VALID|INVALID)$ ]]; then
                        ((corrupted++))
                    elif [[ "$status" == "VALID" ]]; then
                        ((valid++))
                    else
                        ((invalid++))
                    fi
                done < "$validation_cache"
                
                echo -e "\n${GREEN}âœ“ Valid entries:${NC} $valid"
                echo -e "${RED}âœ— Invalid entries:${NC} $invalid"
                
                if [[ $corrupted -gt 0 ]]; then
                    echo -e "${YELLOW}âš ï¸ Corrupted entries:${NC} $corrupted"
                    echo -e "\n${YELLOW}Recommendation: Rebuild cache with --clear-cache${NC}"
                else
                    echo -e "${GREEN}âœ“ Cache integrity: OK${NC}"
                fi
                
                echo -e "\n${BLUE}Commands:${NC}"
                echo -e "  ./convert.sh --clear-cache      # Clear validation cache"
                echo -e "  rm \"$validation_cache\"    # Manually delete cache"
                exit 0
                ;;
            --clear-cache)
                init_log_directory >/dev/null 2>&1
                local validation_cache="$LOG_DIR/validation_cache.db"
                if [[ -f "$validation_cache" ]]; then
                    local backup="${validation_cache}.backup.$(date +%s)"
                    mv "$validation_cache" "$backup"
                    echo -e "${GREEN}âœ“ Validation cache cleared${NC}"
                    echo -e "${BLUE}â„¹ï¸ Backup saved: $(basename -- "$backup")${NC}"
                else
                    echo -e "${YELLOW}âš ï¸ No validation cache to clear${NC}"
                fi
                exit 0
                ;;
            --no-tmux)
                # Internal flag used by tmux wrapper - skip and continue
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo -e "${YELLOW}Use --help for available options${NC}"
                exit 1
                ;;
        esac
    done
    
    # If no meaningful arguments provided (or only --no-tmux), enable interactive mode
    if [[ $has_meaningful_args == false ]]; then
        show_welcome
        show_main_menu
        exit 0
    fi
    
    # Count total files
    shopt -s nullglob
    for file in *.mp4 *.avi *.mov *.mkv *.webm; do
        if [[ -f "$file" ]]; then
            ((total_files++)) || true
        fi
    done
    shopt -u nullglob
    
    if [[ $total_files -eq 0 ]]; then
        echo -e "${RED}âŒ No video files found in current directory${NC}"
        exit 1
    fi
    
    echo -e "${BLUE}ðŸŽ¯ Found $total_files video files to process${NC}"
    
    # Interactive mode for settings selection
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        select_quality_preset
        select_aspect_ratio
        echo ""
    fi
    
    echo -e "${YELLOW}âš™ï¸  Quality: $QUALITY | Resolution: $RESOLUTION | FPS: $FRAMERATE | Aspect: $ASPECT_RATIO${NC}"
    
    # Preload files into memory cache for faster access
    if [[ ${#files_to_process[@]} -gt 1 ]]; then
        preload_files_to_cache "${files_to_process[@]}"
    fi
    
    # Confirmation in interactive mode
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        echo -ne "\n${MAGENTA}Proceed with conversion? [Y/n]: ${NC}"
        read -r confirm
        if [[ "$confirm" =~ ^[Nn]$ ]]; then
            echo -e "${YELLOW}Operation cancelled by user${NC}"
            exit 0
        fi
    fi
    
    # Call the main conversion function
    start_conversion
}

# ðŸŽ¬ Execute main function
main "$@"
